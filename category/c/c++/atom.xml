<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>mioe • Posts by &#34;c/c++&#34; category</title>
    <link href="http://example.com" />
    <updated>2023-02-07T11:45:54.000Z</updated>
    <category term="BFS" />
    <category term="算法" />
    <category term="Resilio Sync" />
    <category term="unity" />
    <category term="WolfraAlpha" />
    <category term="数论" />
    <category term="github" />
    <category term="linux" />
    <category term="Open-cv" />
    <category term="碧蓝航线" />
    <category term="Python" />
    <category term="模板" />
    <category term="局域网" />
    <category term="阅读" />
    <category term="相册" />
    <category term="算法模板" />
    <entry>
        <id>http://example.com/2023/02/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
        <title>最小生成树</title>
        <link rel="alternate" href="http://example.com/2023/02/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
        <content type="html">&lt;h1 id=&#34;最短生成树&#34;&gt;&lt;a href=&#34;#最短生成树&#34; class=&#34;headerlink&#34; title=&#34;最短生成树&#34;&gt;&lt;/a&gt;最短生成树&lt;/h1&gt;&lt;h2 id=&#34;Prim&#34;&gt;&lt;a href=&#34;#Prim&#34; class=&#34;headerlink&#34; title=&#34;Prim&#34;&gt;&lt;/a&gt;Prim&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;

const int N = 505, INF = 0x3f3f3f3f;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

intprim()
&amp;#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;   // 第一个点一定在最小生成树中

    int res = 0;  // 用来存放权值之和
    for(int i = 0; i &amp;lt; n; i ++)
    &amp;#123;
        int t = -1;
        for(int j = 1; j &amp;lt;= n; j ++)
            if(!st[j] &amp;amp;&amp;amp; (t == -1 || dist[j] &amp;lt; dist[t]))
                t = j;

        if(dist[t] == INF) return INF;   // 尽早跳出循环防止TLE，如果不加则需要在输出的地方更改
        res += dist[t];
        st[t] = true;

        for(int j = 1; j &amp;lt;= n; j ++)
            dist[j] = min(dist[j], g[t][j]); // 注意和dijkstra的区别
                                             // prim的dist是到已经生成的树的最短距离
    &amp;#125;
    return res;
&amp;#125;


intmain()
&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    memset(g, 0x3f, sizeof g);

    while(m --)
    &amp;#123;
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    &amp;#125;

    int t = prim();

    if(t == INF) cout &amp;lt;&amp;lt; &amp;quot;impossible&amp;quot; &amp;lt;&amp;lt; endl;  // 如果上面不及时跳出循环则在这里改为(t &amp;gt;= INF / 2)
    else cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kruskal&#34;&gt;&lt;a href=&#34;#kruskal&#34; class=&#34;headerlink&#34; title=&#34;kruskal&#34;&gt;&lt;/a&gt;kruskal&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

structNode&amp;#123;
    int a, b, w;
  
    bool operator&amp;lt; (const Node &amp;amp;N) const &amp;#123;
        return w &amp;lt; N.w;
    &amp;#125;
&amp;#125;edges[N];

int n, m, res, cnt;
int g[N];

intfind(int a)&amp;#123;
    if (a != g[a]) g[a] = find(g[a]);
    return g[a];
&amp;#125;

intkruskal()&amp;#123;
    for (int i = 0; i &amp;lt; m; i++) &amp;#123;
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
  
        a = find(a), b = find(b);  
        if (a != b) &amp;#123;
            g[a] = b;
            res += w;
            cnt++;
        &amp;#125;
    &amp;#125;
  
    if (cnt &amp;lt; n - 1) return -1;
    else return res;
&amp;#125;

intmain()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
  
    for (int i = 0; i &amp;lt; m; i++) &amp;#123;
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        edges[i] = &amp;#123;a, b, c&amp;#125;;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; i++) g[i] = i;
    sort(edges, edges + m);
  
    int t = kruskal();
    cout &amp;lt;&amp;lt; t;
  
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-07T11:45:54.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</id>
        <title>字符串哈希</title>
        <link rel="alternate" href="http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1010, P = 131;

unsigned long long h[N], p[N];
int n, m;
char str[N];

unsigned long long gethash(int l, int r)&amp;#123;
    return h[r] - h[l - 1] * p[r - l + 1];
&amp;#125;

int main()&amp;#123;
    scanf(&amp;quot;%d %d %s&amp;quot;, &amp;amp;n, &amp;amp;m, str + 1);

    p[0] = 1;
    for(int i = 1; i &amp;lt;= n; i++)&amp;#123;
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    &amp;#125;

    int l1, r1, l2, r2;
    while(m--)&amp;#123;
        scanf(&amp;quot;%d %d %d %d&amp;quot;, &amp;amp;l1, &amp;amp;r1, &amp;amp;l2, &amp;amp;r2);
        if(gethash(l1, r1) == gethash(l2, r2)) printf(&amp;quot;Yes\n&amp;quot;);
        else printf(&amp;quot;No\n&amp;quot;);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-02T08:36:57.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/</id>
        <title>小根堆</title>
        <link rel="alternate" href="http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1e6+10;

int hp[N], idx;
int n;

void down(int k)&amp;#123;
    int t = k;
    if(hp[k &amp;lt;&amp;lt; 1] &amp;lt; hp[t] &amp;amp;&amp;amp; (k &amp;lt;&amp;lt; 1) &amp;lt;= idx) t = k &amp;lt;&amp;lt; 1;
    if(hp[k &amp;lt;&amp;lt; 1 | 1] &amp;lt; hp[t] &amp;amp;&amp;amp; (k &amp;lt;&amp;lt; 1 | 1) &amp;lt;= idx) t = k &amp;lt;&amp;lt; 1 | 1;
    if(t != k)&amp;#123;
        swap(hp[k], hp[t]);
        down(t);
    &amp;#125;
&amp;#125;

void up(int k)&amp;#123;
    while(k &amp;gt;&amp;gt; 1 &amp;amp;&amp;amp; hp[k &amp;gt;&amp;gt; 1] &amp;gt; hp[k])&amp;#123;
        swap(hp[k &amp;gt;&amp;gt; 1], hp[k]);
        k &amp;gt;&amp;gt;= 1;
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);

    int x, y;
    while(n--)&amp;#123;
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;x);
        if(x == 1)&amp;#123;
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;y);
            hp[++idx] = y;
            up(idx);
        &amp;#125;else if(x == 2) printf(&amp;quot;%d\n&amp;quot;, hp[1]);
        else hp[1] = hp[idx], idx--, down(1);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-01T10:38:45.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/30/KMP/</id>
        <title>KMP</title>
        <link rel="alternate" href="http://example.com/2023/01/30/KMP/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100, M = 1000;

int n, m;
char p[N], s[M];
int ne[N];

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; p + 1 &amp;gt;&amp;gt; m &amp;gt;&amp;gt; s + 1;

    for(int i = 2, j = 0; i &amp;lt;= n; i++)&amp;#123;
        while(j &amp;amp;&amp;amp; p[i] != p[j + 1]) j = ne[j];
        if(p[i] == p[j + 1]) j++;
        ne[i] = j;
    &amp;#125;

    for(int i = 1, j = 0; i &amp;lt;= m; i++)&amp;#123;
        while(j &amp;amp;&amp;amp; s[i] != p[j + 1]) j = ne[j];
        if(s[i] == p[j + 1]) j++;
        if(j == n)&amp;#123;
            printf(&amp;quot;%d&amp;quot;, i - n);
            break;
        &amp;#125;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-30T10:25:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/30/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89/</id>
        <title>单调栈、滑动窗口（单调队列）</title>
        <link rel="alternate" href="http://example.com/2023/01/30/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89/"/>
        <content type="html">&lt;h4 id=&#34;单调栈&#34;&gt;&lt;a href=&#34;#单调栈&#34; class=&#34;headerlink&#34; title=&#34;单调栈&#34;&gt;&lt;/a&gt;单调栈&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

int stk[N], arr[N];
int n, t;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        cin &amp;gt;&amp;gt; arr[i];
        while(t &amp;amp;&amp;amp; arr[i] &amp;lt;= stk[t]) t--;
    
        if(t) cout &amp;lt;&amp;lt; stk[t] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    
        stk[++t] = arr[i];
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;单调队列&#34;&gt;&lt;a href=&#34;#单调队列&#34; class=&#34;headerlink&#34; title=&#34;单调队列&#34;&gt;&lt;/a&gt;单调队列&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

int arr[N], q[N];
int n, k;

int main()&amp;#123;
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;k);

    for(int i = 0; i &amp;lt; n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;arr[i]);

    int h = 0, r = -1;
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        if(h &amp;lt;= r &amp;amp;&amp;amp; i - k + 1 &amp;gt; q[h]) h++;

        while(h &amp;lt;= r &amp;amp;&amp;amp; arr[q[r]] &amp;gt;= arr[i]) r--;

        q[++r] = i;

        if(i &amp;gt;= k - 1) printf(&amp;quot;%d &amp;quot;, arr[q[h]]);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-30T09:07:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/20/%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
        <title>双指针数组去重</title>
        <link rel="alternate" href="http://example.com/2023/01/20/%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

int n; 
int arr[N];

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    for(int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; arr[i];

    int j = 0;	// 非重复个数
    for(int i = 0; i &amp;lt; n; i++)
        if(!i || arr[i] != arr[i - 1])
            arr[j++] = arr[i];

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-20T12:23:01.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/08/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</id>
        <title>树的直径</title>
        <link rel="alternate" href="http://example.com/2023/01/08/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100010;

struct Node&amp;#123;
    int id, w;
&amp;#125;;

vector&amp;lt;Node&amp;gt; m[N];
int dist[N];
int n;

void dfs(int idx, int root, int dst)&amp;#123;
    dist[idx] = dst;
    for(auto node : m[idx])
        if(node.id != root)	dfs(node.id, idx, dst + node.w);
&amp;#125;

int main()&amp;#123;
    int p, q, d, t;
    cin &amp;gt;&amp;gt; n;
    t = n - 1;
    while(t--)&amp;#123;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;p, &amp;amp;q, &amp;amp;d);
        m[p].push_back(&amp;#123;q, d&amp;#125;);
        m[q].push_back(&amp;#123;p, d&amp;#125;);
    &amp;#125;
    dfs(1, -1, 0);
    int idx = 1;
    for(int i = 1; i &amp;lt;= n; i++)
        if(dist[i] &amp;gt; dist[idx]) idx = i;
    dfs(idx, -1, 0);
    for(int i = 1; i &amp;lt;= n; i++)
        if(dist[i] &amp;gt; dist[idx]) idx = i;
    idx = dist[idx];
    printf(&amp;quot;%lld&amp;quot;, 10 * idx + (1ll + idx) * idx / 2);	

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-08T08:58:43.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/05/BFS%E6%A8%A1%E6%9D%BF/</id>
        <title>BFS模板</title>
        <link rel="alternate" href="http://example.com/2023/01/05/BFS%E6%A8%A1%E6%9D%BF/"/>
        <content type="html">&lt;h4 id=&#34;题目&#34;&gt;&lt;a href=&#34;#题目&#34; class=&#34;headerlink&#34; title=&#34;题目&#34;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行，&lt;/p&gt;
&lt;p&gt;对于每一组数据，输出吃到奶酪的最少单位时间。&lt;/p&gt;
&lt;p&gt;若无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。&lt;/p&gt;
&lt;p&gt;在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。&lt;/p&gt;
&lt;h4 id=&#34;模板&#34;&gt;&lt;a href=&#34;#模板&#34; class=&#34;headerlink&#34; title=&#34;模板&#34;&gt;&lt;/a&gt;模板&lt;/h4&gt;&lt;h6 id=&#34;二维&#34;&gt;&lt;a href=&#34;#二维&#34; class=&#34;headerlink&#34; title=&#34;二维&#34;&gt;&lt;/a&gt;二维&lt;/h6&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 210;

// 方向偏移量
int dx[4] = &amp;#123;-1, 0, 1, 0&amp;#125;;
int dy[4] = &amp;#123;0, 1, 0, -1&amp;#125;;
// 距离
int dist[N][N];
int n, m;
pair&amp;lt;int, int&amp;gt; start;
pair&amp;lt;int, int&amp;gt; ed;
// 迷宫
char g[N][N];

int bfs(pair&amp;lt;int, int&amp;gt; s, pair&amp;lt;int, int&amp;gt; e)&amp;#123;
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
    memset(dist, -1, sizeof dist);

    dist[s.first][s.second] = 0;						// 起点
    q.push(s);

    while(!q.empty())&amp;#123;
        pair&amp;lt;int, int&amp;gt; t = q.front();
        q.pop();

        if(t == e) return dist[t.first][t.second];			// 判断是否终点

        for(int i = 0; i &amp;lt; 4; i++)&amp;#123;
            int x = t.first + dx[i];
            int y = t.second + dy[i];
            if(x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= n || y &amp;gt;= m) continue;	// 越界
            if(g[x][y] == &amp;#39;#&amp;#39;) continue;				// 碰墙
            if(dist[x][y] != -1) continue;				// 已遍历

            dist[x][y] = dist[t.first][t.second] + 1;		// 距离加一
            q.push(&amp;#123;x, y&amp;#125;);
        &amp;#125;
    &amp;#125;

    return -1;
&amp;#125;

int main()&amp;#123;
    int t;
    cin &amp;gt;&amp;gt; t;
    while(t--)&amp;#123;
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;m);
        for(int i = 0; i &amp;lt; n; i++) scanf(&amp;quot;%s&amp;quot;, g[i]);
        for(int i = 0; i &amp;lt; n; i++)&amp;#123;
            for(int j = 0; j &amp;lt; m; j++)&amp;#123;
                if(g[i][j] == &amp;#39;S&amp;#39;) start = &amp;#123;i, j&amp;#125;;
                if(g[i][j] == &amp;#39;E&amp;#39;) ed = &amp;#123;i, j&amp;#125;;
            &amp;#125;
        &amp;#125;

        int d = bfs(start, ed);
        if(d == -1) printf(&amp;quot;oop!\n&amp;quot;);
        else printf(&amp;quot;%d\n&amp;quot;, d);
    &amp;#125;


    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;三维&#34;&gt;&lt;a href=&#34;#三维&#34; class=&#34;headerlink&#34; title=&#34;三维&#34;&gt;&lt;/a&gt;三维&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 101;

pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; start, ed, tmp;
char g[N][N][N];
int st[N][N][N];
int dy[4] = &amp;#123;-1, 0, 1, 0&amp;#125;;
int dz[4] = &amp;#123;0, -1, 0, 1&amp;#125;;
int l, r, c;

int bfs(pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; s, pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; e)&amp;#123;
    memset(st, -1, sizeof st);
    queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; q;
    st[s.first][s.second.first][s.second.second] = 0;
    q.push(s);

    while(!q.empty())&amp;#123;
        tmp = q.front();
        q.pop();
        if(tmp == e) return st[tmp.first][tmp.second.first][tmp.second.second];
    
        int x = tmp.first, y, z;
    
        if(x + 1 &amp;lt; l &amp;amp;&amp;amp; st[x + 1][tmp.second.first][tmp.second.second] == -1 &amp;amp;&amp;amp; g[x + 1][tmp.second.first][tmp.second.second] != &amp;#39;#&amp;#39;)&amp;#123;
            st[x + 1][tmp.second.first][tmp.second.second] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x + 1, &amp;#123;tmp.second.first, tmp.second.second&amp;#125;&amp;#125;);
        &amp;#125;
        if(x - 1 &amp;gt;= 0 &amp;amp;&amp;amp; st[x - 1][tmp.second.first][tmp.second.second] == -1 &amp;amp;&amp;amp; g[x - 1][tmp.second.first][tmp.second.second] != &amp;#39;#&amp;#39;)&amp;#123;
            st[x - 1][tmp.second.first][tmp.second.second] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x - 1, &amp;#123;tmp.second.first, tmp.second.second&amp;#125;&amp;#125;);
        &amp;#125;
    
        for(int i = 0; i &amp;lt; 4; i++)&amp;#123;
            y = tmp.second.first + dy[i];
            z = tmp.second.second + dz[i];
            if(st[x][y][z] != -1) continue;
            if(y &amp;lt; 0 || z &amp;lt; 0 || y &amp;gt;= r || z &amp;gt;= c) continue;
            if(g[x][y][z] == &amp;#39;#&amp;#39;) continue;
        
            st[x][y][z] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x, &amp;#123;y, z&amp;#125;&amp;#125;);
        &amp;#125;
    
    
    &amp;#125;

    return -1;
&amp;#125;

int main()&amp;#123;
    while(1)&amp;#123;
        cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;
        if(l == 0) break;
        for(int i = 0; i &amp;lt; l; i++)
            for(int j = 0; j &amp;lt; r; j++) 
                scanf(&amp;quot;%s&amp;quot;, g[i][j]);
    
        for(int i = 0; i &amp;lt; l; i++)
            for(int j = 0; j &amp;lt; r; j++)
                for(int z = 0; z &amp;lt; c; z++)
                    if(g[i][j][z] == &amp;#39;S&amp;#39;) start = &amp;#123;i, &amp;#123;j, z&amp;#125;&amp;#125;;
                    else if(g[i][j][z] == &amp;#39;E&amp;#39;) ed = &amp;#123;i, &amp;#123;j, z&amp;#125;&amp;#125;;
    
        int step = bfs(start, ed);
        if(step == -1) printf(&amp;quot;Trapped!\n&amp;quot;);
        else printf(&amp;quot;Escaped in %d minute(s).\n&amp;quot;, step);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="BFS" />
        <updated>2023-01-05T09:40:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91___%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A8%A1%E6%9D%BF/</id>
        <title>线段树 / 树状数组 模板</title>
        <link rel="alternate" href="http://example.com/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91___%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A8%A1%E6%9D%BF/"/>
        <content type="html">&lt;h4 id=&#34;题目&#34;&gt;&lt;a href=&#34;#题目&#34; class=&#34;headerlink&#34; title=&#34;题目&#34;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给定 &lt;strong&gt;n&lt;/strong&gt; 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 &lt;strong&gt;[&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt;]&lt;/strong&gt; 的连续和。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;&lt;a href=&#34;#输入格式&#34; class=&#34;headerlink&#34; title=&#34;输入格式&#34;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行包含两个整数 &lt;strong&gt;n&lt;/strong&gt; 和 &lt;strong&gt;m&lt;/strong&gt;，分别表示数的个数和操作次数。&lt;/p&gt;
&lt;p&gt;第二行包含 &lt;strong&gt;n&lt;/strong&gt; 个整数，表示完整数列。&lt;/p&gt;
&lt;p&gt;接下来 &lt;strong&gt;m&lt;/strong&gt; 行，每行包含三个整数 &lt;strong&gt;k&lt;/strong&gt;,&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt; （&lt;strong&gt;k&amp;#x3D;0&lt;/strong&gt;，表示求子数列 &lt;strong&gt;[a,b]&lt;/strong&gt; 的和；&lt;strong&gt;k&amp;#x3D;1&lt;/strong&gt;，表示第 &lt;strong&gt;a&lt;/strong&gt; 个数加 &lt;strong&gt;b&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;数列从 &lt;strong&gt;1&lt;/strong&gt; 开始计数。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;&lt;a href=&#34;#输出格式&#34; class=&#34;headerlink&#34; title=&#34;输出格式&#34;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;输出若干行数字，表示 &lt;strong&gt;k&lt;/strong&gt;&amp;#x3D;&lt;strong&gt;0&lt;/strong&gt; 时，对应的子数列 &lt;strong&gt;[&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt;]&lt;/strong&gt; 的连续和。&lt;/p&gt;
&lt;h4 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;≤&lt;strong&gt;n&lt;/strong&gt;≤&lt;strong&gt;100000&lt;/strong&gt;,&lt;br&gt;&lt;strong&gt;1&lt;/strong&gt;≤&lt;strong&gt;m&lt;/strong&gt;≤&lt;strong&gt;100000，&lt;br&gt;1&lt;/strong&gt;≤&lt;strong&gt;a&lt;/strong&gt;≤&lt;strong&gt;b&lt;/strong&gt;≤&lt;strong&gt;n&lt;/strong&gt;,&lt;br&gt;数据保证在任何时候，数列中所有元素之和均在 int 范围内。&lt;/p&gt;
&lt;h4 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;10 5
1 2 3 4 5 6 7 8 9 10
1 1 5
0 1 3
0 4 8
1 7 5
0 4 8
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;11
30
35
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;树状数组模板&#34;&gt;&lt;a href=&#34;#树状数组模板&#34; class=&#34;headerlink&#34; title=&#34;树状数组模板&#34;&gt;&lt;/a&gt;树状数组模板&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100010;

int n, m;
int arr[N], tr[N];

int lowbit(int i)&amp;#123;
    return i &amp;amp; -i;
&amp;#125;

void add(int index, int x)&amp;#123;
    for(int i = index; i &amp;lt;= n; i += lowbit(i))
        tr[i] += x;
    return;
&amp;#125;

void change(int index, int x)&amp;#123;
    int c = x - arr[index];
    for(int i = index; i &amp;lt;= n; i += lowbit(i))
        tr[i] += c;
    return;
&amp;#125;

int query(int index)&amp;#123;
    int res = 0;
    for(int i = index; i; i -= lowbit(i))
        res += tr[i];
    return res;
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 1; i &amp;lt;= n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;arr[i]);
    for(int i = 1; i &amp;lt;= n; i++) add(i, arr[i]);

    while(m--)&amp;#123;
        int tag, l, r;
        int res;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;tag, &amp;amp;l, &amp;amp;r);
        if(tag) add(l, r);
        else printf(&amp;quot;%d\n&amp;quot;, query(r) - query(l - 1));
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;线段树模板&#34;&gt;&lt;a href=&#34;#线段树模板&#34; class=&#34;headerlink&#34; title=&#34;线段树模板&#34;&gt;&lt;/a&gt;线段树模板&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100010;

int n, m;
int num[N];

struct node&amp;#123;
    int l, r;
    int sum;
&amp;#125;sgt[N * 4];		// 需要开N * 4

// 更新当前节点
void pushup(int root)&amp;#123;
    sgt[root].sum = sgt[root &amp;lt;&amp;lt; 1].sum + sgt[root &amp;lt;&amp;lt; 1 | 1].sum;
&amp;#125;

// 初始化线段树
void build(int root, int l, int r)&amp;#123;
    if(l == r) sgt[root].sum = num[l];
    else&amp;#123;
        sgt[root] = &amp;#123;l, r&amp;#125;;
        int mid = l + r &amp;gt;&amp;gt; 1;
        build(root &amp;lt;&amp;lt; 1, l, mid);
        build(root &amp;lt;&amp;lt; 1 | 1, mid + 1, r);
        pushup(root);
    &amp;#125;
    return;
&amp;#125;

int query(int root, int l, int r)&amp;#123;
    if(sgt[root].l &amp;gt;= l &amp;amp;&amp;amp; sgt[root].r &amp;lt;= r) return sgt[root].sum;
    int mid = sgt[root].l + sgt[root].r &amp;gt;&amp;gt; 1;
    int sum = 0;
    if(l &amp;lt;= mid) sum += query(root &amp;lt;&amp;lt; 1, l, r);
    if(r &amp;gt; mid) sum += query(root &amp;lt;&amp;lt; 1 | 1, l, r);
    return sum;
&amp;#125;

void modify(int root, int index, int c)&amp;#123;
    if(sgt[root].l == sgt[root].r) sgt[root].sum += c;
    else&amp;#123;
        int mid = sgt[root].l + sgt[root].r &amp;gt;&amp;gt; 1;
        if(index &amp;lt;= mid) modify(root &amp;lt;&amp;lt; 1, index, c);
        else modify(root &amp;lt;&amp;lt; 1 | 1, index, c);
        pushup(root);
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 1; i &amp;lt;= n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;num[i]);
    build(1, 1, n);
    int k, a, b;
    while(m--)&amp;#123;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;k, &amp;amp;a, &amp;amp;b);
        if(k) modify(1, a, b);
        else printf(&amp;quot;%d\n&amp;quot;, query(1, a, b));
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法模板" />
        <updated>2022-12-30T13:40:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/27/stringstream_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC_int_double/</id>
        <title>stringstream 字符串转 int/double</title>
        <link rel="alternate" href="http://example.com/2022/12/27/stringstream_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC_int_double/"/>
        <content type="html">&lt;p&gt;某涉密单位下发了某种票据，并要在年终全部收回。&lt;/p&gt;
&lt;p&gt;每张票据有唯一的ID号。&lt;/p&gt;
&lt;p&gt;全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。&lt;/p&gt;
&lt;p&gt;因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。&lt;/p&gt;
&lt;p&gt;你的任务是通过编程，找出断号的ID和重号的ID。&lt;/p&gt;
&lt;p&gt;假设断号不可能发生在最大和最小号。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;&lt;a href=&#34;#输入格式&#34; class=&#34;headerlink&#34; title=&#34;输入格式&#34;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行包含整数 &lt;strong&gt;N&lt;/strong&gt;，表示后面共有 &lt;strong&gt;N&lt;/strong&gt; 行数据。&lt;/p&gt;
&lt;p&gt;接下来 &lt;strong&gt;N&lt;/strong&gt; 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;&lt;a href=&#34;#输出格式&#34; class=&#34;headerlink&#34; title=&#34;输出格式&#34;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;要求程序输出1行，含两个整数 &lt;strong&gt;m&lt;/strong&gt;,&lt;strong&gt;n&lt;/strong&gt;用空格分隔。&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;m&lt;/strong&gt;表示断号ID，&lt;strong&gt;n&lt;/strong&gt;表示重号ID。&lt;/p&gt;
&lt;h4 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;≤&lt;strong&gt;N&lt;/strong&gt;≤&lt;strong&gt;100&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;2
5 6 8 11 9 
10 12 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;7 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;AC代码&#34;&gt;&lt;a href=&#34;#AC代码&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int a[10001];
int c, n;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    string line;
    getline(cin, line);	\\ cin 会读取换行符
    while(n--)&amp;#123;
        getline(cin, line);
        stringstream ssin(line);
        while(ssin &amp;gt;&amp;gt; a[c])&amp;#123;
            c++;
        &amp;#125;
    &amp;#125;
    sort(a, a + c);
    int r1, r2;
    for(int i = 1; i &amp;lt; c; i++)&amp;#123;
        if(a[i] == a[i - 1]) r1 = a[i];
        if(a[i] - 2 == a[i - 1]) r2 = a[i] - 1;
    &amp;#125;
    cout &amp;lt;&amp;lt; r2 &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; r1;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;stringstream技巧：&#34;&gt;&lt;a href=&#34;#stringstream技巧：&#34; class=&#34;headerlink&#34; title=&#34;stringstream技巧：&#34;&gt;&lt;/a&gt;stringstream技巧：&lt;/h4&gt;&lt;h5 id=&#34;转int-x2F-double&#34;&gt;&lt;a href=&#34;#转int-x2F-double&#34; class=&#34;headerlink&#34; title=&#34;转int&amp;#x2F;double&#34;&gt;&lt;/a&gt;转int&amp;#x2F;double&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;string result = &amp;quot;10000&amp;quot;;	// double 同理, result = &amp;quot;1.5&amp;quot;;
stringstream stream(result);	// 可以是字符串也可以是数字，总之后面直接输入到目标变量里面
int n = 0;
stream &amp;gt;&amp;gt; n;	//n 等于10000
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;转int-x2F-double数组&#34;&gt;&lt;a href=&#34;#转int-x2F-double数组&#34; class=&#34;headerlink&#34; title=&#34;转int&amp;#x2F;double数组&#34;&gt;&lt;/a&gt;转int&amp;#x2F;double数组&lt;/h5&gt;&lt;p&gt;&lt;code&gt;stringstream&lt;/code&gt;以空格作为分隔符&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;string str = &amp;quot;1 2 3 4 5&amp;quot;;	// double 同理
stringstream ssin(str);
int i = 0;
int a[10] = &amp;#123;0&amp;#125;;
while(ssin &amp;gt;&amp;gt; a[i]) i++;	// 此时a[0] = 1, a[1] = 2 ...
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-12-27T12:29:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/25/%E5%9C%A8%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E9%87%8C%E5%A4%84%E7%90%86%E6%B5%AE%E7%82%B9%E6%95%B0/</id>
        <title>在整数运算里处理浮点数</title>
        <link rel="alternate" href="http://example.com/2022/12/25/%E5%9C%A8%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E9%87%8C%E5%A4%84%E7%90%86%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
        <content type="html">&lt;p&gt;&lt;code&gt;n = m / 2&lt;/code&gt; 可以写成 &lt;code&gt;n * 2 = m&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同理：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n &amp;lt; m / 2&lt;/code&gt; -&amp;gt; &lt;code&gt;n * 2 &amp;lt; m&lt;/code&gt;&lt;/p&gt;
</content>
        <updated>2022-12-25T08:23:44.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/21/AcWing_95._%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/</id>
        <title>AcWing 95. 费解的开关</title>
        <link rel="alternate" href="http://example.com/2022/12/21/AcWing_95._%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/"/>
        <content type="html">&lt;p&gt;你玩过“拉灯”游戏吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;25&lt;/strong&gt; 盏灯排成一个 &lt;strong&gt;5&lt;/strong&gt;×&lt;strong&gt;5&lt;/strong&gt; 的方形。&lt;/p&gt;
&lt;p&gt;每一个灯都有一个开关，游戏者可以改变它的状态。&lt;/p&gt;
&lt;p&gt;每一步，游戏者可以改变某一个灯的状态。&lt;/p&gt;
&lt;p&gt;游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。&lt;/p&gt;
&lt;p&gt;我们用数字 &lt;strong&gt;1&lt;/strong&gt; 表示一盏开着的灯，用数字 &lt;strong&gt;0&lt;/strong&gt; 表示关着的灯。&lt;/p&gt;
&lt;p&gt;下面这种状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10111
01101
10111
10000
11011
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在改变了最左上角的灯的状态后将变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;01111
11101
10111
10000
11011
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再改变它正中间的灯后状态将变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;01111
11001
11001
10100
11011
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给定一些游戏的初始状态，编写程序判断游戏者是否可能在 &lt;strong&gt;6&lt;/strong&gt;6 步以内使所有的灯都变亮。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;&lt;a href=&#34;#输入格式&#34; class=&#34;headerlink&#34; title=&#34;输入格式&#34;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行输入正整数 &lt;strong&gt;n&lt;/strong&gt;，代表数据中共有 &lt;strong&gt;n&lt;/strong&gt; 个待解决的游戏初始状态。&lt;/p&gt;
&lt;p&gt;以下若干行数据分为 &lt;strong&gt;n&lt;/strong&gt; 组，每组数据有 &lt;strong&gt;5&lt;/strong&gt; 行，每行 &lt;strong&gt;5&lt;/strong&gt; 个字符。&lt;/p&gt;
&lt;p&gt;每组数据描述了一个游戏的初始状态。&lt;/p&gt;
&lt;p&gt;各组数据间用一个空行分隔。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;&lt;a href=&#34;#输出格式&#34; class=&#34;headerlink&#34; title=&#34;输出格式&#34;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;一共输出 &lt;strong&gt;n&lt;/strong&gt; 行数据，每行有一个小于等于 &lt;strong&gt;6&lt;/strong&gt; 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。&lt;/p&gt;
&lt;p&gt;对于某一个游戏初始状态，若 &lt;strong&gt;6&lt;/strong&gt; 步以内无法使所有灯变亮，则输出 &lt;strong&gt;−1&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;0&lt;/strong&gt;&amp;lt;&lt;strong&gt;n&lt;/strong&gt;≤&lt;strong&gt;500&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出样例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
2
-1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int light[7][7], backup[7][7];

void turn(int x, int y)&amp;#123;
    backup[x][y] = !backup[x][y];
    backup[x - 1][y] = !backup[x - 1][y];
    backup[x][y - 1] = !backup[x ][y - 1];
    backup[x + 1][y] = !backup[x + 1][y];
    backup[x][y + 1] = !backup[x][y + 1];
&amp;#125;

int main()&amp;#123;
    int n;
    string str;
    str.resize(7);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        int res = 10;

        for(int x = 1; x &amp;lt;= 5; x++)&amp;#123;
            string str;
            scanf(&amp;quot;%s&amp;quot;, &amp;amp;str[0]);
            for(int y = 1; y &amp;lt;= 5; y++)
                light[x][y] = str[y - 1] - &amp;#39;0&amp;#39;;
        &amp;#125;
        // 枚举操作而非状态
        // 01001 表示操作第2和第5盏灯
        for(int k = 0; k &amp;lt; 32; k++)&amp;#123;
            memcpy(backup, light, sizeof light);
            int step = 0;
            for(int j = 1; j &amp;lt;= 5; j++)&amp;#123;
                if((k &amp;gt;&amp;gt; (j - 1)) &amp;amp; 1)&amp;#123;
                    turn(1, j);
                    step++;
                &amp;#125;
            &amp;#125;

            for(int j = 2; j &amp;lt;= 5; j++)&amp;#123;
                for(int l = 1; l &amp;lt;= 5; l++)&amp;#123;
                    if(backup[j - 1][l] == 0)&amp;#123;
                        turn(j, l);
                        step++;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
            bool dark = false;
            for(int j = 1; j &amp;lt;= 5; j++)&amp;#123;
                if(backup[5][j] != 1)&amp;#123;
                    dark = true;
                    break;
                &amp;#125;
            &amp;#125;
            if(!dark)&amp;#123;
                res = min(res, step);
            &amp;#125;

        &amp;#125;
        if(res == 10 || res &amp;gt; 6) res = -1;

        cout &amp;lt;&amp;lt; res;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-12-21T11:02:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/19/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2_%EF%BC%88%E5%90%91%E5%B7%A6%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E4%B8%8E%E5%90%91%E5%8F%B3%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E7%9B%B8%E5%B7%AE%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%87_1%EF%BC%89/</id>
        <title>数字三角形 （向左下走的次数与向右下走的次数相差不能超过 1）</title>
        <link rel="alternate" href="http://example.com/2022/12/19/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2_%EF%BC%88%E5%90%91%E5%B7%A6%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E4%B8%8E%E5%90%91%E5%8F%B3%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E7%9B%B8%E5%B7%AE%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%87_1%EF%BC%89/"/>
        <content type="html">&lt;p&gt;&lt;strong&gt;二维数组初始化&lt;code&gt;fill(arr[0], arr[0] + n * n, 0)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;DFS-超时&#34;&gt;&lt;a href=&#34;#DFS-超时&#34; class=&#34;headerlink&#34; title=&#34;DFS 超时&#34;&gt;&lt;/a&gt;DFS 超时&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int num[101][101] = &amp;#123;0&amp;#125;;
int add[101][101] = &amp;#123;0&amp;#125;;
int n;
vector&amp;lt;int&amp;gt; ans;

void dfs(int l, int r, int x, int y)&amp;#123;
  if(l &amp;gt; n/2 || r &amp;gt; n/2)&amp;#123;
    return;
  &amp;#125;
    if(x == n - 1)&amp;#123;
        if(abs(l - r) &amp;gt; 1)&amp;#123;
            return;
        &amp;#125;
        ans.push_back(add[x][y]);
        return;
    &amp;#125;
  
    l++;
    add[x + 1][y] = num[x + 1][y] + add[x][y];
    s(l, r, x + 1, y);
    add[x + 1][y] = num[x + 1][y];
    l--;

    r++;
    add[x + 1][y + 1] = num[x + 1][y + 1] + add[x][y];
    s(l, r, x + 1, y + 1);
    add[x + 1][y + 1] = num[x + 1][y + 1];
    r--;
&amp;#125;

int main()
&amp;#123;
    cin &amp;gt;&amp;gt; n;
  
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        for(int j = 0; j &amp;lt;= i; j++)&amp;#123;
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;num[i][j]);
        &amp;#125;
    &amp;#125;
    add[0][0] = num[0][0];
    dfs(0, 0, 0, 0);
    auto max = max_element(ans.begin(), ans.end());
    cout &amp;lt;&amp;lt; *max;
  
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;动态规划&#34;&gt;&lt;a href=&#34;#动态规划&#34; class=&#34;headerlink&#34; title=&#34;动态规划&#34;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main()
&amp;#123;
    int n;
    cin &amp;gt;&amp;gt; n;
    int num[n][n], dp[n][n];
    fill(num[0], num[0] + n * n, 0);
    fill(dp[0], dp[0] + n * n, 0);
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        for(int j = 0; j &amp;lt;= i; j++)&amp;#123;
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;num[i][j]);
        &amp;#125;
    &amp;#125;
    dp[0][0] = num[0][0];
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        for(int j = 0; j &amp;lt;= i; j++)&amp;#123;
            if(i - 1 &amp;gt;= 0 &amp;amp;&amp;amp; j - 1 &amp;lt; 0)&amp;#123;
                dp[i][j] = dp[i - 1][j] + num[i][j];
            &amp;#125;else if(i - 1 &amp;gt;= 0 &amp;amp;&amp;amp; j - 1 &amp;gt;= 0)&amp;#123;
                dp[i][j] = max(dp[i - 1][j - 1] + num[i][j], dp[i - 1][j] + num[i][j]);
            &amp;#125;
        &amp;#125;
    &amp;#125;
// 因为向左下走的次数与向右下走的次数相差不能超过 1
// 所以答案一定在中间
    if(n%2 == 0)&amp;#123;
        cout &amp;lt;&amp;lt; max(dp[n - 1][n / 2 - 1], dp[n - 1][n / 2]);
    &amp;#125;else&amp;#123;
        cout &amp;lt;&amp;lt; dp[n - 1][n / 2];
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-12-19T12:01:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/06/C++_%E6%8F%90%E5%8F%96%E5%B0%8F%E6%95%B0/</id>
        <title>C++ 提取小数</title>
        <link rel="alternate" href="http://example.com/2022/12/06/C++_%E6%8F%90%E5%8F%96%E5%B0%8F%E6%95%B0/"/>
        <content type="html">&lt;p&gt;OpenAi写的一段代码，太值得学习了&lt;/p&gt;
&lt;p&gt;&lt;del&gt;自己写for循环提取小数实在是太蠢了&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;copy&#34;&gt;&lt;a href=&#34;#copy&#34; class=&#34;headerlink&#34; title=&#34;copy&#34;&gt;&lt;/a&gt;copy&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;std::copy(start, end, std::back_inserter(container));

std::copy(iterator source_first, iterator source_end, iterator target_start);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为第三个参数要接受一个迭代器，所以需要使用&lt;code&gt;back_inserter(container)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;regex&#34;&gt;&lt;a href=&#34;#regex&#34; class=&#34;headerlink&#34; title=&#34;regex&#34;&gt;&lt;/a&gt;regex&lt;/h2&gt;&lt;p&gt;pass&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;string expression = &amp;quot;4.12*3.14&amp;quot;;
regex pattern(&amp;quot;([\\d.]+)|([+\\-*/()])&amp;quot;);
vector&amp;lt;string&amp;gt; words;
copy(
    sregex_token_iterator(expression.begin(), expression.end(), pattern),
    sregex_token_iterator(),
    back_inserter(words));

for(int i = 0; i &amp;lt; words.size(); i++)
    cout &amp;lt;&amp;lt; words[i] &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-12-06T09:45:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/11/28/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
        <title>位运算</title>
        <link rel="alternate" href="http://example.com/2022/11/28/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
        <content type="html">&lt;h6 id=&#34;136-Single-Number&#34;&gt;&lt;a href=&#34;#136-Single-Number&#34; class=&#34;headerlink&#34; title=&#34;136. Single Number&#34;&gt;&lt;/a&gt;136. Single Number&lt;/h6&gt;&lt;p&gt;&lt;img data-src=&#34;https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2022/11/4226140631.png&#34; alt=&#34;136&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换律：a ^ b ^ c &amp;lt;&amp;#x3D;&amp;gt; a ^ c ^ b&lt;/li&gt;
&lt;li&gt;任何数于0异或为任何数 0 ^ n &amp;#x3D;&amp;gt; n&lt;/li&gt;
&lt;li&gt;相同的数异或为0: n ^ n &amp;#x3D;&amp;gt; 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;var a = [2, 3, 2, 4, 4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2 ^ 3 ^ 2 ^ 4 ^ 4 等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 =&amp;gt; 0 ^ 0 ^3 =&amp;gt; 3&lt;/code&gt;&lt;/p&gt;
&lt;h6 id=&#34;1758-Minimum-Changes-To-Make-Alternating-Binary-String&#34;&gt;&lt;a href=&#34;#1758-Minimum-Changes-To-Make-Alternating-Binary-String&#34; class=&#34;headerlink&#34; title=&#34;1758. Minimum Changes To Make Alternating Binary String&#34;&gt;&lt;/a&gt;1758. Minimum Changes To Make Alternating Binary String&lt;/h6&gt;&lt;p&gt;&lt;img data-src=&#34;https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2022/11/2630183447.png&#34; alt=&#34;1758&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;// 1 &amp;amp; 1 = 1

// 1 &amp;amp; 0 = 0

// 0 &amp;amp; 0 = 0

int minOperations(string s) &amp;#123;
        char a[2] = &amp;#123;&amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;&amp;#125;;
        int ans = 0, t = 0;
        for(int i = 0; i &amp;lt; s.size(); i++) &amp;#123;
            if(a[i &amp;amp; 1] == s[i]) ans++;
            else t++;
        &amp;#125;
        return min(ans, t);
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-11-28T03:47:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/11/11/C++%E5%A4%A7%E4%BD%9C%E4%B8%9A/</id>
        <title>C++大作业</title>
        <link rel="alternate" href="http://example.com/2022/11/11/C++%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
        <content type="html">&lt;h4 id=&#34;暂时bug-x2F-问题&#34;&gt;&lt;a href=&#34;#暂时bug-x2F-问题&#34; class=&#34;headerlink&#34; title=&#34;暂时bug&amp;#x2F;问题&#34;&gt;&lt;/a&gt;暂时bug&amp;#x2F;问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;无法计算负数&lt;/li&gt;
&lt;li&gt;只能整数&lt;/li&gt;
&lt;li&gt;减法只能前者大于后者&lt;/li&gt;
&lt;li&gt;无法判断表达式的准确性&lt;/li&gt;
&lt;li&gt;&lt;del&gt;复数实部不能小于0&lt;/del&gt;&lt;br&gt;&lt;em&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;&lt;del&gt;头秃&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;// 标准:GNU C++ 14
// 编译器:GNU GCC 8.1.0 64-bit Debug
#include &amp;lt;bits/stdc++.h&amp;gt;
#define MAX 10000
using namespace std;
stack &amp;lt;char&amp;gt; opt;		// 操作数
stack &amp;lt;string&amp;gt; num;		// 符号位

// 长度判断
int CompareLength(string a, string b) &amp;#123;
    return a.length() &amp;gt;= b.length() ? 1 : 0;
&amp;#125;

// 高精数大小判断
int CompareSize(string a, string b)&amp;#123;
    if(a.length() &amp;gt; b.length()) return 1;
    if(a.length() &amp;lt; b.length()) return -1;
    for(int i = 0; i &amp;lt; a.length(); i++)&amp;#123;
        if(a[i] &amp;gt; b[i]) return 1;
        if(a[i] &amp;lt; b[i]) return -1;
    &amp;#125;
    return 0;
&amp;#125;

// 高精度加法
string BigAdd(string a, string b) &amp;#123;
    int la, lb, up = 0, temp;	// up进位数
    string n;
    la = a.length();
    lb = b.length();
    if (CompareLength(a, b)) &amp;#123;		// 判断长度，短字符串前端补零
        for (int i = 0; i &amp;lt; la - lb; i++)
            b = &amp;quot;0&amp;quot; + b;
    &amp;#125; else &amp;#123;
        for (int i = 0; i &amp;lt; lb - la; i++)
            a = &amp;quot;0&amp;quot; + a;
    &amp;#125;
    for (int i = max(la, lb) - 1; i &amp;gt;= 0; i--) &amp;#123;
        temp = a[i] - &amp;#39;0&amp;#39; + b[i] - &amp;#39;0&amp;#39; + up;	// 目标 = 被加数 + 加数 + 进位数
        up = temp / 10;			// 进位数
        temp %= 10;
        n += char(temp) + &amp;#39;0&amp;#39;;
    &amp;#125;
    if (up != 0) n += char(up) + &amp;#39;0&amp;#39;;		// 99 + 1
    reverse(n.begin(), n.end());

    return n;
&amp;#125;

// 高精度减法
// 被减数需大于减除
string BigSub(string a, string b) &amp;#123;
    int na[MAX] = &amp;#123;0&amp;#125;, nb[MAX] = &amp;#123;0&amp;#125;, an[MAX] = &amp;#123;0&amp;#125;, la, lb;			// 初始化
    string n;
    la = a.length();
    lb = b.length();
    for (int i = 0; i &amp;lt; la; i++) na[la - i - 1] = a[i] - &amp;#39;0&amp;#39;;		// 反转操作数，写入整形数组方便运算
    for (int i = 0; i &amp;lt; lb; i++) nb[lb - i - 1] = b[i] - &amp;#39;0&amp;#39;;
    for (int i = 0; i &amp;lt; la; i++) &amp;#123;
        if (na[i] &amp;lt; nb[i]) &amp;#123;			// 借位操作
            na[i] += 10;
            na[i + 1]--;
        &amp;#125;
        an[i] = na[i] - nb[i];
    &amp;#125;
    for (int i = 0; i &amp;lt; la; i++)			// 写入输出
        n += an[i] + &amp;#39;0&amp;#39;;
    reverse(n.begin(), n.end());			// 反转目标
    n.erase(0, n.find_first_not_of(&amp;#39;0&amp;#39;));			// 去除前导0
    if (n == &amp;quot;&amp;quot;) n = &amp;quot;0&amp;quot;;			// 100-100

    return n;
&amp;#125;

// 高精度乘法
string BigMul(string a, string b) &amp;#123;
    int la, lb, temp_int, up = 0;
    string temp_str, n = &amp;quot;0&amp;quot;;
    la = a.length();
    lb = b.length();
    reverse(a.begin(), a.end());			// 反转方便操作
    reverse(b.begin(), b.end());
    for (int i = 0; i &amp;lt; la; i++) &amp;#123;
        for (int j = 0; j &amp;lt; lb; j++) &amp;#123;
            temp_int = (a[i] - &amp;#39;0&amp;#39;) * (b[j] - &amp;#39;0&amp;#39;) + up;			// 加法同理，进位操作
            up =  temp_int / 10;
            temp_int %= 10;
            temp_str += temp_int + &amp;#39;0&amp;#39;;				// 按位写入临时字符串
            if (up &amp;amp;&amp;amp; j == lb - 1) temp_str += (char)(up + &amp;#39;0&amp;#39;);			// 防止2*5无法进位
        &amp;#125;
        reverse(temp_str.begin(), temp_str.end());
        up = 0;			// 	置空进位符
        for (int j = 0; j &amp;lt; i; j++)	temp_str += &amp;quot;0&amp;quot;;			// 移位处理，n+10*i同理
        //		cout &amp;lt;&amp;lt; temp_str &amp;lt;&amp;lt; endl;
        n = BigAdd(temp_str, n);
        temp_str = &amp;quot;&amp;quot;;			// 置空按位乘
    &amp;#125;
    n.erase(0, n.find_first_not_of(&amp;#39;0&amp;#39;));			// 0*1
    if (n == &amp;quot;&amp;quot;) n = &amp;quot;0&amp;quot;;

    return n;
&amp;#125;

// 高精度除法
string BigDiv(string a, string b, int flag = 1) &amp;#123;
    string temp = b, n;
    int l = a.length() - b.length();			// 商预操作
    for(int i = 0; i &amp;lt; a.length(); i++) n += &amp;quot;0&amp;quot;;			// 商预操作
    for(int i = l; i &amp;gt;= 0; i--)&amp;#123;
        for(int j = 0; j &amp;lt; i; j++)&amp;#123;			// 被除数添零
            temp += &amp;quot;0&amp;quot;;
        &amp;#125;
        while(CompareSize(a, temp) &amp;gt;= 0)&amp;#123;
            n[i]++;
            a = BigSub(a, temp);			// 减法模拟
        &amp;#125;
        temp = b;
    &amp;#125;
    reverse(n.begin(), n.end());
    n.erase(0, n.find_first_not_of(&amp;quot;0&amp;quot;));
    if (n == &amp;quot;&amp;quot;) n = &amp;quot;0&amp;quot;;

    if(flag) return n;
    else return a;			// a为余数
&amp;#125;

string BigMod(string a, string b) &amp;#123;	return BigDiv(a, b, 0); &amp;#125;

// 中缀
int Priority(char a) &amp;#123;		// 符号优先级
    if (a == &amp;#39;+&amp;#39; || a == &amp;#39;-&amp;#39;) return 1;
    else if (a == &amp;#39;*&amp;#39; || a == &amp;#39;/&amp;#39;) return 2;
    else return -1;
&amp;#125;

void Clc(char tag) &amp;#123;
    string a = num.top();
    num.pop();
    string b = num.top();
    num.pop();
    if (tag == &amp;#39;+&amp;#39;) num.push(BigAdd(a, b));
    else if (tag == &amp;#39;-&amp;#39;) num.push(BigSub(b, a));			// 注意出栈顺序
    else if (tag == &amp;#39;*&amp;#39;) num.push(BigMul(a, b));
    else if (tag == &amp;#39;/&amp;#39;) num.push(BigDiv(b, a));
    else if (tag == &amp;#39;%&amp;#39;) num.push(BigMod(b, a));
&amp;#125;

// 整数运算
string InitNum(string str)&amp;#123;
    string temp;
    bool flag = false;
    for (int i = 0; i &amp;lt; str.length(); i++) &amp;#123;
        if (str[i] &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; str[i] &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
            temp += str[i];
            flag = true;			// 为后续判断是否有剩余未入栈，如 1+1
        &amp;#125; else if (flag) &amp;#123;
            num.push(temp);
            temp = &amp;quot;&amp;quot;;
            flag = false;
        &amp;#125;
        if (str[i] == &amp;#39;(&amp;#39;) opt.push(str[i]);
        if (str[i] == &amp;#39;+&amp;#39; || str[i] == &amp;#39;-&amp;#39; || str[i] == &amp;#39;*&amp;#39; || str[i] == &amp;#39;/&amp;#39; || str[i] == &amp;#39;%&amp;#39;) &amp;#123;
            if (opt.empty())	opt.push(str[i]);			// 栈空直接入栈
            else &amp;#123;
                if (Priority(opt.top()) &amp;gt;= Priority(str[i])) &amp;#123;			// 判断优先级，当栈顶大于等于当前操作符，当前操作符不入栈直接运算
                    Clc(opt.top());
                    opt.pop();
                    opt.push(str[i]);			// 运算结束，高优先级出栈，当前操作符入栈
                &amp;#125; else opt.push(str[i]);			// 反之出栈
            &amp;#125;
        &amp;#125;
        if (str[i] == &amp;#39;)&amp;#39;) &amp;#123;			// 右括号全出栈，直至栈顶为左括号相匹配结束出栈
            while (opt.top() != &amp;#39;(&amp;#39;) &amp;#123;
                Clc(opt.top());
                opt.pop();
            &amp;#125;
            opt.pop();			// 弹出左括号
        &amp;#125;
    &amp;#125;
    if (flag) num.push(temp);			// 标记判断是否有剩余为入栈
    // 操作符平级
    while (!opt.empty()) &amp;#123;			// 循环结束到操作栈为空
        Clc(opt.top());
        opt.pop();
    &amp;#125;
    //	cout &amp;lt;&amp;lt; num.top();

    return num.top();
&amp;#125;

// 复数运算
complex&amp;lt;long int&amp;gt; Clc_complex(char tag, complex&amp;lt;long int&amp;gt; c1, complex&amp;lt;long int&amp;gt; c2) &amp;#123;
    if (tag == &amp;#39;+&amp;#39;)	return c1+c2;
    else if (tag == &amp;#39;-&amp;#39;) return c1-c2;
    else if (tag == &amp;#39;*&amp;#39;) return c1*c2;
    else if (tag == &amp;#39;/&amp;#39;) return c1/c2;
&amp;#125;

string InitComplex(string str)&amp;#123;
    string com = &amp;quot;&amp;quot;, tempReal = &amp;quot;&amp;quot;, tempComplex = &amp;quot;&amp;quot;;		// 临时复数、临时实部、临时虚部
    char complexOpt;			// 虚部符号位
    int indexRight, indexLeft;
    int complexCount;			// 复数个数
    for (int i = 0; i &amp;lt; str.length(); i++)		// 判断复数个数，一个i为一个复数
        if(str[i] == &amp;#39;i&amp;#39;) complexCount++;
    complex&amp;lt;long int&amp;gt; c[complexCount];
    complexCount = 0;
    while(str != &amp;quot;&amp;quot;)&amp;#123;
        // 提取复数
        indexRight = str.find(&amp;#39;(&amp;#39;);
        indexLeft = str.find(&amp;#39;)&amp;#39;);
        com = str.substr(indexRight, indexLeft + 1);
        complexOpt = com.find(&amp;#39;+&amp;#39;)!=string::npos?&amp;#39;+&amp;#39;:&amp;#39;-&amp;#39;;
        tempReal = com.substr(1, com.find(complexOpt) - 1);
        tempComplex = com.substr(com.find(complexOpt) + 1, com.length() - 4 - tempReal.length());
//		cout &amp;lt;&amp;lt; com.length() &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt;tempReal &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; tempComplex &amp;lt;&amp;lt; endl;
        c[complexCount] = &amp;#123;stol(tempReal), stol(complexOpt+tempComplex)&amp;#125;;
        // 提取完成后擦除
        str.erase(indexRight, indexLeft + 1);
        // 四则运算判断优先级
        if (str[0] == &amp;#39;+&amp;#39; || str[0] == &amp;#39;-&amp;#39; || str[0] == &amp;#39;*&amp;#39; || str[0] == &amp;#39;/&amp;#39;) &amp;#123;
            if (opt.empty())	opt.push(str[0]);			// 栈空直接入栈
            else &amp;#123;
                if (Priority(opt.top()) &amp;gt;= Priority(str[0])) &amp;#123;			// 判断优先级，当栈顶大于等于当前操作符，当前操作符不入栈直接运算
                    c[complexCount - 1] = Clc_complex(opt.top(), c[complexCount - 1], c[complexCount]);
//					cout &amp;lt;&amp;lt; c[complexCount - 1];
                    complexCount -= 1;
                    opt.pop();
                    opt.push(str[0]);			// 运算结束，高优先级出栈，当前操作符入栈
                &amp;#125; else opt.push(str[0]);			// 反之入栈
            &amp;#125;
            // 擦除操作符
            str.erase(0, 1);
        &amp;#125;
        complexCount++;
    &amp;#125;
    // 操作符平级
    while (!opt.empty()) &amp;#123;
        c[complexCount - 2] = Clc_complex(opt.top(), c[complexCount - 2], c[complexCount - 1]);
        complexCount--;
        opt.pop();
    &amp;#125;

    com = to_string(c[0].real()) + complexOpt + to_string(c[0].imag()) + &amp;#39;i&amp;#39;;
    complexOpt = (c[0].imag() &amp;lt; 0)?&amp;#39;-&amp;#39;:&amp;#39;+&amp;#39;;

    return com;
&amp;#125;

// 判断复数、实数
string Complex_Or_Real(string str)&amp;#123;
    for(int i = 0; i &amp;lt; str.length(); i++)&amp;#123;
        if(str[i] == &amp;#39;i&amp;#39;) return InitComplex(str);
    &amp;#125;
    return InitNum(str);
&amp;#125;

int main() &amp;#123;
    string str, a;
    cin &amp;gt;&amp;gt; str;
    a = Complex_Or_Real(str);
    cout &amp;lt;&amp;lt; a;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-11-11T06:04:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/</id>
        <title>Map 单词分析</title>
        <link rel="alternate" href="http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/"/>
        <content type="html">&lt;p&gt;&lt;strong&gt;蓝桥杯无法使用&lt;code&gt;for(x : y)&amp;#123;&amp;#125;&lt;/code&gt; 、 &lt;code&gt;auto&lt;/code&gt;等的C11语法和关键字&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

map&amp;lt;char, int&amp;gt; m;

int main(void)&amp;#123;
    string str;
    char mc;
    int s = 0;
    for(int i = 97; i &amp;lt;= 122; i++)&amp;#123;
        m.insert(make_pair((char)i, 0));
    &amp;#125;
    cin &amp;gt;&amp;gt; str;
    for(int i = 0; i &amp;lt; str.size(); i++)&amp;#123;
        m[str[i]]++;
    &amp;#125;
    for(map&amp;lt;char, int&amp;gt;::iterator i = m.begin(); i != m.end(); i++)&amp;#123;
        if(s &amp;lt; i-&amp;gt;second) mc = i-&amp;gt;first, s = i-&amp;gt;second;		// 记录次数
    &amp;#125;
    cout &amp;lt;&amp;lt; mc &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; m[mc];

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法" />
        <updated>2021-11-08T07:30:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</id>
        <title>DFS迷宫问题</title>
        <link rel="alternate" href="http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#pragma GCC optimize(2)
using namespace std;

int m[101][101];
int xS, yS, xE, yE;
int s;

void dfs(int x, int y)&amp;#123;
    if(x == xE &amp;amp;&amp;amp; y == yE)&amp;#123;
        s++;
        return;
    &amp;#125;else&amp;#123;		// 遍历四个方向 
        m[x][y] = 0;
        if(m[x + 1][y])&amp;#123;
            m[x + 1][y] = 0;		// 占位，防止死循环 
            dfs(x + 1, y);
            m[x + 1][y] = 1;
        &amp;#125;
        if(m[x - 1][y])&amp;#123;
            m[x - 1][y] = 0;
            dfs(x - 1, y);
            m[x - 1][y] = 1;
        &amp;#125;
        if(m[x][y + 1])&amp;#123;
            m[x][y + 1] = 0;
            dfs(x, y + 1);
            m[x][y + 1] = 1;
        &amp;#125;
        if(m[x][y - 1])&amp;#123;
            m[x][y - 1] = 0;
            dfs(x, y - 1);
            m[x][y - 1] = 1;
        &amp;#125;
    &amp;#125;
&amp;#125;

int main(void)&amp;#123;
    ios::sync_with_stdio(false);
    int x, y, k, Ox, Oy;
    cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; k;
    for(int i = 1; i &amp;lt;= x; i++)	// 棋盘预定义
        for(int j = 1; j &amp;lt;= y; j++)
            m[i][j] = 1;
    cin &amp;gt;&amp;gt; xS &amp;gt;&amp;gt; yS &amp;gt;&amp;gt; xE &amp;gt;&amp;gt; yE;
    for(int i = 0; i &amp;lt; k; i++)&amp;#123;	// 预先写入障碍
        cin &amp;gt;&amp;gt; Ox &amp;gt;&amp;gt; Oy;
        m[Ox][Oy] = 0;
    &amp;#125;
    dfs(xS, yS);
    cout &amp;lt;&amp;lt; s;

    return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法" />
        <updated>2021-11-08T06:36:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/11/05/C++_STL%E4%B8%AD%E7%9A%84next_permutation/</id>
        <title>C++ STL中的next_permutation</title>
        <link rel="alternate" href="http://example.com/2021/11/05/C++_STL%E4%B8%AD%E7%9A%84next_permutation/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;Rearranges the elements in the range &lt;code&gt;[first,last)&lt;/code&gt; into the next &lt;em&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jcGx1c3BsdXMuY29tL2xleGljb2dyYXBoaWNhbF9jb21wYXJl&#34;&gt;lexicographically&lt;/span&gt; greater&lt;/em&gt; permutation.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;将范围内的元素重新排列&lt;code&gt;[first,last)&lt;/code&gt;为下一个&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jcGx1c3BsdXMuY29tL2xleGljb2dyYXBoaWNhbF9jb21wYXJl&#34;&gt;字典序&lt;/span&gt;更大的排列。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jcGx1c3BsdXMuY29tLw==&#34;&gt;–cplusplus.com&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于next_permutation函数，其函数原型为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; #include &amp;lt;algorithm&amp;gt;
 bool next_permutation(iterator start,iterator end)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
int main()&amp;#123;
    int num[3]=&amp;#123;1, 2, 3&amp;#125;;
    do&amp;#123;
        cout &amp;lt;&amp;lt; num[0] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[1] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[2] &amp;lt;&amp;lt; endl;
    &amp;#125;while(next_permutation(num, num + 3));
    return 0;
&amp;#125;

输出结果：
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们把&lt;code&gt;while(next_permutation(num, num + 3))&lt;/code&gt;中的&lt;code&gt;3&lt;/code&gt;改为&lt;code&gt;2&lt;/code&gt;时，输出就变为了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3
2 1 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此可见，next_permutation是对数组前n项进行全排列&lt;/p&gt;
&lt;p&gt;同理，既然有下一个全排列函数，那肯定是有上一个全排列函数：&lt;code&gt;prev_permutation&lt;/code&gt;使用方法与&lt;code&gt;next_permutation&lt;/code&gt;一致。&lt;/p&gt;
</content>
        <category term="算法" />
        <updated>2021-11-05T06:45:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
        <title>Vector 二分查找</title>
        <link rel="alternate" href="http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
        <content type="html">&lt;p&gt;二分查找：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lower_bound：查找第一个大于或等于某个元素的位置。&lt;/li&gt;
&lt;li&gt;upper_bound：查找第一个大于某个元素的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vector 插入元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iterator insert(iterator it, const T&amp;amp; x)：iterator向量中迭代器指向元素前增加一个元素x&lt;/li&gt;
&lt;li&gt;iterator insert(iterator it, int n,const T&amp;amp; x)：向量中迭代器指向元素前增加n个相同的元素x&lt;/li&gt;
&lt;li&gt;iterator insert(iterator it, const_iterator first, const_iterator last)：向量中迭代器指向元素前插入另一个相同类型向量的[first, last)间的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main(void)&amp;#123;
    vector&amp;lt;int&amp;gt; arr;
    int t, k, a;
    for(int i = 0; i &amp;lt; 9; i++)&amp;#123;
        cin &amp;gt;&amp;gt; t;
        arr.push_back(t);
    &amp;#125;
    cin &amp;gt;&amp;gt; k;
    auto pos = upper_bound(arr.begin(), arr.end(), k); 	// vector&amp;lt;int&amp;gt;::iterator
    arr.insert(pos, k);
    for(int i = 0; i &amp;lt; 10; i++)
        cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法" />
        <updated>2021-11-04T07:39:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF/</id>
        <title>二叉树模板</title>
        <link rel="alternate" href="http://example.com/2021/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#pragma GCC optimize(2)
using namespace std;

struct tree&amp;#123;
    int left;
    int right;
&amp;#125;;

tree t[1000];

int dfs(int n)&amp;#123;		// 深度 
    if(!n) return 0;
    return max(dfs(t[n].left), dfs(t[n].right)) + 1;
&amp;#125;

void f(int n)&amp;#123;		// 先序 
    cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    if(t[n].left) f(t[n].left);
    if(t[n].right) f(t[n].right);
&amp;#125;

void s(int n)&amp;#123;		// 中序 
    if(t[n].left) s(t[n].left);
    cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    if(t[n].right) s(t[n].right);
&amp;#125;

void e(int n)&amp;#123;		// 后序 
    if(t[n].left) e(t[n].left);
    if(t[n].right) e(t[n].right);
    cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
&amp;#125;

int main(void)&amp;#123;
    int n;
    cin &amp;gt;&amp;gt; n;
    for(int i = 1; i &amp;lt;= n; i++)
        cin &amp;gt;&amp;gt; t[i].left &amp;gt;&amp;gt; t[i].right;
    
    return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-28T09:03:28.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/28/%E5%8D%A1%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%82%86%E6%97%A0%E5%BF%8C%E6%83%AESTL/</id>
        <title>卡常小技巧，肆无忌惮STL</title>
        <link rel="alternate" href="http://example.com/2021/10/28/%E5%8D%A1%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%82%86%E6%97%A0%E5%BF%8C%E6%83%AESTL/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#pragma GCC optimize(2)
ios::sync_with_stdio(false);
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-28T08:25:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/28/%E6%95%B0%E7%BB%84%E7%B2%98%E8%B4%B4%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96C++/</id>
        <title>数组粘贴，初始化C++</title>
        <link rel="alternate" href="http://example.com/2021/10/28/%E6%95%B0%E7%BB%84%E7%B2%98%E8%B4%B4%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96C++/"/>
        <content type="html">&lt;p&gt;粘贴：memcpy()&lt;/p&gt;
&lt;p&gt;初始化（可初始化结构体内的数组元素）：memset()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[5];
int b[5] = &amp;#123;1, 2, 3, 4, 5&amp;#125;
memset(a, 0, sizeof(int));	// 把a中所有数组元素初始化为1
memcpy(a, b, 5 * sizeof(int));	// 把b数组覆盖到a数组
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-28T03:51:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/27/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%98%B6%E4%B9%98%E6%A8%A1%E6%9D%BF(C++)/</id>
        <title>高精度阶乘模板(C++)</title>
        <link rel="alternate" href="http://example.com/2021/10/27/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%98%B6%E4%B9%98%E6%A8%A1%E6%9D%BF(C++)/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int MAX = 10000;
struct N&amp;#123;
    int len;
    int a[MAX];
    N(int x = 0)&amp;#123;		// 初始化
        memset(a, 0, sizeof(a));
        for(len = 1; x; len++)&amp;#123;
            a[len] = x % 10;
            x /= 10;
        &amp;#125;
    &amp;#125;
    void f(int _l)&amp;#123;		// 进位
        len = _l;
        for(int i = 1; i &amp;lt;= len; i++)&amp;#123;
            a[i + 1] += a[i] / 10;
            a[i] %= 10;
        &amp;#125;
        for(;!a[len];) len--;		// 去除无效前置0
    &amp;#125;
    void print()&amp;#123;
        for(int i = max(len, 1); i &amp;gt;= 1; i--)
            printf(&amp;quot;%d&amp;quot;, a[i]);
    &amp;#125;
    int &amp;amp;operator[](int i)&amp;#123;		// 重载[]，方便直接使用Node[num]访问Node数组
        return a[i];
    &amp;#125;
    N operator*(int t)&amp;#123;		// 重载*
        N c;
        for(int i = 1; i &amp;lt;= len; i++)
            c[i] = a[i] * t;
        c.f(len + 11);
        return c;
    &amp;#125;
&amp;#125;;

int main(void)&amp;#123;
    N fac(1);
    int n;
    cin &amp;gt;&amp;gt; n;
    for(int i = 1; i &amp;lt;= n; i++)
        fac = fac * i; 
    fac.print();

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-27T04:13:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/26/c_str()%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
        <title>c_str()使用方法</title>
        <link rel="alternate" href="http://example.com/2021/10/26/c_str()%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;//标准库的string类提供了三个成员函数来从一个string得到c类型的字符数组
//c_str()：生成一个const char*指针，指向以空字符终止的数组。
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
 
int main()
&amp;#123;
    //string--&amp;gt;char*
    //c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同
    //这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用后，其中的数据就会失效。
    //因此要么现用先转换，要么把它的数据复制到用户自己可以管理的内存中
    const char *c;
    string s = &amp;quot;1234&amp;quot;;
    c = s.c_str();
    cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl;
    s = &amp;quot;abcde&amp;quot;;
    cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1234
abcde
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-26T13:52:15.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/23/C++_STL%E5%AE%B9%E5%99%A8%EF%BC%8811%E4%B8%AA%EF%BC%89/</id>
        <title>C++ STL容器（11个）</title>
        <link rel="alternate" href="http://example.com/2021/10/23/C++_STL%E5%AE%B9%E5%99%A8%EF%BC%8811%E4%B8%AA%EF%BC%89/"/>
        <content type="html">&lt;h1 id=&#34;deque&#34;&gt;&lt;a href=&#34;#deque&#34; class=&#34;headerlink&#34; title=&#34;deque :&#34;&gt;&lt;/a&gt;&lt;code&gt;deque&lt;/code&gt; :&lt;/h1&gt;&lt;h1 id=&#34;list&#34;&gt;&lt;a href=&#34;#list&#34; class=&#34;headerlink&#34; title=&#34;list :&#34;&gt;&lt;/a&gt;&lt;code&gt;list&lt;/code&gt; :&lt;/h1&gt;&lt;h1 id=&#34;queue&#34;&gt;&lt;a href=&#34;#queue&#34; class=&#34;headerlink&#34; title=&#34;queue :&#34;&gt;&lt;/a&gt;&lt;code&gt;queue&lt;/code&gt; :&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&#34;https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2022/11/3285107056.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;priority-queue&#34;&gt;&lt;a href=&#34;#priority-queue&#34; class=&#34;headerlink&#34; title=&#34;priority_queue :&#34;&gt;&lt;/a&gt;&lt;code&gt;priority_queue&lt;/code&gt; :&lt;/h1&gt;&lt;h4 id=&#34;默认大顶堆（后两参数可缺省）&#34;&gt;&lt;a href=&#34;#默认大顶堆（后两参数可缺省）&#34; class=&#34;headerlink&#34; title=&#34;#### 默认大顶堆（后两参数可缺省）&#34;&gt;&lt;/a&gt;#### 默认大顶堆（后两参数可缺省）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;priority_queue&amp;lt;int&amp;gt; big_heap;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;大顶堆&#34;&gt;&lt;a href=&#34;#大顶堆&#34; class=&#34;headerlink&#34; title=&#34;大顶堆&#34;&gt;&lt;/a&gt;大顶堆&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,less&amp;lt;int&amp;gt;&amp;gt; big_heap2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;小顶堆&#34;&gt;&lt;a href=&#34;#小顶堆&#34; class=&#34;headerlink&#34; title=&#34;小顶堆&#34;&gt;&lt;/a&gt;小顶堆&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,greater&amp;lt;int&amp;gt;&amp;gt; small_heap;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;函数&#34;&gt;&lt;a href=&#34;#函数&#34; class=&#34;headerlink&#34; title=&#34;函数&#34;&gt;&lt;/a&gt;函数&lt;/h4&gt;&lt;p&gt;&lt;code&gt;bool empty() const&lt;/code&gt;：返回值为true，说明队列为空&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int size() const&lt;/code&gt;：返回优先队列中元素的数量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void pop()&lt;/code&gt;：删除队列顶部的元素，也即根节点&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int top()&lt;/code&gt;：返回队列中的顶部元素，但不删除该元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void push(int arg)&lt;/code&gt;：将元素arg插入到队列之中；&lt;/p&gt;
&lt;h1 id=&#34;stack&#34;&gt;&lt;a href=&#34;#stack&#34; class=&#34;headerlink&#34; title=&#34;stack :&#34;&gt;&lt;/a&gt;&lt;code&gt;stack&lt;/code&gt; :&lt;/h1&gt;&lt;h1 id=&#34;vector&#34;&gt;&lt;a href=&#34;#vector&#34; class=&#34;headerlink&#34; title=&#34;vector :&#34;&gt;&lt;/a&gt;&lt;code&gt;vector&lt;/code&gt; :&lt;/h1&gt;&lt;h1 id=&#34;map&#34;&gt;&lt;a href=&#34;#map&#34; class=&#34;headerlink&#34; title=&#34;map :&#34;&gt;&lt;/a&gt;&lt;code&gt;map&lt;/code&gt; :&lt;/h1&gt;&lt;h1 id=&#34;multimap&#34;&gt;&lt;a href=&#34;#multimap&#34; class=&#34;headerlink&#34; title=&#34;multimap :&#34;&gt;&lt;/a&gt;&lt;code&gt;multimap&lt;/code&gt; :&lt;/h1&gt;&lt;h1 id=&#34;set&#34;&gt;&lt;a href=&#34;#set&#34; class=&#34;headerlink&#34; title=&#34;set :&#34;&gt;&lt;/a&gt;&lt;code&gt;set&lt;/code&gt; :&lt;/h1&gt;&lt;h1 id=&#34;multiset&#34;&gt;&lt;a href=&#34;#multiset&#34; class=&#34;headerlink&#34; title=&#34;multiset :&#34;&gt;&lt;/a&gt;&lt;code&gt;multiset&lt;/code&gt; :&lt;/h1&gt;&lt;h1 id=&#34;bitset&#34;&gt;&lt;a href=&#34;#bitset&#34; class=&#34;headerlink&#34; title=&#34;bitset :&#34;&gt;&lt;/a&gt;&lt;code&gt;bitset&lt;/code&gt; :&lt;/h1&gt;</content>
        <updated>2021-10-23T08:33:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84sort%E6%8E%92%E5%BA%8F/</id>
        <title>二维数组sort排序</title>
        <link rel="alternate" href="http://example.com/2021/10/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84sort%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;for(int i = 0; i &amp;lt; n; i++)
    sort(s[i], s[i] + len);
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-19T07:25:51.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/16/%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98_%E5%88%86%E7%B3%96%E6%9E%9C%E3%80%90%E7%AC%AC%E4%BA%94%E5%B1%8A%E3%80%91%E3%80%90%E7%9C%81%E8%B5%9B%E3%80%91%E3%80%90C%E7%BB%84%E3%80%91/</id>
        <title>历届真题 分糖果【第五届】【省赛】【C组】</title>
        <link rel="alternate" href="http://example.com/2021/10/16/%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98_%E5%88%86%E7%B3%96%E6%9E%9C%E3%80%90%E7%AC%AC%E4%BA%94%E5%B1%8A%E3%80%91%E3%80%90%E7%9C%81%E8%B5%9B%E3%80%91%E3%80%90C%E7%BB%84%E3%80%91/"/>
        <content type="html">&lt;p&gt;&lt;img data-src=&#34;http://mioe.xyz/usr/uploads/2021/10/3684429808.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int eq(int *t, int l)&amp;#123;
    for(int i = 1; i &amp;lt; l; i++)
        if(t[0] != t[i]) return 0;
    return 1;
&amp;#125;

int main(void)&amp;#123;
    int n, m;
    cin &amp;gt;&amp;gt; n;
    int c[n], i, s = 0, bf[n];		// bf[n] 缓存区 
    for(i = 0; i &amp;lt; n; i++)
        cin &amp;gt;&amp;gt; c[i];
    while(1)&amp;#123;						// 思路：每次分糖果，把第i个 分出 的糖果记录到 对应的 缓存区， 
        for(i = 0; i &amp;lt; n; i++)&amp;#123;		// 		 第i个小朋友的苹果等于 自身糖果的一半 加  i - 1 缓冲区的糖果 
            c[i] /= 2;				//	例如： 有三个小朋友
            bf[i] = c[i];			//         2 2 4 
        &amp;#125;							// 对半分：1 1 2(1)
        c[0] += bf[n - 1];			//          / / / 
        for(i = 1; i &amp;lt; n; i++)	 	// 缓冲区：1 1 2 
            c[i] += bf[i - 1];		//         | | | 
        for(i = 0; i &amp;lt; n; i++)		// 完成：3 2 3(3) 
            if(c[i] % 2 != 0)&amp;#123;
                c[i]++;
                s++;
            &amp;#125;
        if(eq(c, n) == 1) break;
    &amp;#125;

    cout &amp;lt;&amp;lt; s;
    return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-16T08:35:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/15/XX_XX_XX%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%90%E5%8F%96%E6%95%B0%E5%AD%97/</id>
        <title>XX:XX:XX类型字符串提取数字</title>
        <link rel="alternate" href="http://example.com/2021/10/15/XX_XX_XX%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%90%E5%8F%96%E6%95%B0%E5%AD%97/"/>
        <content type="html">&lt;p&gt;洛谷P1615&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cin &amp;gt;&amp;gt; time1
sscanf(time1.c_str(), &amp;quot;%d:%d:%d&amp;quot;, &amp;amp;h1, &amp;amp;m1, &amp;amp;s1); // c_str()获取字符串地址
// 或者直接这样写 scanf(&amp;quot;%d:%d:%d&amp;quot;, &amp;amp;h1, &amp;amp;m1, &amp;amp;s1);
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-15T09:26:16.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/01/P2911_[USACO08OCT]Bovine_Bones_G_(C)/</id>
        <title>P2911 [USACO08OCT]Bovine Bones G (C)</title>
        <link rel="alternate" href="http://example.com/2021/10/01/P2911_[USACO08OCT]Bovine_Bones_G_(C)/"/>
        <content type="html">&lt;p&gt;&lt;img data-src=&#34;https://i.loli.net/2021/10/01/dcA2xWtmfYQRaqD.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
    根据题意，总共3个骰子，每个骰子有 S个面，因为数据范围较小，可以直接选择暴力
    每次总和记录到相应的结构体(Sum = 10 -&amp;gt; struct[10])，结构体中保存两个数据：总和(num)、次数(times) 
    最后使用快排(qsort)筛出次数(times)最小的目标 
*/ 

#include&amp;lt;stdio.h&amp;gt;

struct A&amp;#123;		// 声明结构体，存放点数总和与次数 
    int num;
    int times;
&amp;#125;;

int compare(const void *a, const void *b)&amp;#123;
    struct A *p1 = (struct A *)a;
    struct A *p2 = (struct A *)b;
    if(p1-&amp;gt;times == p2-&amp;gt;times) return p1-&amp;gt;num - p2-&amp;gt;num;		// 题意：如果出现概率一样时输出最小总和 
    return p2-&amp;gt;times - p1-&amp;gt;times;
&amp;#125;

int main(void)&amp;#123;
    int s1, s2, s3, s, i, j, k;
    struct A a[80];
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;s1, &amp;amp;s2, &amp;amp;s3);
    for(i = 0; i &amp;lt; 81; i++)&amp;#123;
         a[i].times = 0;
         a[i].num = 0;
    &amp;#125;
    for(i = 1; i &amp;lt;= s1; i++)
        for(j = 1; j &amp;lt;= s2; j++)
            for(k = 1; k &amp;lt;= s3; k++)&amp;#123;
                a[i + j + k].num = i + j + k;
                a[i + j + k].times++;
            &amp;#125;

    qsort(a, 80, sizeof(struct A), compare);
    printf(&amp;quot;%d&amp;quot;, a[0].num);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-01T12:40:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/09/11/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F_C%E8%AF%AD%E8%A8%80/</id>
        <title>冒泡排序 C语言</title>
        <link rel="alternate" href="http://example.com/2021/09/11/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F_C%E8%AF%AD%E8%A8%80/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;

/* 交换函数
void swap(int *pa, int *pb)&amp;#123;
    int temp;
    if(*pa &amp;gt; *pb)&amp;#123;
        temp = *pb;
        *pb = *pa;
        *pa = temp; 
    &amp;#125;
&amp;#125;
*/

int main(void)&amp;#123;
    int a[] = &amp;#123;1, 3, 5, 2, 14, 8, 4 ,9&amp;#125;;
    int i, j;
    int temp;
    int num = (sizeof(a) / sizeof(a[0]));
    printf(&amp;quot;排序前：&amp;quot;);
    for(i = 0; i &amp;lt; num; i++)&amp;#123;
        printf(&amp;quot;%d &amp;quot;, a[i]);
    &amp;#125;
    printf(&amp;quot;\n&amp;quot;);

    // 冒泡 
    for(i = 0; i &amp;lt; num; i++)&amp;#123;		// 游标 
        for(j = i; j &amp;lt; num - 1; j++)&amp;#123;		// 两两比较 
            if(a[j] &amp;gt; a[j + 1])&amp;#123;
                temp = a[j + 1];
                a[j + 1] = a[j];
                a[j] = temp;
            &amp;#125;
            // swap((a + j), (a + j + 1));
        &amp;#125;
    &amp;#125;

    printf(&amp;quot;排序后：&amp;quot;);
    for(i = 0; i &amp;lt; num; i++)&amp;#123;
        printf(&amp;quot;%d &amp;quot;, a[i]);
    &amp;#125;
    return 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-09-11T09:10:00.000Z</updated>
    </entry>
</feed>
