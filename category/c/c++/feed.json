{
    "version": "https://jsonfeed.org/version/1",
    "title": "mioe • All posts by \"c/c++\" category",
    "description": "花店不开了，花继续开",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/02/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/",
            "url": "http://example.com/2023/02/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/",
            "title": "最小生成树",
            "date_published": "2023-02-07T11:45:54.000Z",
            "content_html": "<h1 id=\"最短生成树\"><a href=\"#最短生成树\" class=\"headerlink\" title=\"最短生成树\"></a>最短生成树</h1><h2 id=\"Prim\"><a href=\"#Prim\" class=\"headerlink\" title=\"Prim\"></a>Prim</h2><pre><code class=\"cpp\">#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N = 505, INF = 0x3f3f3f3f;\n\nint n, m;\nint g[N][N];\nint dist[N];\nbool st[N];\n\nintprim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;   // 第一个点一定在最小生成树中\n\n    int res = 0;  // 用来存放权值之和\n    for(int i = 0; i &lt; n; i ++)\n    &#123;\n        int t = -1;\n        for(int j = 1; j &lt;= n; j ++)\n            if(!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))\n                t = j;\n\n        if(dist[t] == INF) return INF;   // 尽早跳出循环防止TLE，如果不加则需要在输出的地方更改\n        res += dist[t];\n        st[t] = true;\n\n        for(int j = 1; j &lt;= n; j ++)\n            dist[j] = min(dist[j], g[t][j]); // 注意和dijkstra的区别\n                                             // prim的dist是到已经生成的树的最短距离\n    &#125;\n    return res;\n&#125;\n\n\nintmain()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(g, 0x3f, sizeof g);\n\n    while(m --)\n    &#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        g[a][b] = g[b][a] = min(g[a][b], c);\n    &#125;\n\n    int t = prim();\n\n    if(t == INF) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;  // 如果上面不及时跳出循环则在这里改为(t &gt;= INF / 2)\n    else cout &lt;&lt; t &lt;&lt; endl;\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"kruskal\"><a href=\"#kruskal\" class=\"headerlink\" title=\"kruskal\"></a>kruskal</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100;\n\nstructNode&#123;\n    int a, b, w;\n  \n    bool operator&lt; (const Node &amp;N) const &#123;\n        return w &lt; N.w;\n    &#125;\n&#125;edges[N];\n\nint n, m, res, cnt;\nint g[N];\n\nintfind(int a)&#123;\n    if (a != g[a]) g[a] = find(g[a]);\n    return g[a];\n&#125;\n\nintkruskal()&#123;\n    for (int i = 0; i &lt; m; i++) &#123;\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n  \n        a = find(a), b = find(b);  \n        if (a != b) &#123;\n            g[a] = b;\n            res += w;\n            cnt++;\n        &#125;\n    &#125;\n  \n    if (cnt &lt; n - 1) return -1;\n    else return res;\n&#125;\n\nintmain()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n  \n    for (int i = 0; i &lt; m; i++) &#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        edges[i] = &#123;a, b, c&#125;;\n    &#125;\n    for (int i = 1; i &lt;= n; i++) g[i] = i;\n    sort(edges, edges + m);\n  \n    int t = kruskal();\n    cout &lt;&lt; t;\n  \n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        },
        {
            "id": "http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/",
            "url": "http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/",
            "title": "字符串哈希",
            "date_published": "2023-02-02T08:36:57.000Z",
            "content_html": "<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1010, P = 131;\n\nunsigned long long h[N], p[N];\nint n, m;\nchar str[N];\n\nunsigned long long gethash(int l, int r)&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d %d %s&quot;, &amp;n, &amp;m, str + 1);\n\n    p[0] = 1;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        p[i] = p[i - 1] * P;\n        h[i] = h[i - 1] * P + str[i];\n    &#125;\n\n    int l1, r1, l2, r2;\n    while(m--)&#123;\n        scanf(&quot;%d %d %d %d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);\n        if(gethash(l1, r1) == gethash(l2, r2)) printf(&quot;Yes\\n&quot;);\n        else printf(&quot;No\\n&quot;);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        },
        {
            "id": "http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/",
            "url": "http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/",
            "title": "小根堆",
            "date_published": "2023-02-01T10:38:45.000Z",
            "content_html": "<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e6+10;\n\nint hp[N], idx;\nint n;\n\nvoid down(int k)&#123;\n    int t = k;\n    if(hp[k &lt;&lt; 1] &lt; hp[t] &amp;&amp; (k &lt;&lt; 1) &lt;= idx) t = k &lt;&lt; 1;\n    if(hp[k &lt;&lt; 1 | 1] &lt; hp[t] &amp;&amp; (k &lt;&lt; 1 | 1) &lt;= idx) t = k &lt;&lt; 1 | 1;\n    if(t != k)&#123;\n        swap(hp[k], hp[t]);\n        down(t);\n    &#125;\n&#125;\n\nvoid up(int k)&#123;\n    while(k &gt;&gt; 1 &amp;&amp; hp[k &gt;&gt; 1] &gt; hp[k])&#123;\n        swap(hp[k &gt;&gt; 1], hp[k]);\n        k &gt;&gt;= 1;\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;n);\n\n    int x, y;\n    while(n--)&#123;\n        scanf(&quot;%d&quot;, &amp;x);\n        if(x == 1)&#123;\n            scanf(&quot;%d&quot;, &amp;y);\n            hp[++idx] = y;\n            up(idx);\n        &#125;else if(x == 2) printf(&quot;%d\\n&quot;, hp[1]);\n        else hp[1] = hp[idx], idx--, down(1);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        },
        {
            "id": "http://example.com/2023/01/30/KMP/",
            "url": "http://example.com/2023/01/30/KMP/",
            "title": "KMP",
            "date_published": "2023-01-30T10:25:00.000Z",
            "content_html": "<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100, M = 1000;\n\nint n, m;\nchar p[N], s[M];\nint ne[N];\n\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\n\n    for(int i = 2, j = 0; i &lt;= n; i++)&#123;\n        while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n        if(p[i] == p[j + 1]) j++;\n        ne[i] = j;\n    &#125;\n\n    for(int i = 1, j = 0; i &lt;= m; i++)&#123;\n        while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];\n        if(s[i] == p[j + 1]) j++;\n        if(j == n)&#123;\n            printf(&quot;%d&quot;, i - n);\n            break;\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/30/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89/",
            "url": "http://example.com/2023/01/30/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89/",
            "title": "单调栈、滑动窗口（单调队列）",
            "date_published": "2023-01-30T09:07:00.000Z",
            "content_html": "<h4 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h4><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100;\n\nint stk[N], arr[N];\nint n, t;\n\nint main()&#123;\n    cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++)&#123;\n        cin &gt;&gt; arr[i];\n        while(t &amp;&amp; arr[i] &lt;= stk[t]) t--;\n    \n        if(t) cout &lt;&lt; stk[t] &lt;&lt; &quot; &quot;;\n        else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;\n    \n        stk[++t] = arr[i];\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h4><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100;\n\nint arr[N], q[N];\nint n, k;\n\nint main()&#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;k);\n\n    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;arr[i]);\n\n    int h = 0, r = -1;\n    for(int i = 0; i &lt; n; i++)&#123;\n        if(h &lt;= r &amp;&amp; i - k + 1 &gt; q[h]) h++;\n\n        while(h &lt;= r &amp;&amp; arr[q[r]] &gt;= arr[i]) r--;\n\n        q[++r] = i;\n\n        if(i &gt;= k - 1) printf(&quot;%d &quot;, arr[q[h]]);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/20/%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/",
            "url": "http://example.com/2023/01/20/%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/",
            "title": "双指针数组去重",
            "date_published": "2023-01-20T12:23:01.000Z",
            "content_html": "<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100;\n\nint n; \nint arr[N];\n\nint main()&#123;\n    cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i];\n\n    int j = 0;\t// 非重复个数\n    for(int i = 0; i &lt; n; i++)\n        if(!i || arr[i] != arr[i - 1])\n            arr[j++] = arr[i];\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/08/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/",
            "url": "http://example.com/2023/01/08/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/",
            "title": "树的直径",
            "date_published": "2023-01-08T08:58:43.000Z",
            "content_html": "<pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010;\n\nstruct Node&#123;\n    int id, w;\n&#125;;\n\nvector&lt;Node&gt; m[N];\nint dist[N];\nint n;\n\nvoid dfs(int idx, int root, int dst)&#123;\n    dist[idx] = dst;\n    for(auto node : m[idx])\n        if(node.id != root)\tdfs(node.id, idx, dst + node.w);\n&#125;\n\nint main()&#123;\n    int p, q, d, t;\n    cin &gt;&gt; n;\n    t = n - 1;\n    while(t--)&#123;\n        scanf(&quot;%d%d%d&quot;, &amp;p, &amp;q, &amp;d);\n        m[p].push_back(&#123;q, d&#125;);\n        m[q].push_back(&#123;p, d&#125;);\n    &#125;\n    dfs(1, -1, 0);\n    int idx = 1;\n    for(int i = 1; i &lt;= n; i++)\n        if(dist[i] &gt; dist[idx]) idx = i;\n    dfs(idx, -1, 0);\n    for(int i = 1; i &lt;= n; i++)\n        if(dist[i] &gt; dist[idx]) idx = i;\n    idx = dist[idx];\n    printf(&quot;%lld&quot;, 10 * idx + (1ll + idx) * idx / 2);\t\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/05/BFS%E6%A8%A1%E6%9D%BF/",
            "url": "http://example.com/2023/01/05/BFS%E6%A8%A1%E6%9D%BF/",
            "title": "BFS模板",
            "date_published": "2023-01-05T09:40:00.000Z",
            "content_html": "<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行，</p>\n<p>对于每一组数据，输出吃到奶酪的最少单位时间。</p>\n<p>若无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。</p>\n<p>在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。</p>\n<h4 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h4><h6 id=\"二维\"><a href=\"#二维\" class=\"headerlink\" title=\"二维\"></a>二维</h6><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 210;\n\n// 方向偏移量\nint dx[4] = &#123;-1, 0, 1, 0&#125;;\nint dy[4] = &#123;0, 1, 0, -1&#125;;\n// 距离\nint dist[N][N];\nint n, m;\npair&lt;int, int&gt; start;\npair&lt;int, int&gt; ed;\n// 迷宫\nchar g[N][N];\n\nint bfs(pair&lt;int, int&gt; s, pair&lt;int, int&gt; e)&#123;\n    queue&lt;pair&lt;int, int&gt;&gt; q;\n    memset(dist, -1, sizeof dist);\n\n    dist[s.first][s.second] = 0;\t\t\t\t\t\t// 起点\n    q.push(s);\n\n    while(!q.empty())&#123;\n        pair&lt;int, int&gt; t = q.front();\n        q.pop();\n\n        if(t == e) return dist[t.first][t.second];\t\t\t// 判断是否终点\n\n        for(int i = 0; i &lt; 4; i++)&#123;\n            int x = t.first + dx[i];\n            int y = t.second + dy[i];\n            if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m) continue;\t// 越界\n            if(g[x][y] == &#39;#&#39;) continue;\t\t\t\t// 碰墙\n            if(dist[x][y] != -1) continue;\t\t\t\t// 已遍历\n\n            dist[x][y] = dist[t.first][t.second] + 1;\t\t// 距离加一\n            q.push(&#123;x, y&#125;);\n        &#125;\n    &#125;\n\n    return -1;\n&#125;\n\nint main()&#123;\n    int t;\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n        for(int i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]);\n        for(int i = 0; i &lt; n; i++)&#123;\n            for(int j = 0; j &lt; m; j++)&#123;\n                if(g[i][j] == &#39;S&#39;) start = &#123;i, j&#125;;\n                if(g[i][j] == &#39;E&#39;) ed = &#123;i, j&#125;;\n            &#125;\n        &#125;\n\n        int d = bfs(start, ed);\n        if(d == -1) printf(&quot;oop!\\n&quot;);\n        else printf(&quot;%d\\n&quot;, d);\n    &#125;\n\n\n    return 0;\n&#125;\n</code></pre>\n<h5 id=\"三维\"><a href=\"#三维\" class=\"headerlink\" title=\"三维\"></a>三维</h5><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 101;\n\npair&lt;int, pair&lt;int, int&gt;&gt; start, ed, tmp;\nchar g[N][N][N];\nint st[N][N][N];\nint dy[4] = &#123;-1, 0, 1, 0&#125;;\nint dz[4] = &#123;0, -1, 0, 1&#125;;\nint l, r, c;\n\nint bfs(pair&lt;int, pair&lt;int, int&gt;&gt; s, pair&lt;int, pair&lt;int, int&gt;&gt; e)&#123;\n    memset(st, -1, sizeof st);\n    queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; q;\n    st[s.first][s.second.first][s.second.second] = 0;\n    q.push(s);\n\n    while(!q.empty())&#123;\n        tmp = q.front();\n        q.pop();\n        if(tmp == e) return st[tmp.first][tmp.second.first][tmp.second.second];\n    \n        int x = tmp.first, y, z;\n    \n        if(x + 1 &lt; l &amp;&amp; st[x + 1][tmp.second.first][tmp.second.second] == -1 &amp;&amp; g[x + 1][tmp.second.first][tmp.second.second] != &#39;#&#39;)&#123;\n            st[x + 1][tmp.second.first][tmp.second.second] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;\n            q.push(&#123;x + 1, &#123;tmp.second.first, tmp.second.second&#125;&#125;);\n        &#125;\n        if(x - 1 &gt;= 0 &amp;&amp; st[x - 1][tmp.second.first][tmp.second.second] == -1 &amp;&amp; g[x - 1][tmp.second.first][tmp.second.second] != &#39;#&#39;)&#123;\n            st[x - 1][tmp.second.first][tmp.second.second] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;\n            q.push(&#123;x - 1, &#123;tmp.second.first, tmp.second.second&#125;&#125;);\n        &#125;\n    \n        for(int i = 0; i &lt; 4; i++)&#123;\n            y = tmp.second.first + dy[i];\n            z = tmp.second.second + dz[i];\n            if(st[x][y][z] != -1) continue;\n            if(y &lt; 0 || z &lt; 0 || y &gt;= r || z &gt;= c) continue;\n            if(g[x][y][z] == &#39;#&#39;) continue;\n        \n            st[x][y][z] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;\n            q.push(&#123;x, &#123;y, z&#125;&#125;);\n        &#125;\n    \n    \n    &#125;\n\n    return -1;\n&#125;\n\nint main()&#123;\n    while(1)&#123;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;\n        if(l == 0) break;\n        for(int i = 0; i &lt; l; i++)\n            for(int j = 0; j &lt; r; j++) \n                scanf(&quot;%s&quot;, g[i][j]);\n    \n        for(int i = 0; i &lt; l; i++)\n            for(int j = 0; j &lt; r; j++)\n                for(int z = 0; z &lt; c; z++)\n                    if(g[i][j][z] == &#39;S&#39;) start = &#123;i, &#123;j, z&#125;&#125;;\n                    else if(g[i][j][z] == &#39;E&#39;) ed = &#123;i, &#123;j, z&#125;&#125;;\n    \n        int step = bfs(start, ed);\n        if(step == -1) printf(&quot;Trapped!\\n&quot;);\n        else printf(&quot;Escaped in %d minute(s).\\n&quot;, step);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "BFS"
            ]
        },
        {
            "id": "http://example.com/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91___%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A8%A1%E6%9D%BF/",
            "url": "http://example.com/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91___%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A8%A1%E6%9D%BF/",
            "title": "线段树 / 树状数组 模板",
            "date_published": "2022-12-30T13:40:00.000Z",
            "content_html": "<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定 <strong>n</strong> 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 <strong>[<strong>a</strong>,<strong>b</strong>]</strong> 的连续和。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行包含两个整数 <strong>n</strong> 和 <strong>m</strong>，分别表示数的个数和操作次数。</p>\n<p>第二行包含 <strong>n</strong> 个整数，表示完整数列。</p>\n<p>接下来 <strong>m</strong> 行，每行包含三个整数 <strong>k</strong>,<strong>a</strong>,<strong>b</strong> （<strong>k&#x3D;0</strong>，表示求子数列 <strong>[a,b]</strong> 的和；<strong>k&#x3D;1</strong>，表示第 <strong>a</strong> 个数加 <strong>b</strong>）。</p>\n<p>数列从 <strong>1</strong> 开始计数。</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>输出若干行数字，表示 <strong>k</strong>&#x3D;<strong>0</strong> 时，对应的子数列 <strong>[<strong>a</strong>,<strong>b</strong>]</strong> 的连续和。</p>\n<h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p><strong>1</strong>≤<strong>n</strong>≤<strong>100000</strong>,<br><strong>1</strong>≤<strong>m</strong>≤<strong>100000，<br>1</strong>≤<strong>a</strong>≤<strong>b</strong>≤<strong>n</strong>,<br>数据保证在任何时候，数列中所有元素之和均在 int 范围内。</p>\n<h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>10 5\n1 2 3 4 5 6 7 8 9 10\n1 1 5\n0 1 3\n0 4 8\n1 7 5\n0 4 8\n</code></pre>\n<h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>11\n30\n35\n</code></pre>\n<h4 id=\"树状数组模板\"><a href=\"#树状数组模板\" class=\"headerlink\" title=\"树状数组模板\"></a>树状数组模板</h4><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010;\n\nint n, m;\nint arr[N], tr[N];\n\nint lowbit(int i)&#123;\n    return i &amp; -i;\n&#125;\n\nvoid add(int index, int x)&#123;\n    for(int i = index; i &lt;= n; i += lowbit(i))\n        tr[i] += x;\n    return;\n&#125;\n\nvoid change(int index, int x)&#123;\n    int c = x - arr[index];\n    for(int i = index; i &lt;= n; i += lowbit(i))\n        tr[i] += c;\n    return;\n&#125;\n\nint query(int index)&#123;\n    int res = 0;\n    for(int i = index; i; i -= lowbit(i))\n        res += tr[i];\n    return res;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;arr[i]);\n    for(int i = 1; i &lt;= n; i++) add(i, arr[i]);\n\n    while(m--)&#123;\n        int tag, l, r;\n        int res;\n        scanf(&quot;%d %d %d&quot;, &amp;tag, &amp;l, &amp;r);\n        if(tag) add(l, r);\n        else printf(&quot;%d\\n&quot;, query(r) - query(l - 1));\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"线段树模板\"><a href=\"#线段树模板\" class=\"headerlink\" title=\"线段树模板\"></a>线段树模板</h4><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010;\n\nint n, m;\nint num[N];\n\nstruct node&#123;\n    int l, r;\n    int sum;\n&#125;sgt[N * 4];\t\t// 需要开N * 4\n\n// 更新当前节点\nvoid pushup(int root)&#123;\n    sgt[root].sum = sgt[root &lt;&lt; 1].sum + sgt[root &lt;&lt; 1 | 1].sum;\n&#125;\n\n// 初始化线段树\nvoid build(int root, int l, int r)&#123;\n    if(l == r) sgt[root].sum = num[l];\n    else&#123;\n        sgt[root] = &#123;l, r&#125;;\n        int mid = l + r &gt;&gt; 1;\n        build(root &lt;&lt; 1, l, mid);\n        build(root &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(root);\n    &#125;\n    return;\n&#125;\n\nint query(int root, int l, int r)&#123;\n    if(sgt[root].l &gt;= l &amp;&amp; sgt[root].r &lt;= r) return sgt[root].sum;\n    int mid = sgt[root].l + sgt[root].r &gt;&gt; 1;\n    int sum = 0;\n    if(l &lt;= mid) sum += query(root &lt;&lt; 1, l, r);\n    if(r &gt; mid) sum += query(root &lt;&lt; 1 | 1, l, r);\n    return sum;\n&#125;\n\nvoid modify(int root, int index, int c)&#123;\n    if(sgt[root].l == sgt[root].r) sgt[root].sum += c;\n    else&#123;\n        int mid = sgt[root].l + sgt[root].r &gt;&gt; 1;\n        if(index &lt;= mid) modify(root &lt;&lt; 1, index, c);\n        else modify(root &lt;&lt; 1 | 1, index, c);\n        pushup(root);\n    &#125;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;num[i]);\n    build(1, 1, n);\n    int k, a, b;\n    while(m--)&#123;\n        scanf(&quot;%d %d %d&quot;, &amp;k, &amp;a, &amp;b);\n        if(k) modify(1, a, b);\n        else printf(&quot;%d\\n&quot;, query(1, a, b));\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "算法模板"
            ]
        },
        {
            "id": "http://example.com/2022/12/27/stringstream_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC_int_double/",
            "url": "http://example.com/2022/12/27/stringstream_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC_int_double/",
            "title": "stringstream 字符串转 int/double",
            "date_published": "2022-12-27T12:29:00.000Z",
            "content_html": "<p>某涉密单位下发了某种票据，并要在年终全部收回。</p>\n<p>每张票据有唯一的ID号。</p>\n<p>全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p>\n<p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p>\n<p>你的任务是通过编程，找出断号的ID和重号的ID。</p>\n<p>假设断号不可能发生在最大和最小号。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行包含整数 <strong>N</strong>，表示后面共有 <strong>N</strong> 行数据。</p>\n<p>接下来 <strong>N</strong> 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>要求程序输出1行，含两个整数 <strong>m</strong>,<strong>n</strong>用空格分隔。</p>\n<p>其中，<strong>m</strong>表示断号ID，<strong>n</strong>表示重号ID。</p>\n<h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p><strong>1</strong>≤<strong>N</strong>≤<strong>100</strong></p>\n<h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>2\n5 6 8 11 9 \n10 12 9\n</code></pre>\n<h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>7 9\n</code></pre>\n<h4 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h4><pre><code class=\"c++\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint a[10001];\nint c, n;\n\nint main()&#123;\n    cin &gt;&gt; n;\n    string line;\n    getline(cin, line);\t\\\\ cin 会读取换行符\n    while(n--)&#123;\n        getline(cin, line);\n        stringstream ssin(line);\n        while(ssin &gt;&gt; a[c])&#123;\n            c++;\n        &#125;\n    &#125;\n    sort(a, a + c);\n    int r1, r2;\n    for(int i = 1; i &lt; c; i++)&#123;\n        if(a[i] == a[i - 1]) r1 = a[i];\n        if(a[i] - 2 == a[i - 1]) r2 = a[i] - 1;\n    &#125;\n    cout &lt;&lt; r2 &lt;&lt; &quot; &quot; &lt;&lt; r1;\n\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"stringstream技巧：\"><a href=\"#stringstream技巧：\" class=\"headerlink\" title=\"stringstream技巧：\"></a>stringstream技巧：</h4><h5 id=\"转int-x2F-double\"><a href=\"#转int-x2F-double\" class=\"headerlink\" title=\"转int&#x2F;double\"></a>转int&#x2F;double</h5><pre><code class=\"c++\">string result = &quot;10000&quot;;\t// double 同理, result = &quot;1.5&quot;;\nstringstream stream(result);\t// 可以是字符串也可以是数字，总之后面直接输入到目标变量里面\nint n = 0;\nstream &gt;&gt; n;\t//n 等于10000\n</code></pre>\n<h5 id=\"转int-x2F-double数组\"><a href=\"#转int-x2F-double数组\" class=\"headerlink\" title=\"转int&#x2F;double数组\"></a>转int&#x2F;double数组</h5><p><code>stringstream</code>以空格作为分隔符</p>\n<pre><code class=\"c++\">string str = &quot;1 2 3 4 5&quot;;\t// double 同理\nstringstream ssin(str);\nint i = 0;\nint a[10] = &#123;0&#125;;\nwhile(ssin &gt;&gt; a[i]) i++;\t// 此时a[0] = 1, a[1] = 2 ...\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/25/%E5%9C%A8%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E9%87%8C%E5%A4%84%E7%90%86%E6%B5%AE%E7%82%B9%E6%95%B0/",
            "url": "http://example.com/2022/12/25/%E5%9C%A8%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E9%87%8C%E5%A4%84%E7%90%86%E6%B5%AE%E7%82%B9%E6%95%B0/",
            "title": "在整数运算里处理浮点数",
            "date_published": "2022-12-25T08:23:44.000Z",
            "content_html": "<p><code>n = m / 2</code> 可以写成 <code>n * 2 = m</code></p>\n<p>同理：</p>\n<p><code>n &lt; m / 2</code> -&gt; <code>n * 2 &lt; m</code></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/21/AcWing_95._%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/",
            "url": "http://example.com/2022/12/21/AcWing_95._%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/",
            "title": "AcWing 95. 费解的开关",
            "date_published": "2022-12-21T11:02:00.000Z",
            "content_html": "<p>你玩过“拉灯”游戏吗？</p>\n<p><strong>25</strong> 盏灯排成一个 <strong>5</strong>×<strong>5</strong> 的方形。</p>\n<p>每一个灯都有一个开关，游戏者可以改变它的状态。</p>\n<p>每一步，游戏者可以改变某一个灯的状态。</p>\n<p>游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p>\n<p>我们用数字 <strong>1</strong> 表示一盏开着的灯，用数字 <strong>0</strong> 表示关着的灯。</p>\n<p>下面这种状态</p>\n<pre><code>10111\n01101\n10111\n10000\n11011\n</code></pre>\n<p>在改变了最左上角的灯的状态后将变成：</p>\n<pre><code>01111\n11101\n10111\n10000\n11011\n</code></pre>\n<p>再改变它正中间的灯后状态将变成：</p>\n<pre><code>01111\n11001\n11001\n10100\n11011\n</code></pre>\n<p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在 <strong>6</strong>6 步以内使所有的灯都变亮。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行输入正整数 <strong>n</strong>，代表数据中共有 <strong>n</strong> 个待解决的游戏初始状态。</p>\n<p>以下若干行数据分为 <strong>n</strong> 组，每组数据有 <strong>5</strong> 行，每行 <strong>5</strong> 个字符。</p>\n<p>每组数据描述了一个游戏的初始状态。</p>\n<p>各组数据间用一个空行分隔。</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>一共输出 <strong>n</strong> 行数据，每行有一个小于等于 <strong>6</strong> 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p>\n<p>对于某一个游戏初始状态，若 <strong>6</strong> 步以内无法使所有灯变亮，则输出 <strong>−1</strong>。</p>\n<h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p><strong>0</strong>&lt;<strong>n</strong>≤<strong>500</strong></p>\n<h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n00111\n01011\n10001\n11010\n11100\n\n11101\n11101\n11110\n11111\n11111\n\n01111\n11111\n11111\n11111\n11111\n</code></pre>\n<p>输出样例：</p>\n<pre><code>3\n2\n-1\n</code></pre>\n<pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint light[7][7], backup[7][7];\n\nvoid turn(int x, int y)&#123;\n    backup[x][y] = !backup[x][y];\n    backup[x - 1][y] = !backup[x - 1][y];\n    backup[x][y - 1] = !backup[x ][y - 1];\n    backup[x + 1][y] = !backup[x + 1][y];\n    backup[x][y + 1] = !backup[x][y + 1];\n&#125;\n\nint main()&#123;\n    int n;\n    string str;\n    str.resize(7);\n    scanf(&quot;%d&quot;, &amp;n);\n    for(int i = 0; i &lt; n; i++)&#123;\n        int res = 10;\n\n        for(int x = 1; x &lt;= 5; x++)&#123;\n            string str;\n            scanf(&quot;%s&quot;, &amp;str[0]);\n            for(int y = 1; y &lt;= 5; y++)\n                light[x][y] = str[y - 1] - &#39;0&#39;;\n        &#125;\n        // 枚举操作而非状态\n        // 01001 表示操作第2和第5盏灯\n        for(int k = 0; k &lt; 32; k++)&#123;\n            memcpy(backup, light, sizeof light);\n            int step = 0;\n            for(int j = 1; j &lt;= 5; j++)&#123;\n                if((k &gt;&gt; (j - 1)) &amp; 1)&#123;\n                    turn(1, j);\n                    step++;\n                &#125;\n            &#125;\n\n            for(int j = 2; j &lt;= 5; j++)&#123;\n                for(int l = 1; l &lt;= 5; l++)&#123;\n                    if(backup[j - 1][l] == 0)&#123;\n                        turn(j, l);\n                        step++;\n                    &#125;\n                &#125;\n            &#125;\n            bool dark = false;\n            for(int j = 1; j &lt;= 5; j++)&#123;\n                if(backup[5][j] != 1)&#123;\n                    dark = true;\n                    break;\n                &#125;\n            &#125;\n            if(!dark)&#123;\n                res = min(res, step);\n            &#125;\n\n        &#125;\n        if(res == 10 || res &gt; 6) res = -1;\n\n        cout &lt;&lt; res;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/19/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2_%EF%BC%88%E5%90%91%E5%B7%A6%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E4%B8%8E%E5%90%91%E5%8F%B3%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E7%9B%B8%E5%B7%AE%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%87_1%EF%BC%89/",
            "url": "http://example.com/2022/12/19/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2_%EF%BC%88%E5%90%91%E5%B7%A6%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E4%B8%8E%E5%90%91%E5%8F%B3%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E7%9B%B8%E5%B7%AE%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%87_1%EF%BC%89/",
            "title": "数字三角形 （向左下走的次数与向右下走的次数相差不能超过 1）",
            "date_published": "2022-12-19T12:01:00.000Z",
            "content_html": "<p><strong>二维数组初始化<code>fill(arr[0], arr[0] + n * n, 0)</code></strong></p>\n<h3 id=\"DFS-超时\"><a href=\"#DFS-超时\" class=\"headerlink\" title=\"DFS 超时\"></a>DFS 超时</h3><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint num[101][101] = &#123;0&#125;;\nint add[101][101] = &#123;0&#125;;\nint n;\nvector&lt;int&gt; ans;\n\nvoid dfs(int l, int r, int x, int y)&#123;\n  if(l &gt; n/2 || r &gt; n/2)&#123;\n    return;\n  &#125;\n    if(x == n - 1)&#123;\n        if(abs(l - r) &gt; 1)&#123;\n            return;\n        &#125;\n        ans.push_back(add[x][y]);\n        return;\n    &#125;\n  \n    l++;\n    add[x + 1][y] = num[x + 1][y] + add[x][y];\n    s(l, r, x + 1, y);\n    add[x + 1][y] = num[x + 1][y];\n    l--;\n\n    r++;\n    add[x + 1][y + 1] = num[x + 1][y + 1] + add[x][y];\n    s(l, r, x + 1, y + 1);\n    add[x + 1][y + 1] = num[x + 1][y + 1];\n    r--;\n&#125;\n\nint main()\n&#123;\n    cin &gt;&gt; n;\n  \n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt;= i; j++)&#123;\n            scanf(&quot;%d&quot;, &amp;num[i][j]);\n        &#125;\n    &#125;\n    add[0][0] = num[0][0];\n    dfs(0, 0, 0, 0);\n    auto max = max_element(ans.begin(), ans.end());\n    cout &lt;&lt; *max;\n  \n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int n;\n    cin &gt;&gt; n;\n    int num[n][n], dp[n][n];\n    fill(num[0], num[0] + n * n, 0);\n    fill(dp[0], dp[0] + n * n, 0);\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt;= i; j++)&#123;\n            scanf(&quot;%d&quot;, &amp;num[i][j]);\n        &#125;\n    &#125;\n    dp[0][0] = num[0][0];\n    for(int i = 0; i &lt; n; i++)&#123;\n        for(int j = 0; j &lt;= i; j++)&#123;\n            if(i - 1 &gt;= 0 &amp;&amp; j - 1 &lt; 0)&#123;\n                dp[i][j] = dp[i - 1][j] + num[i][j];\n            &#125;else if(i - 1 &gt;= 0 &amp;&amp; j - 1 &gt;= 0)&#123;\n                dp[i][j] = max(dp[i - 1][j - 1] + num[i][j], dp[i - 1][j] + num[i][j]);\n            &#125;\n        &#125;\n    &#125;\n// 因为向左下走的次数与向右下走的次数相差不能超过 1\n// 所以答案一定在中间\n    if(n%2 == 0)&#123;\n        cout &lt;&lt; max(dp[n - 1][n / 2 - 1], dp[n - 1][n / 2]);\n    &#125;else&#123;\n        cout &lt;&lt; dp[n - 1][n / 2];\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/06/C++_%E6%8F%90%E5%8F%96%E5%B0%8F%E6%95%B0/",
            "url": "http://example.com/2022/12/06/C++_%E6%8F%90%E5%8F%96%E5%B0%8F%E6%95%B0/",
            "title": "C++ 提取小数",
            "date_published": "2022-12-06T09:45:00.000Z",
            "content_html": "<p>OpenAi写的一段代码，太值得学习了</p>\n<p><del>自己写for循环提取小数实在是太蠢了</del></p>\n<h2 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h2><pre><code class=\"c++\">std::copy(start, end, std::back_inserter(container));\n\nstd::copy(iterator source_first, iterator source_end, iterator target_start);\n</code></pre>\n<p>因为第三个参数要接受一个迭代器，所以需要使用<code>back_inserter(container)</code></p>\n<h2 id=\"regex\"><a href=\"#regex\" class=\"headerlink\" title=\"regex\"></a>regex</h2><p>pass</p>\n<pre><code class=\"c++\">string expression = &quot;4.12*3.14&quot;;\nregex pattern(&quot;([\\\\d.]+)|([+\\\\-*/()])&quot;);\nvector&lt;string&gt; words;\ncopy(\n    sregex_token_iterator(expression.begin(), expression.end(), pattern),\n    sregex_token_iterator(),\n    back_inserter(words));\n\nfor(int i = 0; i &lt; words.size(); i++)\n    cout &lt;&lt; words[i] &lt;&lt; endl;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/11/28/%E4%BD%8D%E8%BF%90%E7%AE%97/",
            "url": "http://example.com/2022/11/28/%E4%BD%8D%E8%BF%90%E7%AE%97/",
            "title": "位运算",
            "date_published": "2022-11-28T03:47:00.000Z",
            "content_html": "<h6 id=\"136-Single-Number\"><a href=\"#136-Single-Number\" class=\"headerlink\" title=\"136. Single Number\"></a>136. Single Number</h6><p><img data-src=\"https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2022/11/4226140631.png\" alt=\"136\"></p>\n<ul>\n<li>交换律：a ^ b ^ c &lt;&#x3D;&gt; a ^ c ^ b</li>\n<li>任何数于0异或为任何数 0 ^ n &#x3D;&gt; n</li>\n<li>相同的数异或为0: n ^ n &#x3D;&gt; 0</li>\n</ul>\n<p><code>var a = [2, 3, 2, 4, 4]</code></p>\n<p><code>2 ^ 3 ^ 2 ^ 4 ^ 4 等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 =&gt; 0 ^ 0 ^3 =&gt; 3</code></p>\n<h6 id=\"1758-Minimum-Changes-To-Make-Alternating-Binary-String\"><a href=\"#1758-Minimum-Changes-To-Make-Alternating-Binary-String\" class=\"headerlink\" title=\"1758. Minimum Changes To Make Alternating Binary String\"></a>1758. Minimum Changes To Make Alternating Binary String</h6><p><img data-src=\"https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2022/11/2630183447.png\" alt=\"1758\"></p>\n<pre><code class=\"c++\">// 1 &amp; 1 = 1\n\n// 1 &amp; 0 = 0\n\n// 0 &amp; 0 = 0\n\nint minOperations(string s) &#123;\n        char a[2] = &#123;&#39;0&#39;, &#39;1&#39;&#125;;\n        int ans = 0, t = 0;\n        for(int i = 0; i &lt; s.size(); i++) &#123;\n            if(a[i &amp; 1] == s[i]) ans++;\n            else t++;\n        &#125;\n        return min(ans, t);\n    &#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/11/11/C++%E5%A4%A7%E4%BD%9C%E4%B8%9A/",
            "url": "http://example.com/2022/11/11/C++%E5%A4%A7%E4%BD%9C%E4%B8%9A/",
            "title": "C++大作业",
            "date_published": "2022-11-11T06:04:00.000Z",
            "content_html": "<h4 id=\"暂时bug-x2F-问题\"><a href=\"#暂时bug-x2F-问题\" class=\"headerlink\" title=\"暂时bug&#x2F;问题\"></a>暂时bug&#x2F;问题</h4><ul>\n<li>无法计算负数</li>\n<li>只能整数</li>\n<li>减法只能前者大于后者</li>\n<li>无法判断表达式的准确性</li>\n<li><del>复数实部不能小于0</del><br><em><strong>……</strong></em><br><del>头秃</del></li>\n</ul>\n<pre><code class=\"cpp\">// 标准:GNU C++ 14\n// 编译器:GNU GCC 8.1.0 64-bit Debug\n#include &lt;bits/stdc++.h&gt;\n#define MAX 10000\nusing namespace std;\nstack &lt;char&gt; opt;\t\t// 操作数\nstack &lt;string&gt; num;\t\t// 符号位\n\n// 长度判断\nint CompareLength(string a, string b) &#123;\n    return a.length() &gt;= b.length() ? 1 : 0;\n&#125;\n\n// 高精数大小判断\nint CompareSize(string a, string b)&#123;\n    if(a.length() &gt; b.length()) return 1;\n    if(a.length() &lt; b.length()) return -1;\n    for(int i = 0; i &lt; a.length(); i++)&#123;\n        if(a[i] &gt; b[i]) return 1;\n        if(a[i] &lt; b[i]) return -1;\n    &#125;\n    return 0;\n&#125;\n\n// 高精度加法\nstring BigAdd(string a, string b) &#123;\n    int la, lb, up = 0, temp;\t// up进位数\n    string n;\n    la = a.length();\n    lb = b.length();\n    if (CompareLength(a, b)) &#123;\t\t// 判断长度，短字符串前端补零\n        for (int i = 0; i &lt; la - lb; i++)\n            b = &quot;0&quot; + b;\n    &#125; else &#123;\n        for (int i = 0; i &lt; lb - la; i++)\n            a = &quot;0&quot; + a;\n    &#125;\n    for (int i = max(la, lb) - 1; i &gt;= 0; i--) &#123;\n        temp = a[i] - &#39;0&#39; + b[i] - &#39;0&#39; + up;\t// 目标 = 被加数 + 加数 + 进位数\n        up = temp / 10;\t\t\t// 进位数\n        temp %= 10;\n        n += char(temp) + &#39;0&#39;;\n    &#125;\n    if (up != 0) n += char(up) + &#39;0&#39;;\t\t// 99 + 1\n    reverse(n.begin(), n.end());\n\n    return n;\n&#125;\n\n// 高精度减法\n// 被减数需大于减除\nstring BigSub(string a, string b) &#123;\n    int na[MAX] = &#123;0&#125;, nb[MAX] = &#123;0&#125;, an[MAX] = &#123;0&#125;, la, lb;\t\t\t// 初始化\n    string n;\n    la = a.length();\n    lb = b.length();\n    for (int i = 0; i &lt; la; i++) na[la - i - 1] = a[i] - &#39;0&#39;;\t\t// 反转操作数，写入整形数组方便运算\n    for (int i = 0; i &lt; lb; i++) nb[lb - i - 1] = b[i] - &#39;0&#39;;\n    for (int i = 0; i &lt; la; i++) &#123;\n        if (na[i] &lt; nb[i]) &#123;\t\t\t// 借位操作\n            na[i] += 10;\n            na[i + 1]--;\n        &#125;\n        an[i] = na[i] - nb[i];\n    &#125;\n    for (int i = 0; i &lt; la; i++)\t\t\t// 写入输出\n        n += an[i] + &#39;0&#39;;\n    reverse(n.begin(), n.end());\t\t\t// 反转目标\n    n.erase(0, n.find_first_not_of(&#39;0&#39;));\t\t\t// 去除前导0\n    if (n == &quot;&quot;) n = &quot;0&quot;;\t\t\t// 100-100\n\n    return n;\n&#125;\n\n// 高精度乘法\nstring BigMul(string a, string b) &#123;\n    int la, lb, temp_int, up = 0;\n    string temp_str, n = &quot;0&quot;;\n    la = a.length();\n    lb = b.length();\n    reverse(a.begin(), a.end());\t\t\t// 反转方便操作\n    reverse(b.begin(), b.end());\n    for (int i = 0; i &lt; la; i++) &#123;\n        for (int j = 0; j &lt; lb; j++) &#123;\n            temp_int = (a[i] - &#39;0&#39;) * (b[j] - &#39;0&#39;) + up;\t\t\t// 加法同理，进位操作\n            up =  temp_int / 10;\n            temp_int %= 10;\n            temp_str += temp_int + &#39;0&#39;;\t\t\t\t// 按位写入临时字符串\n            if (up &amp;&amp; j == lb - 1) temp_str += (char)(up + &#39;0&#39;);\t\t\t// 防止2*5无法进位\n        &#125;\n        reverse(temp_str.begin(), temp_str.end());\n        up = 0;\t\t\t// \t置空进位符\n        for (int j = 0; j &lt; i; j++)\ttemp_str += &quot;0&quot;;\t\t\t// 移位处理，n+10*i同理\n        //\t\tcout &lt;&lt; temp_str &lt;&lt; endl;\n        n = BigAdd(temp_str, n);\n        temp_str = &quot;&quot;;\t\t\t// 置空按位乘\n    &#125;\n    n.erase(0, n.find_first_not_of(&#39;0&#39;));\t\t\t// 0*1\n    if (n == &quot;&quot;) n = &quot;0&quot;;\n\n    return n;\n&#125;\n\n// 高精度除法\nstring BigDiv(string a, string b, int flag = 1) &#123;\n    string temp = b, n;\n    int l = a.length() - b.length();\t\t\t// 商预操作\n    for(int i = 0; i &lt; a.length(); i++) n += &quot;0&quot;;\t\t\t// 商预操作\n    for(int i = l; i &gt;= 0; i--)&#123;\n        for(int j = 0; j &lt; i; j++)&#123;\t\t\t// 被除数添零\n            temp += &quot;0&quot;;\n        &#125;\n        while(CompareSize(a, temp) &gt;= 0)&#123;\n            n[i]++;\n            a = BigSub(a, temp);\t\t\t// 减法模拟\n        &#125;\n        temp = b;\n    &#125;\n    reverse(n.begin(), n.end());\n    n.erase(0, n.find_first_not_of(&quot;0&quot;));\n    if (n == &quot;&quot;) n = &quot;0&quot;;\n\n    if(flag) return n;\n    else return a;\t\t\t// a为余数\n&#125;\n\nstring BigMod(string a, string b) &#123;\treturn BigDiv(a, b, 0); &#125;\n\n// 中缀\nint Priority(char a) &#123;\t\t// 符号优先级\n    if (a == &#39;+&#39; || a == &#39;-&#39;) return 1;\n    else if (a == &#39;*&#39; || a == &#39;/&#39;) return 2;\n    else return -1;\n&#125;\n\nvoid Clc(char tag) &#123;\n    string a = num.top();\n    num.pop();\n    string b = num.top();\n    num.pop();\n    if (tag == &#39;+&#39;) num.push(BigAdd(a, b));\n    else if (tag == &#39;-&#39;) num.push(BigSub(b, a));\t\t\t// 注意出栈顺序\n    else if (tag == &#39;*&#39;) num.push(BigMul(a, b));\n    else if (tag == &#39;/&#39;) num.push(BigDiv(b, a));\n    else if (tag == &#39;%&#39;) num.push(BigMod(b, a));\n&#125;\n\n// 整数运算\nstring InitNum(string str)&#123;\n    string temp;\n    bool flag = false;\n    for (int i = 0; i &lt; str.length(); i++) &#123;\n        if (str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;) &#123;\n            temp += str[i];\n            flag = true;\t\t\t// 为后续判断是否有剩余未入栈，如 1+1\n        &#125; else if (flag) &#123;\n            num.push(temp);\n            temp = &quot;&quot;;\n            flag = false;\n        &#125;\n        if (str[i] == &#39;(&#39;) opt.push(str[i]);\n        if (str[i] == &#39;+&#39; || str[i] == &#39;-&#39; || str[i] == &#39;*&#39; || str[i] == &#39;/&#39; || str[i] == &#39;%&#39;) &#123;\n            if (opt.empty())\topt.push(str[i]);\t\t\t// 栈空直接入栈\n            else &#123;\n                if (Priority(opt.top()) &gt;= Priority(str[i])) &#123;\t\t\t// 判断优先级，当栈顶大于等于当前操作符，当前操作符不入栈直接运算\n                    Clc(opt.top());\n                    opt.pop();\n                    opt.push(str[i]);\t\t\t// 运算结束，高优先级出栈，当前操作符入栈\n                &#125; else opt.push(str[i]);\t\t\t// 反之出栈\n            &#125;\n        &#125;\n        if (str[i] == &#39;)&#39;) &#123;\t\t\t// 右括号全出栈，直至栈顶为左括号相匹配结束出栈\n            while (opt.top() != &#39;(&#39;) &#123;\n                Clc(opt.top());\n                opt.pop();\n            &#125;\n            opt.pop();\t\t\t// 弹出左括号\n        &#125;\n    &#125;\n    if (flag) num.push(temp);\t\t\t// 标记判断是否有剩余为入栈\n    // 操作符平级\n    while (!opt.empty()) &#123;\t\t\t// 循环结束到操作栈为空\n        Clc(opt.top());\n        opt.pop();\n    &#125;\n    //\tcout &lt;&lt; num.top();\n\n    return num.top();\n&#125;\n\n// 复数运算\ncomplex&lt;long int&gt; Clc_complex(char tag, complex&lt;long int&gt; c1, complex&lt;long int&gt; c2) &#123;\n    if (tag == &#39;+&#39;)\treturn c1+c2;\n    else if (tag == &#39;-&#39;) return c1-c2;\n    else if (tag == &#39;*&#39;) return c1*c2;\n    else if (tag == &#39;/&#39;) return c1/c2;\n&#125;\n\nstring InitComplex(string str)&#123;\n    string com = &quot;&quot;, tempReal = &quot;&quot;, tempComplex = &quot;&quot;;\t\t// 临时复数、临时实部、临时虚部\n    char complexOpt;\t\t\t// 虚部符号位\n    int indexRight, indexLeft;\n    int complexCount;\t\t\t// 复数个数\n    for (int i = 0; i &lt; str.length(); i++)\t\t// 判断复数个数，一个i为一个复数\n        if(str[i] == &#39;i&#39;) complexCount++;\n    complex&lt;long int&gt; c[complexCount];\n    complexCount = 0;\n    while(str != &quot;&quot;)&#123;\n        // 提取复数\n        indexRight = str.find(&#39;(&#39;);\n        indexLeft = str.find(&#39;)&#39;);\n        com = str.substr(indexRight, indexLeft + 1);\n        complexOpt = com.find(&#39;+&#39;)!=string::npos?&#39;+&#39;:&#39;-&#39;;\n        tempReal = com.substr(1, com.find(complexOpt) - 1);\n        tempComplex = com.substr(com.find(complexOpt) + 1, com.length() - 4 - tempReal.length());\n//\t\tcout &lt;&lt; com.length() &lt;&lt; &quot; &quot; &lt;&lt;tempReal &lt;&lt; &quot; &quot; &lt;&lt; tempComplex &lt;&lt; endl;\n        c[complexCount] = &#123;stol(tempReal), stol(complexOpt+tempComplex)&#125;;\n        // 提取完成后擦除\n        str.erase(indexRight, indexLeft + 1);\n        // 四则运算判断优先级\n        if (str[0] == &#39;+&#39; || str[0] == &#39;-&#39; || str[0] == &#39;*&#39; || str[0] == &#39;/&#39;) &#123;\n            if (opt.empty())\topt.push(str[0]);\t\t\t// 栈空直接入栈\n            else &#123;\n                if (Priority(opt.top()) &gt;= Priority(str[0])) &#123;\t\t\t// 判断优先级，当栈顶大于等于当前操作符，当前操作符不入栈直接运算\n                    c[complexCount - 1] = Clc_complex(opt.top(), c[complexCount - 1], c[complexCount]);\n//\t\t\t\t\tcout &lt;&lt; c[complexCount - 1];\n                    complexCount -= 1;\n                    opt.pop();\n                    opt.push(str[0]);\t\t\t// 运算结束，高优先级出栈，当前操作符入栈\n                &#125; else opt.push(str[0]);\t\t\t// 反之入栈\n            &#125;\n            // 擦除操作符\n            str.erase(0, 1);\n        &#125;\n        complexCount++;\n    &#125;\n    // 操作符平级\n    while (!opt.empty()) &#123;\n        c[complexCount - 2] = Clc_complex(opt.top(), c[complexCount - 2], c[complexCount - 1]);\n        complexCount--;\n        opt.pop();\n    &#125;\n\n    com = to_string(c[0].real()) + complexOpt + to_string(c[0].imag()) + &#39;i&#39;;\n    complexOpt = (c[0].imag() &lt; 0)?&#39;-&#39;:&#39;+&#39;;\n\n    return com;\n&#125;\n\n// 判断复数、实数\nstring Complex_Or_Real(string str)&#123;\n    for(int i = 0; i &lt; str.length(); i++)&#123;\n        if(str[i] == &#39;i&#39;) return InitComplex(str);\n    &#125;\n    return InitNum(str);\n&#125;\n\nint main() &#123;\n    string str, a;\n    cin &gt;&gt; str;\n    a = Complex_Or_Real(str);\n    cout &lt;&lt; a;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/",
            "url": "http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/",
            "title": "Map 单词分析",
            "date_published": "2021-11-08T07:30:00.000Z",
            "content_html": "<p><strong>蓝桥杯无法使用<code>for(x : y)&#123;&#125;</code> 、 <code>auto</code>等的C11语法和关键字</strong></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nmap&lt;char, int&gt; m;\n\nint main(void)&#123;\n    string str;\n    char mc;\n    int s = 0;\n    for(int i = 97; i &lt;= 122; i++)&#123;\n        m.insert(make_pair((char)i, 0));\n    &#125;\n    cin &gt;&gt; str;\n    for(int i = 0; i &lt; str.size(); i++)&#123;\n        m[str[i]]++;\n    &#125;\n    for(map&lt;char, int&gt;::iterator i = m.begin(); i != m.end(); i++)&#123;\n        if(s &lt; i-&gt;second) mc = i-&gt;first, s = i-&gt;second;\t\t// 记录次数\n    &#125;\n    cout &lt;&lt; mc &lt;&lt; endl &lt;&lt; m[mc];\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/",
            "title": "DFS迷宫问题",
            "date_published": "2021-11-08T06:36:00.000Z",
            "content_html": "<pre><code>#include&lt;bits/stdc++.h&gt;\n#pragma GCC optimize(2)\nusing namespace std;\n\nint m[101][101];\nint xS, yS, xE, yE;\nint s;\n\nvoid dfs(int x, int y)&#123;\n    if(x == xE &amp;&amp; y == yE)&#123;\n        s++;\n        return;\n    &#125;else&#123;\t\t// 遍历四个方向 \n        m[x][y] = 0;\n        if(m[x + 1][y])&#123;\n            m[x + 1][y] = 0;\t\t// 占位，防止死循环 \n            dfs(x + 1, y);\n            m[x + 1][y] = 1;\n        &#125;\n        if(m[x - 1][y])&#123;\n            m[x - 1][y] = 0;\n            dfs(x - 1, y);\n            m[x - 1][y] = 1;\n        &#125;\n        if(m[x][y + 1])&#123;\n            m[x][y + 1] = 0;\n            dfs(x, y + 1);\n            m[x][y + 1] = 1;\n        &#125;\n        if(m[x][y - 1])&#123;\n            m[x][y - 1] = 0;\n            dfs(x, y - 1);\n            m[x][y - 1] = 1;\n        &#125;\n    &#125;\n&#125;\n\nint main(void)&#123;\n    ios::sync_with_stdio(false);\n    int x, y, k, Ox, Oy;\n    cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\n    for(int i = 1; i &lt;= x; i++)\t// 棋盘预定义\n        for(int j = 1; j &lt;= y; j++)\n            m[i][j] = 1;\n    cin &gt;&gt; xS &gt;&gt; yS &gt;&gt; xE &gt;&gt; yE;\n    for(int i = 0; i &lt; k; i++)&#123;\t// 预先写入障碍\n        cin &gt;&gt; Ox &gt;&gt; Oy;\n        m[Ox][Oy] = 0;\n    &#125;\n    dfs(xS, yS);\n    cout &lt;&lt; s;\n\n    return 0;\n&#125; \n</code></pre>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/11/05/C++_STL%E4%B8%AD%E7%9A%84next_permutation/",
            "url": "http://example.com/2021/11/05/C++_STL%E4%B8%AD%E7%9A%84next_permutation/",
            "title": "C++ STL中的next_permutation",
            "date_published": "2021-11-05T06:45:00.000Z",
            "content_html": "<blockquote>\n<p>Rearranges the elements in the range <code>[first,last)</code> into the next <em><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcGx1c3BsdXMuY29tL2xleGljb2dyYXBoaWNhbF9jb21wYXJl\">lexicographically</span> greater</em> permutation.</p>\n<p><em>将范围内的元素重新排列<code>[first,last)</code>为下一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcGx1c3BsdXMuY29tL2xleGljb2dyYXBoaWNhbF9jb21wYXJl\">字典序</span>更大的排列。</em></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcGx1c3BsdXMuY29tLw==\">–cplusplus.com</span></p>\n</blockquote>\n<p>对于next_permutation函数，其函数原型为：</p>\n<pre><code> #include &lt;algorithm&gt;\n bool next_permutation(iterator start,iterator end)\n</code></pre>\n<p>如下例子：</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()&#123;\n    int num[3]=&#123;1, 2, 3&#125;;\n    do&#123;\n        cout &lt;&lt; num[0] &lt;&lt; &quot; &quot; &lt;&lt; num[1] &lt;&lt; &quot; &quot; &lt;&lt; num[2] &lt;&lt; endl;\n    &#125;while(next_permutation(num, num + 3));\n    return 0;\n&#125;\n\n输出结果：\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n</code></pre>\n<p>当我们把<code>while(next_permutation(num, num + 3))</code>中的<code>3</code>改为<code>2</code>时，输出就变为了：</p>\n<pre><code>1 2 3\n2 1 3\n</code></pre>\n<p>由此可见，next_permutation是对数组前n项进行全排列</p>\n<p>同理，既然有下一个全排列函数，那肯定是有上一个全排列函数：<code>prev_permutation</code>使用方法与<code>next_permutation</code>一致。</p>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/",
            "url": "http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/",
            "title": "Vector 二分查找",
            "date_published": "2021-11-04T07:39:00.000Z",
            "content_html": "<p>二分查找：</p>\n<ul>\n<li>lower_bound：查找第一个大于或等于某个元素的位置。</li>\n<li>upper_bound：查找第一个大于某个元素的位置。</li>\n</ul>\n<p>Vector 插入元素</p>\n<ul>\n<li>iterator insert(iterator it, const T&amp; x)：iterator向量中迭代器指向元素前增加一个元素x</li>\n<li>iterator insert(iterator it, int n,const T&amp; x)：向量中迭代器指向元素前增加n个相同的元素x</li>\n<li>iterator insert(iterator it, const_iterator first, const_iterator last)：向量中迭代器指向元素前插入另一个相同类型向量的[first, last)间的数据</li>\n</ul>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(void)&#123;\n    vector&lt;int&gt; arr;\n    int t, k, a;\n    for(int i = 0; i &lt; 9; i++)&#123;\n        cin &gt;&gt; t;\n        arr.push_back(t);\n    &#125;\n    cin &gt;&gt; k;\n    auto pos = upper_bound(arr.begin(), arr.end(), k); \t// vector&lt;int&gt;::iterator\n    arr.insert(pos, k);\n    for(int i = 0; i &lt; 10; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; endl;\n\n    return 0;\n&#125; \n</code></pre>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF/",
            "url": "http://example.com/2021/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF/",
            "title": "二叉树模板",
            "date_published": "2021-10-28T09:03:28.000Z",
            "content_html": "<pre><code>#include&lt;bits/stdc++.h&gt;\n#pragma GCC optimize(2)\nusing namespace std;\n\nstruct tree&#123;\n    int left;\n    int right;\n&#125;;\n\ntree t[1000];\n\nint dfs(int n)&#123;\t\t// 深度 \n    if(!n) return 0;\n    return max(dfs(t[n].left), dfs(t[n].right)) + 1;\n&#125;\n\nvoid f(int n)&#123;\t\t// 先序 \n    cout &lt;&lt; n &lt;&lt; &quot; &quot;;\n    if(t[n].left) f(t[n].left);\n    if(t[n].right) f(t[n].right);\n&#125;\n\nvoid s(int n)&#123;\t\t// 中序 \n    if(t[n].left) s(t[n].left);\n    cout &lt;&lt; n &lt;&lt; &quot; &quot;;\n    if(t[n].right) s(t[n].right);\n&#125;\n\nvoid e(int n)&#123;\t\t// 后序 \n    if(t[n].left) e(t[n].left);\n    if(t[n].right) e(t[n].right);\n    cout &lt;&lt; n &lt;&lt; &quot; &quot;;\n&#125;\n\nint main(void)&#123;\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; t[i].left &gt;&gt; t[i].right;\n    \n    return 0;\n&#125; \n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/28/%E5%8D%A1%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%82%86%E6%97%A0%E5%BF%8C%E6%83%AESTL/",
            "url": "http://example.com/2021/10/28/%E5%8D%A1%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%82%86%E6%97%A0%E5%BF%8C%E6%83%AESTL/",
            "title": "卡常小技巧，肆无忌惮STL",
            "date_published": "2021-10-28T08:25:00.000Z",
            "content_html": "<pre><code>#pragma GCC optimize(2)\nios::sync_with_stdio(false);\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/28/%E6%95%B0%E7%BB%84%E7%B2%98%E8%B4%B4%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96C++/",
            "url": "http://example.com/2021/10/28/%E6%95%B0%E7%BB%84%E7%B2%98%E8%B4%B4%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96C++/",
            "title": "数组粘贴，初始化C++",
            "date_published": "2021-10-28T03:51:00.000Z",
            "content_html": "<p>粘贴：memcpy()</p>\n<p>初始化（可初始化结构体内的数组元素）：memset()</p>\n<pre><code>int a[5];\nint b[5] = &#123;1, 2, 3, 4, 5&#125;\nmemset(a, 0, sizeof(int));\t// 把a中所有数组元素初始化为1\nmemcpy(a, b, 5 * sizeof(int));\t// 把b数组覆盖到a数组\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/27/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%98%B6%E4%B9%98%E6%A8%A1%E6%9D%BF(C++)/",
            "url": "http://example.com/2021/10/27/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%98%B6%E4%B9%98%E6%A8%A1%E6%9D%BF(C++)/",
            "title": "高精度阶乘模板(C++)",
            "date_published": "2021-10-27T04:13:00.000Z",
            "content_html": "<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAX = 10000;\nstruct N&#123;\n    int len;\n    int a[MAX];\n    N(int x = 0)&#123;\t\t// 初始化\n        memset(a, 0, sizeof(a));\n        for(len = 1; x; len++)&#123;\n            a[len] = x % 10;\n            x /= 10;\n        &#125;\n    &#125;\n    void f(int _l)&#123;\t\t// 进位\n        len = _l;\n        for(int i = 1; i &lt;= len; i++)&#123;\n            a[i + 1] += a[i] / 10;\n            a[i] %= 10;\n        &#125;\n        for(;!a[len];) len--;\t\t// 去除无效前置0\n    &#125;\n    void print()&#123;\n        for(int i = max(len, 1); i &gt;= 1; i--)\n            printf(&quot;%d&quot;, a[i]);\n    &#125;\n    int &amp;operator[](int i)&#123;\t\t// 重载[]，方便直接使用Node[num]访问Node数组\n        return a[i];\n    &#125;\n    N operator*(int t)&#123;\t\t// 重载*\n        N c;\n        for(int i = 1; i &lt;= len; i++)\n            c[i] = a[i] * t;\n        c.f(len + 11);\n        return c;\n    &#125;\n&#125;;\n\nint main(void)&#123;\n    N fac(1);\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)\n        fac = fac * i; \n    fac.print();\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/26/c_str()%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/",
            "url": "http://example.com/2021/10/26/c_str()%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/",
            "title": "c_str()使用方法",
            "date_published": "2021-10-26T13:52:15.000Z",
            "content_html": "<pre><code>//标准库的string类提供了三个成员函数来从一个string得到c类型的字符数组\n//c_str()：生成一个const char*指针，指向以空字符终止的数组。\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n&#123;\n    //string--&gt;char*\n    //c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同\n    //这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用后，其中的数据就会失效。\n    //因此要么现用先转换，要么把它的数据复制到用户自己可以管理的内存中\n    const char *c;\n    string s = &quot;1234&quot;;\n    c = s.c_str();\n    cout&lt;&lt;c&lt;&lt;endl;\n    s = &quot;abcde&quot;;\n    cout&lt;&lt;c&lt;&lt;endl;\n&#125;\n</code></pre>\n<p>输出：</p>\n<pre><code>1234\nabcde\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/23/C++_STL%E5%AE%B9%E5%99%A8%EF%BC%8811%E4%B8%AA%EF%BC%89/",
            "url": "http://example.com/2021/10/23/C++_STL%E5%AE%B9%E5%99%A8%EF%BC%8811%E4%B8%AA%EF%BC%89/",
            "title": "C++ STL容器（11个）",
            "date_published": "2021-10-23T08:33:00.000Z",
            "content_html": "<h1 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque :\"></a><code>deque</code> :</h1><h1 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list :\"></a><code>list</code> :</h1><h1 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue :\"></a><code>queue</code> :</h1><p><img data-src=\"https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2022/11/3285107056.jpg\"></p>\n<h1 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue :\"></a><code>priority_queue</code> :</h1><h4 id=\"默认大顶堆（后两参数可缺省）\"><a href=\"#默认大顶堆（后两参数可缺省）\" class=\"headerlink\" title=\"#### 默认大顶堆（后两参数可缺省）\"></a>#### 默认大顶堆（后两参数可缺省）</h4><pre><code>priority_queue&lt;int&gt; big_heap;\n</code></pre>\n<h4 id=\"大顶堆\"><a href=\"#大顶堆\" class=\"headerlink\" title=\"大顶堆\"></a>大顶堆</h4><pre><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; big_heap2;\n</code></pre>\n<h4 id=\"小顶堆\"><a href=\"#小顶堆\" class=\"headerlink\" title=\"小顶堆\"></a>小顶堆</h4><pre><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; small_heap;\n</code></pre>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p><code>bool empty() const</code>：返回值为true，说明队列为空</p>\n<p><code>int size() const</code>：返回优先队列中元素的数量</p>\n<p><code>void pop()</code>：删除队列顶部的元素，也即根节点</p>\n<p><code>int top()</code>：返回队列中的顶部元素，但不删除该元素</p>\n<p><code>void push(int arg)</code>：将元素arg插入到队列之中；</p>\n<h1 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack :\"></a><code>stack</code> :</h1><h1 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector :\"></a><code>vector</code> :</h1><h1 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map :\"></a><code>map</code> :</h1><h1 id=\"multimap\"><a href=\"#multimap\" class=\"headerlink\" title=\"multimap :\"></a><code>multimap</code> :</h1><h1 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set :\"></a><code>set</code> :</h1><h1 id=\"multiset\"><a href=\"#multiset\" class=\"headerlink\" title=\"multiset :\"></a><code>multiset</code> :</h1><h1 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset :\"></a><code>bitset</code> :</h1>",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84sort%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2021/10/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84sort%E6%8E%92%E5%BA%8F/",
            "title": "二维数组sort排序",
            "date_published": "2021-10-19T07:25:51.000Z",
            "content_html": "<pre><code>for(int i = 0; i &lt; n; i++)\n    sort(s[i], s[i] + len);\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/16/%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98_%E5%88%86%E7%B3%96%E6%9E%9C%E3%80%90%E7%AC%AC%E4%BA%94%E5%B1%8A%E3%80%91%E3%80%90%E7%9C%81%E8%B5%9B%E3%80%91%E3%80%90C%E7%BB%84%E3%80%91/",
            "url": "http://example.com/2021/10/16/%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98_%E5%88%86%E7%B3%96%E6%9E%9C%E3%80%90%E7%AC%AC%E4%BA%94%E5%B1%8A%E3%80%91%E3%80%90%E7%9C%81%E8%B5%9B%E3%80%91%E3%80%90C%E7%BB%84%E3%80%91/",
            "title": "历届真题 分糖果【第五届】【省赛】【C组】",
            "date_published": "2021-10-16T08:35:00.000Z",
            "content_html": "<p><img data-src=\"http://mioe.xyz/usr/uploads/2021/10/3684429808.png\" alt=\"image.png\"></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint eq(int *t, int l)&#123;\n    for(int i = 1; i &lt; l; i++)\n        if(t[0] != t[i]) return 0;\n    return 1;\n&#125;\n\nint main(void)&#123;\n    int n, m;\n    cin &gt;&gt; n;\n    int c[n], i, s = 0, bf[n];\t\t// bf[n] 缓存区 \n    for(i = 0; i &lt; n; i++)\n        cin &gt;&gt; c[i];\n    while(1)&#123;\t\t\t\t\t\t// 思路：每次分糖果，把第i个 分出 的糖果记录到 对应的 缓存区， \n        for(i = 0; i &lt; n; i++)&#123;\t\t// \t\t 第i个小朋友的苹果等于 自身糖果的一半 加  i - 1 缓冲区的糖果 \n            c[i] /= 2;\t\t\t\t//\t例如： 有三个小朋友\n            bf[i] = c[i];\t\t\t//         2 2 4 \n        &#125;\t\t\t\t\t\t\t// 对半分：1 1 2(1)\n        c[0] += bf[n - 1];\t\t\t//          / / / \n        for(i = 1; i &lt; n; i++)\t \t// 缓冲区：1 1 2 \n            c[i] += bf[i - 1];\t\t//         | | | \n        for(i = 0; i &lt; n; i++)\t\t// 完成：3 2 3(3) \n            if(c[i] % 2 != 0)&#123;\n                c[i]++;\n                s++;\n            &#125;\n        if(eq(c, n) == 1) break;\n    &#125;\n\n    cout &lt;&lt; s;\n    return 0;\n&#125; \n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/15/XX_XX_XX%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%90%E5%8F%96%E6%95%B0%E5%AD%97/",
            "url": "http://example.com/2021/10/15/XX_XX_XX%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%90%E5%8F%96%E6%95%B0%E5%AD%97/",
            "title": "XX:XX:XX类型字符串提取数字",
            "date_published": "2021-10-15T09:26:16.000Z",
            "content_html": "<p>洛谷P1615</p>\n<pre><code>cin &gt;&gt; time1\nsscanf(time1.c_str(), &quot;%d:%d:%d&quot;, &amp;h1, &amp;m1, &amp;s1); // c_str()获取字符串地址\n// 或者直接这样写 scanf(&quot;%d:%d:%d&quot;, &amp;h1, &amp;m1, &amp;s1);\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/01/P2911_[USACO08OCT]Bovine_Bones_G_(C)/",
            "url": "http://example.com/2021/10/01/P2911_[USACO08OCT]Bovine_Bones_G_(C)/",
            "title": "P2911 [USACO08OCT]Bovine Bones G (C)",
            "date_published": "2021-10-01T12:40:00.000Z",
            "content_html": "<p><img data-src=\"https://i.loli.net/2021/10/01/dcA2xWtmfYQRaqD.png\" alt=\"image.png\"></p>\n<pre><code>/*\n    根据题意，总共3个骰子，每个骰子有 S个面，因为数据范围较小，可以直接选择暴力\n    每次总和记录到相应的结构体(Sum = 10 -&gt; struct[10])，结构体中保存两个数据：总和(num)、次数(times) \n    最后使用快排(qsort)筛出次数(times)最小的目标 \n*/ \n\n#include&lt;stdio.h&gt;\n\nstruct A&#123;\t\t// 声明结构体，存放点数总和与次数 \n    int num;\n    int times;\n&#125;;\n\nint compare(const void *a, const void *b)&#123;\n    struct A *p1 = (struct A *)a;\n    struct A *p2 = (struct A *)b;\n    if(p1-&gt;times == p2-&gt;times) return p1-&gt;num - p2-&gt;num;\t\t// 题意：如果出现概率一样时输出最小总和 \n    return p2-&gt;times - p1-&gt;times;\n&#125;\n\nint main(void)&#123;\n    int s1, s2, s3, s, i, j, k;\n    struct A a[80];\n    scanf(&quot;%d %d %d&quot;, &amp;s1, &amp;s2, &amp;s3);\n    for(i = 0; i &lt; 81; i++)&#123;\n         a[i].times = 0;\n         a[i].num = 0;\n    &#125;\n    for(i = 1; i &lt;= s1; i++)\n        for(j = 1; j &lt;= s2; j++)\n            for(k = 1; k &lt;= s3; k++)&#123;\n                a[i + j + k].num = i + j + k;\n                a[i + j + k].times++;\n            &#125;\n\n    qsort(a, 80, sizeof(struct A), compare);\n    printf(&quot;%d&quot;, a[0].num);\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/09/11/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F_C%E8%AF%AD%E8%A8%80/",
            "url": "http://example.com/2021/09/11/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F_C%E8%AF%AD%E8%A8%80/",
            "title": "冒泡排序 C语言",
            "date_published": "2021-09-11T09:10:00.000Z",
            "content_html": "<pre><code>#include&lt;stdio.h&gt;\n\n/* 交换函数\nvoid swap(int *pa, int *pb)&#123;\n    int temp;\n    if(*pa &gt; *pb)&#123;\n        temp = *pb;\n        *pb = *pa;\n        *pa = temp; \n    &#125;\n&#125;\n*/\n\nint main(void)&#123;\n    int a[] = &#123;1, 3, 5, 2, 14, 8, 4 ,9&#125;;\n    int i, j;\n    int temp;\n    int num = (sizeof(a) / sizeof(a[0]));\n    printf(&quot;排序前：&quot;);\n    for(i = 0; i &lt; num; i++)&#123;\n        printf(&quot;%d &quot;, a[i]);\n    &#125;\n    printf(&quot;\\n&quot;);\n\n    // 冒泡 \n    for(i = 0; i &lt; num; i++)&#123;\t\t// 游标 \n        for(j = i; j &lt; num - 1; j++)&#123;\t\t// 两两比较 \n            if(a[j] &gt; a[j + 1])&#123;\n                temp = a[j + 1];\n                a[j + 1] = a[j];\n                a[j] = temp;\n            &#125;\n            // swap((a + j), (a + j + 1));\n        &#125;\n    &#125;\n\n    printf(&quot;排序后：&quot;);\n    for(i = 0; i &lt; num; i++)&#123;\n        printf(&quot;%d &quot;, a[i]);\n    &#125;\n    return 1;\n&#125;\n</code></pre>\n",
            "tags": []
        }
    ]
}