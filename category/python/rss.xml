<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;python&#34; category</title>
        <link>http://example.com</link>
        <description>花店不开了，花继续开</description>
        <language>zh-CN</language>
        <pubDate>Fri, 10 Sep 2021 20:39:00 +0800</pubDate>
        <lastBuildDate>Fri, 10 Sep 2021 20:39:00 +0800</lastBuildDate>
        <category>算法</category>
        <category>BFS</category>
        <category>Resilio Sync</category>
        <category>WolfraAlpha</category>
        <category>unity</category>
        <category>数论</category>
        <category>github</category>
        <category>linux</category>
        <category>Open-cv</category>
        <category>模板</category>
        <category>碧蓝航线</category>
        <category>Python</category>
        <category>局域网</category>
        <category>阅读</category>
        <category>相册</category>
        <category>算法模板</category>
        <item>
            <guid isPermalink="true">http://example.com/2021/09/10/%E6%B4%9B%E8%B0%B7%E9%A2%98%E5%BA%93%E7%88%AC%E8%99%AB/</guid>
            <title>洛谷题库爬虫</title>
            <link>http://example.com/2021/09/10/%E6%B4%9B%E8%B0%B7%E9%A2%98%E5%BA%93%E7%88%AC%E8%99%AB/</link>
            <pubDate>Fri, 10 Sep 2021 20:39:00 +0800</pubDate>
            <description><![CDATA[ &lt;pre&gt;&lt;code&gt;import re
import urllib.request, urllib.error
import bs4
import time


baseUrl = &amp;quot;https://www.luogu.com.cn/problem/P&amp;quot;
savePath = &amp;quot;C:\\Users\\666\\Desktop\\p\\&amp;quot;	# 存放位置
maxn = 7000	# 最大爬取数


def main():
    print(&amp;quot;计划爬取到P&amp;#123;&amp;#125;&amp;quot;.format(maxn))
    for i in range(1000, maxn + 1):
        time.sleep(0.2)
        try:
            print(&amp;quot;正在爬取P&amp;#123;&amp;#125;&amp;quot;.format(i))
            html = getHTML(baseUrl + str(i))
            problemMD = getMD(html)
            name = getName(html)
            saveData(problemMD, &amp;quot;P&amp;quot; + str(i) + &amp;quot; &amp;quot; + name + &amp;quot;.md&amp;quot;)
        except Exception:
            pass
        continue
    print(&amp;quot;爬取完毕&amp;quot;)


def getHTML(url):
    headers = &amp;#123;
        &amp;quot;user-agent&amp;quot;: &amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/5&amp;quot;
                      &amp;quot;37.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&amp;quot;
    &amp;#125;
    request = urllib.request.Request(url=url, headers=headers)
    response = urllib.request.urlopen(request)
    html = response.read().decode(&#39;utf-8&#39;)
    return html


def getName(html):
    bs = bs4.BeautifulSoup(html, &amp;quot;html.parser&amp;quot;)
    name = str(bs.select(&amp;quot;h1&amp;quot;)[0])
    name = re.sub(&amp;quot;&amp;lt;h1&amp;gt;&amp;quot;, &amp;quot;&amp;quot;, name)
    name = re.sub(&amp;quot;&amp;lt;/?[a-zA-Z]+[^&amp;lt;&amp;gt;]*&amp;gt;&amp;quot;, &amp;quot;&amp;quot;, name)
    return name


def getMD(html):
    bs = bs4.BeautifulSoup(html, &amp;quot;html.parser&amp;quot;)
    core = bs.select(&amp;quot;article&amp;quot;)[0]
    md = str(core)
    md = re.sub(&amp;quot;&amp;lt;h1&amp;gt;&amp;quot;, &amp;quot;# &amp;quot;, md)
    md = re.sub(&amp;quot;&amp;lt;h2&amp;gt;&amp;quot;, &amp;quot;## &amp;quot;, md)
    md = re.sub(&amp;quot;&amp;lt;h3&amp;gt;&amp;quot;, &amp;quot;#### &amp;quot;, md)
    md = re.sub(&amp;quot;&amp;lt;/?[a-zA-Z]+[^&amp;lt;&amp;gt;]*&amp;gt;&amp;quot;, &amp;quot;&amp;quot;, md)
    md = func(md)
    return md


def func(s: str) -&amp;gt; str:
    res = &amp;quot;&amp;quot;
    left = True
    for i in s:
        if i != &amp;quot;$&amp;quot;:
            res = res + i
        elif left == True:
            res = res + &amp;quot;`&amp;quot; + i
            left = not (left)
        else:
            res = res + i + &amp;quot;`&amp;quot;
            left = not (left)
    return res


def saveData(data, filename):
    cfilename = savePath + filename
    file = open(cfilename, &amp;quot;w&amp;quot;, encoding=&amp;quot;utf-8&amp;quot;)
    for d in data:
        file.writelines(d)
    file.close()


if __name__ == &#39;__main__&#39;:
    main()

&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/06/02/P1223_%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4_python/</guid>
            <title>P1223 排队接水 python</title>
            <link>http://example.com/2021/06/02/P1223_%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4_python/</link>
            <pubDate>Wed, 02 Jun 2021 21:10:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;img data-src=&#34;https://i.loli.net/2021/06/02/kzh7MsgTyiPWaUK.png&#34; alt=&#34;P1223 排队接水&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = int(input())
list1 = list(map(int, input().split()))
c = 1
sum1 = 0
list2 = []
for i in range(n):
    list2.append(&amp;#123;&amp;quot;id&amp;quot;: i + 1, &amp;quot;time&amp;quot;: list1[i]&amp;#125;)
list2.sort(key=lambda rank: rank[&amp;quot;time&amp;quot;])
for i in list2:
    sum1 += i[&amp;quot;time&amp;quot;] * (n - c)
    c += 1
for i in range(n):
    if i == n - 1:
        print(list2[i][&amp;quot;id&amp;quot;], end=&amp;quot;&amp;quot;)
    else:
        print(list2[i][&amp;quot;id&amp;quot;], end=&amp;quot; &amp;quot;)
print()
print(&amp;quot;%.2f&amp;quot; % (sum1/n))
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/06/01/%E5%9B%9E%E6%96%87%E8%B4%A8%E6%95%B0_python/</guid>
            <title>回文质数 python</title>
            <link>http://example.com/2021/06/01/%E5%9B%9E%E6%96%87%E8%B4%A8%E6%95%B0_python/</link>
            <pubDate>Tue, 01 Jun 2021 20:02:49 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;img data-src=&#34;http://mioe.xyz/usr/uploads/2021/06/1304133883.png&#34; alt=&#34;6-01-2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;洛谷卡了很长时间，最终还是没有 AC，最后两个超时，可能是我回文判断选择用字符串的方式导致的，最后没办法了，选择下策直接打表 AC。&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;除 11 外没有偶数位的回文质数，那么 [10000000,100000000] 这个区间根本不用枚举。&lt;/li&gt;
&lt;li&gt;只需要 [2, sqrt (i) + 1]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import math
a, b = map(int, input().split())
list1 = []
if b &amp;gt; 10000000:
    b = 10000000
for i in range(a, b + 1):
    if str(i) == str(i)[::-1]:
        for j in range(2, int(math.sqrt(i)) + 1):
            if i % j == 0:
                break
        else:
            print(i)&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/06/01/%E6%B4%9B%E8%B0%B7_P1106_%E5%88%A0%E6%95%B0%E9%97%AE%E9%A2%98_python%E8%A7%A3%E6%B3%95/</guid>
            <title>洛谷 P1106 删数问题 python解法</title>
            <link>http://example.com/2021/06/01/%E6%B4%9B%E8%B0%B7_P1106_%E5%88%A0%E6%95%B0%E9%97%AE%E9%A2%98_python%E8%A7%A3%E6%B3%95/</link>
            <pubDate>Tue, 01 Jun 2021 19:48:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;img data-src=&#34;http://mioe.xyz/usr/uploads/2021/06/3479330492.png&#34; alt=&#34;6-01-1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一次提交时，因为读题不清，3 个 WA。一开始理解为依次删除最大数，例 50074897 2 得 500747，结果一直 WA，然后被迫下载测试数据，发现正确答案为 4897。&lt;/p&gt;
&lt;p&gt;思索了一番，发现是个贪心问题，还是用 50074897 2 举例:&lt;br&gt;
(1) 5 &amp;gt; 0 , 删除 5, 0074897&lt;br&gt;
 (2) 0 = 0 , 不动 0074897&lt;br&gt;
 (3) 0 = 0 , 同理 0074897&lt;br&gt;
 (5) 7 &amp;gt; 4 , 删除 7，004897&lt;br&gt;
 (6) 去零整理，答案为 4897&lt;br&gt;
Python 天下第一，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m = input()
n = int(input())
i = 0   # 用于下标索引
while quit:
    # 边界默认和0比
    if i + 1 == len(m):
        m = m[:len(m) - 1]
        n -= 1
        i -= 1
    # 判断是否单调递增
    elif m[i] &amp;lt;= m[i + 1]:
        i += 1
        continue
    # 删除非递增项
    else:
        m = m.replace(m[i], &amp;quot;&amp;quot;, 1)
        n -= 1
        i -= 1
    # 循环结束
    if n == 0:
        break
print(int(m))
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/05/31/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
            <title>贪婪算法之背包问题</title>
            <link>http://example.com/2021/05/31/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
            <pubDate>Mon, 31 May 2021 21:54:41 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;img data-src=&#34;http://mioe.xyz/usr/uploads/2021/05/33685418.png&#34; alt=&#34;5-31.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;coins, capacity = map(int, input().split())
emt = []
sum_coin = 0.0
for i in range(coins):
    temp_weight, temp_coin = map(int, input().split())
    emt.append(&amp;#123;&#39;coin&#39;: temp_coin, &#39;weight&#39;: temp_weight, &#39;avg&#39;: temp_coin/temp_weight&amp;#125;)
emt.sort(key=lambda emt_d: emt_d[&#39;avg&#39;], reverse=True)
for i in range(len(emt)):
    if capacity &amp;gt;= emt[i][&#39;weight&#39;]:
        sum_coin += emt[i][&#39;coin&#39;]
        capacity -= emt[i][&#39;weight&#39;]
    elif capacity &amp;lt; emt[i][&#39;weight&#39;] and capacity != 0:
        sum_coin += emt[i][&#39;avg&#39;] * capacity
        break
print(&#39;%.2f&#39; % sum_coin)&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/04/06/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC_%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
            <title>python基础之函数进阶之函数作为返回值/装饰器</title>
            <link>http://example.com/2021/04/06/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC_%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
            <pubDate>Tue, 06 Apr 2021 18:44:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;strong&gt;因为装饰器需要用到返回函数的知识，所以在这里将返回函数和装饰器合并讲解。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;什么是返回函数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，一个函数中 return 可以返回一个或者多个值，但其实，return 不仅可以返回值，还可以返回函数。&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def col(*arg):
    def sum():
        res_sum=0
        for i in arg:
            res_sum=res_sum+i
        return res_sum
    return sum()
a=col(1,2,3,4,5)
print(a)#结果：15
#a=col(1,2,3,4,5)  ==〉
#即a=sum,并且arg=(1,2,3,4,5)也被传入sum中了
#a()==sum()
&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&#34;color:red&#34;&gt;并且因为sum()定义在col()函数中，所以sum()继承了col()函数的局部变量和参数，这就是闭包。&lt;/p&gt;（比如，col()的arg参数就被sum()所继承）
&lt;p&gt;下面来看一个我在检验上面加红的句话时所碰到的一个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#还是用上面这段代码。稍稍修改一下
def col(*arg):
    res_sum=0         #注意：将这句话移动到这里了
    def sum():
        for i in arg:
            res_sum=res_sum+i
        return res_sum
    return sum()
a=col(1,2,3,4,5)
print(a())       

结果报错：local variable &#39;res_sum&#39; referenced before assignment
#既然内部函数可以引用外部函数的变量，为什么res_sum没有被内#部函数所引用？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为啥会报错？我当时很是疑惑，后来终于弄明白，错在这句：res_sum=res_sum+i&lt;/p&gt;
&lt;p style=&#34;color:blue&#34;&gt;这句导致内部函数修改了外部函数的局部变量res_sum，这时，Python认为res_sum是内部函数的局部变量，而res_sum=res_sum+i之前并没有事先定义res_sum，所以当然会发生这种错误。&lt;/p&gt;
&lt;p&gt;所以，需要这样进行修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def col(*arg):
    res_sum=0         
    def sum():
        for i in arg:
            a=res_sum+i     #在内部函数中定义一个新的变量a
        return a
    return sum
a=col(1,2,3,4,5)
print(a())
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;什么是装饰器？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def login():
    pass
@login       #关键字@
def open():
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上例就是一个装饰器的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰器的作用：&lt;/strong&gt;&lt;br&gt;
当我们定义了 open 函数后（可以帮助我们打开某个文件），过了一段时间，发现我们需要在进行 open 之前进行验证用户，如何在&lt;p style=&#34;color:red&#34;&gt;不修改 open 函数的条件下将 login 函数和 open 函数进行结合&lt;/p&gt;，即：运行 open 之前先运行 login？ 这里就要用到装饰器。&lt;/p&gt;
&lt;p&gt;下面我们来看一个真正的装饰器的实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def login(fun):
    def real_login():
        print(&#39;please input your password&#39;)
        return fun()
    return real_login
@login
def open():
    print(&#39;hello world&#39;)
open()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@login 相当于 open=login (open)   也就是将 open 函数偷梁换柱了一番。&lt;/p&gt;
&lt;p&gt;当我们运行 open () 时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open=login(open)　　#login(open)中的参数及局部变量：fun=open(原)　　#open=login(open)的返回值！
　　#即：open=real_login　　
open()=real_login()
　　#因为real_login定义在login之中，所以继承其参数和局部变量
　　#所以整体来看open()==login(open)+real_login()+open()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现一个可以接受任意参数的装饰器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def outer(func):
    def inner(*args,**kwargs):
        print(&#39;start&#39;)
        r=func(*args,**kwargs)    # 这里func(*args,**kwargs)相当于f(a,b)
        print(&#39;end&#39;)
        return r
    return inner

@outer
def f(a,b):
    print(a+b)
@outer
def f2(a,b,c):
    print(a+b+c)

f(1,2)
f2(1,2,3)
#结果：
start
3
end
start
6
end&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/03/31/%E9%80%92%E5%BD%92_-_%E6%95%B0%E7%BB%84%E7%B4%AF%E5%8A%A0/</guid>
            <title>递归 - 数组累加</title>
            <link>http://example.com/2021/03/31/%E9%80%92%E5%BD%92_-_%E6%95%B0%E7%BB%84%E7%B4%AF%E5%8A%A0/</link>
            <pubDate>Wed, 31 Mar 2021 18:01:00 +0800</pubDate>
            <description><![CDATA[ &lt;pre&gt;&lt;code&gt;def sum(a):
    if a == []:
        return 0    #基线条件
    return a[0] + sum(a[1:])    #递归条件

print(sum(a))
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/03/28/%E8%BF%AD%E4%BB%A3_-_%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/</guid>
            <title>迭代 - 水仙花数</title>
            <link>http://example.com/2021/03/28/%E8%BF%AD%E4%BB%A3_-_%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/</link>
            <pubDate>Sun, 28 Mar 2021 15:13:27 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;偶然发现了一种用迭代算水仙花，太顶了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in range(100, 1000):
    sum = 0
    temp = i
    while temp:   #开始迭代
        sum = sum + (temp%10) ** 3
        temp //= 10
    if sum == i:
        print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如 153 这个数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先取出个位数 152 % 10 == 2 ，再对 temp 去除个位 (temp //= 10) , 这时 temp 等于 15&lt;/li&gt;
&lt;li&gt;while 为真，循环上一次操作，对 15 取各位 ，同理 temp 此时为 1&lt;/li&gt;
&lt;li&gt;对 1 求模 ，1 // 10 为 0，跳出循环，至此 1,5,3 全部取出&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/03/28/%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E7%9A%84%E9%98%B6%E6%A2%AF%E9%97%AE%E9%A2%98/</guid>
            <title>爱因斯坦的阶梯问题</title>
            <link>http://example.com/2021/03/28/%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E7%9A%84%E9%98%B6%E6%A2%AF%E9%97%AE%E9%A2%98/</link>
            <pubDate>Sun, 28 Mar 2021 14:10:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;爱因斯坦的阶梯难题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#爱因斯坦的阶梯难题&#34;&gt;#&lt;/a&gt; 爱因斯坦的阶梯难题&lt;/h2&gt;
&lt;p&gt;爱因斯坦曾出过这样一道有趣的数学题：有一个长阶梯，若每步上 2 阶，最后剩 1 阶；若每步上 3 阶，最后剩 2 阶；若每步上 5 阶，最后剩 4 阶；若每步上 6 阶，最后剩 5 阶；只有每步上 7 阶，最后刚好一阶也不剩。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 0
while True:
    if i % 2 == 1 and i % 3 == 2 and i % 5 == 4 and i % 6 == 5 and i % 7 == 0:
        print(i)
        break
    else:
        i += 1&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
            <title>二分查找</title>
            <link>http://example.com/2021/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
            <pubDate>Sun, 21 Mar 2021 15:53:00 +0800</pubDate>
            <description><![CDATA[ &lt;pre&gt;&lt;code&gt;def binary(list, item):         #二分查找
    low = 0
    high = len(list)
    while low &amp;lt;= high:
        mid = int((low + high) / 2)
        if list[mid] == item:
            return mid
        if list[mid] &amp;lt;= item:
            low = mid + 1         #中值已经比较过，直接从下一值开始，提高效率
        if list[mid] &amp;gt;= item:
            high = mid - 1         #同理
 
 
list1 = [1, 3, 5, 7, 9, 11, 15, 16]         #二分查找测试
print(binary(list1, 9))&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/03/17/Python%E5%A3%B0%E6%98%8E%E7%A9%BA%E6%95%B0%E7%BB%84/</guid>
            <title>Python声明空数组</title>
            <link>http://example.com/2021/03/17/Python%E5%A3%B0%E6%98%8E%E7%A9%BA%E6%95%B0%E7%BB%84/</link>
            <pubDate>Wed, 17 Mar 2021 18:36:00 +0800</pubDate>
            <description><![CDATA[ &lt;pre&gt;&lt;code&gt;w, h = 8, 5;
Array = [ [0 for x in range( w )] for y in range( h ) ]  &lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
