<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>mioe • Posts by &#34;算法&#34; category</title>
    <link href="http://example.com" />
    <updated>2023-02-04T10:51:00.000Z</updated>
    <category term="BFS" />
    <category term="算法" />
    <category term="unity" />
    <category term="Resilio Sync" />
    <category term="WolfraAlpha" />
    <category term="github" />
    <category term="数论" />
    <category term="linux" />
    <category term="Open-cv" />
    <category term="模板" />
    <category term="碧蓝航线" />
    <category term="Python" />
    <category term="局域网" />
    <category term="阅读" />
    <category term="相册" />
    <category term="算法模板" />
    <entry>
        <id>http://example.com/2023/02/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</id>
        <title>最短路问题</title>
        <link rel="alternate" href="http://example.com/2023/02/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;h1 id=&#34;单源最短路&#34;&gt;&lt;a href=&#34;#单源最短路&#34; class=&#34;headerlink&#34; title=&#34;单源最短路&#34;&gt;&lt;/a&gt;单源最短路&lt;/h1&gt;&lt;h2 id=&#34;dijkstra-稠密图&#34;&gt;&lt;a href=&#34;#dijkstra-稠密图&#34; class=&#34;headerlink&#34; title=&#34;dijkstra 稠密图&#34;&gt;&lt;/a&gt;dijkstra 稠密图&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1e4;

int n, m, s;
int g[N][N];
int dist[N];
bool st[N];

void dijkstra() &amp;#123;
    memset(dist, 0x3f, sizeof dist);

    dist[s] = 0;

    for (int i = 0; i &amp;lt; n; i++) &amp;#123;
        int t = -1;
        for (int j = 1; j &amp;lt;= n; j++)
            if (!st[j] &amp;amp;&amp;amp; (t == -1 || dist[t] &amp;gt; dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j &amp;lt;= n; j++) &amp;#123;
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        &amp;#125;
    &amp;#125;

    //	if(dist[n] == 0x3f3f3f3f) return -1;
    //	else return n;
&amp;#125;

int main() &amp;#123;
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);

    memset(g, 0x3f, sizeof g);

    int a, b, c;
    while (m--) &amp;#123;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        g[a][b] = min(g[a][b], c);
    &amp;#125;

    //	int t = dijkstra();
    //	printf(&amp;quot;%d&amp;quot;, t);

    dijkstra();

    for (int i = 1; i &amp;lt;= n; i++) printf(&amp;quot;%d &amp;quot;, dist[i]);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;堆优化dijkstra&#34;&gt;&lt;a href=&#34;#堆优化dijkstra&#34; class=&#34;headerlink&#34; title=&#34;堆优化dijkstra&#34;&gt;&lt;/a&gt;堆优化dijkstra&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 2e6 + 5;
typedef pair&amp;lt;int, int&amp;gt; PII;

int n, m, s;
int h[N], ne[N], e[N], w[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c) &amp;#123;
    w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&amp;#125;

void dijkstra() &amp;#123;
    memset(dist, 127, sizeof dist);
    dist[s] = 0;

    priority_queue&amp;lt;PII, vector&amp;lt;PII&amp;gt;, greater&amp;lt;PII&amp;gt;&amp;gt; heap;
    heap.push(&amp;#123;0, s&amp;#125;);

    while (heap.size()) &amp;#123;
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i]) &amp;#123;
            int j = e[i];
            if (dist[j] &amp;gt; distance + w[i]) &amp;#123;
                dist[j] = distance + w[i];
                heap.push(&amp;#123;dist[j], j&amp;#125;);
            &amp;#125;
        &amp;#125;
    &amp;#125;

    //	if(dist[n] == 0x3f3f3f3f) return -1;
    //	else return n;
&amp;#125;

int main() &amp;#123;
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);

    memset(h, -1, sizeof h);
    int a, b, c;
    while (m--) &amp;#123;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        add(a, b, c);
    &amp;#125;
    //	int t = dijkstra();
    //	printf(&amp;quot;%d&amp;quot;, t);

    dijkstra();
    for (int i = 1; i &amp;lt;= n; i++) printf(&amp;quot;%d &amp;quot;, dist[i]);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Bellman-Ford&#34;&gt;&lt;a href=&#34;#Bellman-Ford&#34; class=&#34;headerlink&#34; title=&#34;Bellman-Ford&#34;&gt;&lt;/a&gt;Bellman-Ford&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 505, M = 10010;

int n, m, k;
int dist[N], backup[N], st[N];

struct Node &amp;#123;
    int a, b, w;
&amp;#125; edges[M];

int b_f() &amp;#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i &amp;lt; k; i++) &amp;#123;
        memcpy(backup, dist, sizeof dist);
        for (int j = 0; j &amp;lt; m; j++) &amp;#123;
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            dist[b] = min(dist[b], backup[a] + w);
        &amp;#125;
    &amp;#125;
    if (dist[n] &amp;gt;= 0x3f3f3f3f / 2) return -1;
    else return dist[n];
&amp;#125;

int main() &amp;#123;
    scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;k);

    for (int i = 0; i &amp;lt; m; i++) &amp;#123;
        int x, y, z;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;x, &amp;amp;y, &amp;amp;z);
        edges[i] = &amp;#123;x, y, z&amp;#125;;
    &amp;#125;

    int t = b_f();
    if (t == -1 &amp;amp;&amp;amp; dist[n] != -1) printf(&amp;quot;impossible&amp;quot;);
    else printf(&amp;quot;%d&amp;quot;, t);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;SPFA&#34;&gt;&lt;a href=&#34;#SPFA&#34; class=&#34;headerlink&#34; title=&#34;SPFA&#34;&gt;&lt;/a&gt;SPFA&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&#34;https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2023/02/568055134.png&#34; alt=&#34;《信息学奥赛一本通》 , usaco training 3.2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;输入样例&#34;&gt;&lt;a href=&#34;#输入样例&#34; class=&#34;headerlink&#34; title=&#34;输入样例&#34;&gt;&lt;/a&gt;输入样例&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出样例&#34;&gt;&lt;a href=&#34;#输出样例&#34; class=&#34;headerlink&#34; title=&#34;输出样例&#34;&gt;&lt;/a&gt;输出样例&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;8
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;AC&#34;&gt;&lt;a href=&#34;#AC&#34; class=&#34;headerlink&#34; title=&#34;AC&#34;&gt;&lt;/a&gt;AC&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 510, P = 805, C = 1455 * 2;    // 无向图 边 * 2;

bool st[P];
int cow[N];
int dist[P];
int ne[C], e[C], h[C], w[C], idx;

void add(int a, int b, int v) &amp;#123;
    e[idx] = b, w[idx] = v, ne[idx] = h[a], h[a] = idx++;
&amp;#125;

void spfa(int cw) &amp;#123;
    memset(dist, 0x3f, sizeof dist);
    dist[cw] = 0;

    queue&amp;lt;int&amp;gt; q;
    q.push(cw);
    st[cw] = true;

    while (!q.empty()) &amp;#123;
        int t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]) &amp;#123;
            int j = e[i];
            if (dist[j] &amp;gt; dist[t] + w[i]) &amp;#123;
                dist[j] = dist[t] + w[i];
                if (!st[j]) &amp;#123;
                    q.push(j);
                    st[j] = true;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;

int main() &amp;#123;
    int n, p, c;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; p &amp;gt;&amp;gt; c;

    for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; cow[i];

    memset(h, -1, sizeof h);
    for (int i = 0; i &amp;lt; c; i++) &amp;#123;
        int a, b, v;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; v;
        add(a, b, v);
        add(b, a, v);
    &amp;#125;

    int res = 0x3f3f3f3f, t = 0;
    for (int i = 1; i &amp;lt;= p; i++) &amp;#123;
        t = 0;
        spfa(i);
        for (int j = 0; j &amp;lt; n; j++) &amp;#123;
            if (t &amp;gt;= 0x3f3f3f3f) continue;
            t += dist[cow[j]];
        &amp;#125;
        res = min(res, t);
    &amp;#125;

    cout &amp;lt;&amp;lt; res;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;负环判断&#34;&gt;&lt;a href=&#34;#负环判断&#34; class=&#34;headerlink&#34; title=&#34;负环判断&#34;&gt;&lt;/a&gt;负环判断&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;cnt[x] = cnt[i] + 1;
if(cnt[x] &amp;gt;= n) return true;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;多源最短路&#34;&gt;&lt;a href=&#34;#多源最短路&#34; class=&#34;headerlink&#34; title=&#34;多源最短路&#34;&gt;&lt;/a&gt;多源最短路&lt;/h1&gt;&lt;h2 id=&#34;Floyd&#34;&gt;&lt;a href=&#34;#Floyd&#34; class=&#34;headerlink&#34; title=&#34;Floyd&#34;&gt;&lt;/a&gt;Floyd&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 205, inf = 0x3f3f3f3f;

int g[N][N], path[N][N];
int n, m, q;
int tx, ty;

void writePath(int x, int y)&amp;#123;
    if (path[x][y] != 0) &amp;#123;
        writePath(x, path[x][y]);
        cout &amp;lt;&amp;lt; path[x][y] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    &amp;#125;
    if (y == ty) cout &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
&amp;#125;

void floyd() &amp;#123;
    for (int k = 1; k &amp;lt;= n; k++)
        for (int i = 1; i &amp;lt;= n; i++)
            for (int j = 1; j &amp;lt;= n; j++)
                if (g[i][k] + g[k][j] &amp;lt; g[i][j]) &amp;#123;
                    g[i][j] = g[i][k] + g[k][j];
                    path[i][j] = path[k][j];
                &amp;#125;
&amp;#125; 

int main() &amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

    for (int i = 1; i &amp;lt;= n; i++) &amp;#123;
        for (int j = 1; j &amp;lt;= n; j++) &amp;#123;
            if (i == j) g[i][j] = 0;
            else g[i][j] = inf;
        &amp;#125;
    &amp;#125;

    for (int i = 0; i &amp;lt; m; i++) &amp;#123;
        int x, y, z;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;
        path[x][y] = x;
        g[x][y] = min(g[x][y], z);
    &amp;#125;

    floyd();

    cin &amp;gt;&amp;gt; tx &amp;gt;&amp;gt; ty;
    cout &amp;lt;&amp;lt; g[tx][ty] &amp;lt;&amp;lt; endl;
    writePath(tx, ty);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-04T10:51:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/03/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89/</id>
        <title>树的深度优先遍历（邻接表）</title>
        <link rel="alternate" href="http://example.com/2023/02/03/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89/"/>
        <content type="html">&lt;h4 id=&#34;DFS&#34;&gt;&lt;a href=&#34;#DFS&#34; class=&#34;headerlink&#34; title=&#34;DFS&#34;&gt;&lt;/a&gt;DFS&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

int idx, n;
int h[N], e[N], ne[N];
bool st[N];

void ins(int a, int b)&amp;#123;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
&amp;#125;

void dfs(int u)&amp;#123;
    st[u] = true;
    cout &amp;lt;&amp;lt; u;
    for(int i = h[u]; i != -1; i = ne[i])&amp;#123;
        int j = e[i];
        if(!st[j]) dfs(j);
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    memset(h, -1, sizeof h);

    cin &amp;gt;&amp;gt; n;
    int a, b;

    while(n--)&amp;#123;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        ins(a, b);
    &amp;#125;

    dfs(1);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-03T10:24:20.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</id>
        <title>字符串哈希</title>
        <link rel="alternate" href="http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1010, P = 131;

unsigned long long h[N], p[N];
int n, m;
char str[N];

unsigned long long gethash(int l, int r)&amp;#123;
    return h[r] - h[l - 1] * p[r - l + 1];
&amp;#125;

int main()&amp;#123;
    scanf(&amp;quot;%d %d %s&amp;quot;, &amp;amp;n, &amp;amp;m, str + 1);

    p[0] = 1;
    for(int i = 1; i &amp;lt;= n; i++)&amp;#123;
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    &amp;#125;

    int l1, r1, l2, r2;
    while(m--)&amp;#123;
        scanf(&amp;quot;%d %d %d %d&amp;quot;, &amp;amp;l1, &amp;amp;r1, &amp;amp;l2, &amp;amp;r2);
        if(gethash(l1, r1) == gethash(l2, r2)) printf(&amp;quot;Yes\n&amp;quot;);
        else printf(&amp;quot;No\n&amp;quot;);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-02T08:36:57.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/</id>
        <title>小根堆</title>
        <link rel="alternate" href="http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1e6+10;

int hp[N], idx;
int n;

void down(int k)&amp;#123;
    int t = k;
    if(hp[k &amp;lt;&amp;lt; 1] &amp;lt; hp[t] &amp;amp;&amp;amp; (k &amp;lt;&amp;lt; 1) &amp;lt;= idx) t = k &amp;lt;&amp;lt; 1;
    if(hp[k &amp;lt;&amp;lt; 1 | 1] &amp;lt; hp[t] &amp;amp;&amp;amp; (k &amp;lt;&amp;lt; 1 | 1) &amp;lt;= idx) t = k &amp;lt;&amp;lt; 1 | 1;
    if(t != k)&amp;#123;
        swap(hp[k], hp[t]);
        down(t);
    &amp;#125;
&amp;#125;

void up(int k)&amp;#123;
    while(k &amp;gt;&amp;gt; 1 &amp;amp;&amp;amp; hp[k &amp;gt;&amp;gt; 1] &amp;gt; hp[k])&amp;#123;
        swap(hp[k &amp;gt;&amp;gt; 1], hp[k]);
        k &amp;gt;&amp;gt;= 1;
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);

    int x, y;
    while(n--)&amp;#123;
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;x);
        if(x == 1)&amp;#123;
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;y);
            hp[++idx] = y;
            up(idx);
        &amp;#125;else if(x == 2) printf(&amp;quot;%d\n&amp;quot;, hp[1]);
        else hp[1] = hp[idx], idx--, down(1);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-01T10:38:45.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/31/%E9%9B%86%E5%90%88%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
        <title>集合与并查集</title>
        <link rel="alternate" href="http://example.com/2023/01/31/%E9%9B%86%E5%90%88%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
        <content type="html">&lt;h4 id=&#34;集合&#34;&gt;&lt;a href=&#34;#集合&#34; class=&#34;headerlink&#34; title=&#34;集合&#34;&gt;&lt;/a&gt;集合&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100010;

int son[N][26], cnt[N], idx;
int n;

void insert(string str)&amp;#123;
    int p = 0;
    for(int i = 0; str[i]; i++)&amp;#123;
        int u = str[i] - &amp;#39;a&amp;#39;;
        if(!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    &amp;#125;
    cnt[p]++;
&amp;#125;

int query(string str)&amp;#123;
    int p = 0;
    for(int i = 0; str[i]; i++)&amp;#123;
        int u = str[i] - &amp;#39;a&amp;#39;;
        if(!son[p][u]) return 0;
        p = son[p][u];
    &amp;#125;

    return cnt[p];
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    while(n--)&amp;#123;
        char op;
        string str;
        cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; str;
        if(op == &amp;#39;I&amp;#39;) insert(str);
        else printf(&amp;quot;%d\n&amp;quot;, query(str)); 
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;并查集&#34;&gt;&lt;a href=&#34;#并查集&#34; class=&#34;headerlink&#34; title=&#34;并查集&#34;&gt;&lt;/a&gt;并查集&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 10010;

int p[N], n, m;

int find(int x)&amp;#123;
    if(p[x] != x) p[x] = find(p[x]);
    return x;
&amp;#125;

int main()&amp;#123;
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for(int i = 1; i &amp;lt;= n; i++) p[i] = i;

    while(m--)&amp;#123;
        int z, x, y;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;z, &amp;amp;x, &amp;amp;y);
        if(z == 1) p[find(x)] = find(y);
        else&amp;#123;
            if(find(x) == find(y)) printf(&amp;quot;Y\n&amp;quot;);
            else printf(&amp;quot;N\n&amp;quot;);
        &amp;#125;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-01-31T10:11:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/30/KMP/</id>
        <title>KMP</title>
        <link rel="alternate" href="http://example.com/2023/01/30/KMP/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100, M = 1000;

int n, m;
char p[N], s[M];
int ne[N];

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; p + 1 &amp;gt;&amp;gt; m &amp;gt;&amp;gt; s + 1;

    for(int i = 2, j = 0; i &amp;lt;= n; i++)&amp;#123;
        while(j &amp;amp;&amp;amp; p[i] != p[j + 1]) j = ne[j];
        if(p[i] == p[j + 1]) j++;
        ne[i] = j;
    &amp;#125;

    for(int i = 1, j = 0; i &amp;lt;= m; i++)&amp;#123;
        while(j &amp;amp;&amp;amp; s[i] != p[j + 1]) j = ne[j];
        if(s[i] == p[j + 1]) j++;
        if(j == n)&amp;#123;
            printf(&amp;quot;%d&amp;quot;, i - n);
            break;
        &amp;#125;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-30T10:25:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/30/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89/</id>
        <title>单调栈、滑动窗口（单调队列）</title>
        <link rel="alternate" href="http://example.com/2023/01/30/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89/"/>
        <content type="html">&lt;h4 id=&#34;单调栈&#34;&gt;&lt;a href=&#34;#单调栈&#34; class=&#34;headerlink&#34; title=&#34;单调栈&#34;&gt;&lt;/a&gt;单调栈&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

int stk[N], arr[N];
int n, t;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        cin &amp;gt;&amp;gt; arr[i];
        while(t &amp;amp;&amp;amp; arr[i] &amp;lt;= stk[t]) t--;
    
        if(t) cout &amp;lt;&amp;lt; stk[t] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    
        stk[++t] = arr[i];
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;单调队列&#34;&gt;&lt;a href=&#34;#单调队列&#34; class=&#34;headerlink&#34; title=&#34;单调队列&#34;&gt;&lt;/a&gt;单调队列&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

int arr[N], q[N];
int n, k;

int main()&amp;#123;
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;k);

    for(int i = 0; i &amp;lt; n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;arr[i]);

    int h = 0, r = -1;
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        if(h &amp;lt;= r &amp;amp;&amp;amp; i - k + 1 &amp;gt; q[h]) h++;

        while(h &amp;lt;= r &amp;amp;&amp;amp; arr[q[r]] &amp;gt;= arr[i]) r--;

        q[++r] = i;

        if(i &amp;gt;= k - 1) printf(&amp;quot;%d &amp;quot;, arr[q[h]]);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-30T09:07:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/20/%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
        <title>双指针数组去重</title>
        <link rel="alternate" href="http://example.com/2023/01/20/%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

int n; 
int arr[N];

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    for(int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; arr[i];

    int j = 0;	// 非重复个数
    for(int i = 0; i &amp;lt; n; i++)
        if(!i || arr[i] != arr[i - 1])
            arr[j++] = arr[i];

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-20T12:23:01.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/20/%E7%A6%BB%E6%95%A3%E5%8C%96%E5%8C%BA%E9%97%B4%E5%92%8C/</id>
        <title>离散化区间和</title>
        <link rel="alternate" href="http://example.com/2023/01/20/%E7%A6%BB%E6%95%A3%E5%8C%96%E5%8C%BA%E9%97%B4%E5%92%8C/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;
typedef pair&amp;lt;int, int&amp;gt; PII;

int n, m;
int arr[N], sum[N];
vector&amp;lt;int&amp;gt; alls;
vector&amp;lt;PII&amp;gt; add, query;

// 查找x在alls数组中的下标
int find(int x)&amp;#123;
    int l = 0, r = alls.size() - 1, mid;
    while(l &amp;lt; r)&amp;#123;
        mid = l + r &amp;gt;&amp;gt; 1;
        if(alls[mid] &amp;gt;= x) r = mid;
        else l = mid + 1;
    &amp;#125;
    return l + 1;
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

    int x, c;
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; c;
        add.push_back(&amp;#123;x, c&amp;#125;);
        alls.push_back(x);
    &amp;#125;

    int l, r;
    for(int i = 0; i &amp;lt; m; i++)&amp;#123;
        cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        query.push_back(&amp;#123;l, r&amp;#125;);
        alls.push_back(l);
        alls.push_back(r);
    &amp;#125;

    // 排序去重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());

    for(auto item : add)
        arr[find(item.first)] += item.second;

    // 处理前缀和
    for(int i = 1; i &amp;lt;= alls.size(); i++)
        sum[i] = sum[i - 1] + arr[i];

    for(auto item : query)
        printf(&amp;quot;%d\n&amp;quot;, sum[find(item.second)] - sum[find(item.first) - 1]);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法模板" />
        <updated>2023-01-20T11:29:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/10/gcd%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%A8%A1%E6%9D%BF/</id>
        <title>gcd与欧拉质数筛模板</title>
        <link rel="alternate" href="http://example.com/2023/01/10/gcd%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%A8%A1%E6%9D%BF/"/>
        <content type="html">&lt;h2 id=&#34;欧几里得辗转相除法&#34;&gt;&lt;a href=&#34;#欧几里得辗转相除法&#34; class=&#34;headerlink&#34; title=&#34;欧几里得辗转相除法&#34;&gt;&lt;/a&gt;欧几里得辗转相除法&lt;/h2&gt;&lt;p&gt;$gcd(a, b)&amp;#x3D;gcd(b,a\ mod\ b)&amp;#x3D;···&amp;#x3D;gcd(n,0)$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;int gcd(int a, int b)&amp;#123;
    return b ? gcd(b, a % b) : a;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;欧拉质数筛&#34;&gt;&lt;a href=&#34;#欧拉质数筛&#34; class=&#34;headerlink&#34; title=&#34;欧拉质数筛&#34;&gt;&lt;/a&gt;欧拉质数筛&lt;/h2&gt;&lt;h4 id=&#34;时间复杂度-O-n&#34;&gt;&lt;a href=&#34;#时间复杂度-O-n&#34; class=&#34;headerlink&#34; title=&#34;时间复杂度$O(n)$&#34;&gt;&lt;/a&gt;时间复杂度$O(n)$&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;const int N = 1e8 + 10;
int p[N], cnt;
bool st[N];
void get_primes(int n)&amp;#123;
    for(int i = 2; i &amp;lt;= n; i++)&amp;#123;
        if(!st[i]) p[cnt++] = i;
        for(int j = 0; i * p[i] &amp;lt;= n; j++)&amp;#123;
            st[p[j] * i] = true;
            if(i % p[j] == 0) break;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="数论" />
        <updated>2023-01-10T08:04:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/08/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</id>
        <title>树的直径</title>
        <link rel="alternate" href="http://example.com/2023/01/08/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100010;

struct Node&amp;#123;
    int id, w;
&amp;#125;;

vector&amp;lt;Node&amp;gt; m[N];
int dist[N];
int n;

void dfs(int idx, int root, int dst)&amp;#123;
    dist[idx] = dst;
    for(auto node : m[idx])
        if(node.id != root)	dfs(node.id, idx, dst + node.w);
&amp;#125;

int main()&amp;#123;
    int p, q, d, t;
    cin &amp;gt;&amp;gt; n;
    t = n - 1;
    while(t--)&amp;#123;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;p, &amp;amp;q, &amp;amp;d);
        m[p].push_back(&amp;#123;q, d&amp;#125;);
        m[q].push_back(&amp;#123;p, d&amp;#125;);
    &amp;#125;
    dfs(1, -1, 0);
    int idx = 1;
    for(int i = 1; i &amp;lt;= n; i++)
        if(dist[i] &amp;gt; dist[idx]) idx = i;
    dfs(idx, -1, 0);
    for(int i = 1; i &amp;lt;= n; i++)
        if(dist[i] &amp;gt; dist[idx]) idx = i;
    idx = dist[idx];
    printf(&amp;quot;%lld&amp;quot;, 10 * idx + (1ll + idx) * idx / 2);	

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2023-01-08T08:58:43.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/05/BFS%E6%A8%A1%E6%9D%BF/</id>
        <title>BFS模板</title>
        <link rel="alternate" href="http://example.com/2023/01/05/BFS%E6%A8%A1%E6%9D%BF/"/>
        <content type="html">&lt;h4 id=&#34;题目&#34;&gt;&lt;a href=&#34;#题目&#34; class=&#34;headerlink&#34; title=&#34;题目&#34;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行，&lt;/p&gt;
&lt;p&gt;对于每一组数据，输出吃到奶酪的最少单位时间。&lt;/p&gt;
&lt;p&gt;若无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。&lt;/p&gt;
&lt;p&gt;在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。&lt;/p&gt;
&lt;h4 id=&#34;模板&#34;&gt;&lt;a href=&#34;#模板&#34; class=&#34;headerlink&#34; title=&#34;模板&#34;&gt;&lt;/a&gt;模板&lt;/h4&gt;&lt;h6 id=&#34;二维&#34;&gt;&lt;a href=&#34;#二维&#34; class=&#34;headerlink&#34; title=&#34;二维&#34;&gt;&lt;/a&gt;二维&lt;/h6&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 210;

// 方向偏移量
int dx[4] = &amp;#123;-1, 0, 1, 0&amp;#125;;
int dy[4] = &amp;#123;0, 1, 0, -1&amp;#125;;
// 距离
int dist[N][N];
int n, m;
pair&amp;lt;int, int&amp;gt; start;
pair&amp;lt;int, int&amp;gt; ed;
// 迷宫
char g[N][N];

int bfs(pair&amp;lt;int, int&amp;gt; s, pair&amp;lt;int, int&amp;gt; e)&amp;#123;
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
    memset(dist, -1, sizeof dist);

    dist[s.first][s.second] = 0;						// 起点
    q.push(s);

    while(!q.empty())&amp;#123;
        pair&amp;lt;int, int&amp;gt; t = q.front();
        q.pop();

        if(t == e) return dist[t.first][t.second];			// 判断是否终点

        for(int i = 0; i &amp;lt; 4; i++)&amp;#123;
            int x = t.first + dx[i];
            int y = t.second + dy[i];
            if(x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= n || y &amp;gt;= m) continue;	// 越界
            if(g[x][y] == &amp;#39;#&amp;#39;) continue;				// 碰墙
            if(dist[x][y] != -1) continue;				// 已遍历

            dist[x][y] = dist[t.first][t.second] + 1;		// 距离加一
            q.push(&amp;#123;x, y&amp;#125;);
        &amp;#125;
    &amp;#125;

    return -1;
&amp;#125;

int main()&amp;#123;
    int t;
    cin &amp;gt;&amp;gt; t;
    while(t--)&amp;#123;
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;m);
        for(int i = 0; i &amp;lt; n; i++) scanf(&amp;quot;%s&amp;quot;, g[i]);
        for(int i = 0; i &amp;lt; n; i++)&amp;#123;
            for(int j = 0; j &amp;lt; m; j++)&amp;#123;
                if(g[i][j] == &amp;#39;S&amp;#39;) start = &amp;#123;i, j&amp;#125;;
                if(g[i][j] == &amp;#39;E&amp;#39;) ed = &amp;#123;i, j&amp;#125;;
            &amp;#125;
        &amp;#125;

        int d = bfs(start, ed);
        if(d == -1) printf(&amp;quot;oop!\n&amp;quot;);
        else printf(&amp;quot;%d\n&amp;quot;, d);
    &amp;#125;


    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;三维&#34;&gt;&lt;a href=&#34;#三维&#34; class=&#34;headerlink&#34; title=&#34;三维&#34;&gt;&lt;/a&gt;三维&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 101;

pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; start, ed, tmp;
char g[N][N][N];
int st[N][N][N];
int dy[4] = &amp;#123;-1, 0, 1, 0&amp;#125;;
int dz[4] = &amp;#123;0, -1, 0, 1&amp;#125;;
int l, r, c;

int bfs(pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; s, pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; e)&amp;#123;
    memset(st, -1, sizeof st);
    queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; q;
    st[s.first][s.second.first][s.second.second] = 0;
    q.push(s);

    while(!q.empty())&amp;#123;
        tmp = q.front();
        q.pop();
        if(tmp == e) return st[tmp.first][tmp.second.first][tmp.second.second];
    
        int x = tmp.first, y, z;
    
        if(x + 1 &amp;lt; l &amp;amp;&amp;amp; st[x + 1][tmp.second.first][tmp.second.second] == -1 &amp;amp;&amp;amp; g[x + 1][tmp.second.first][tmp.second.second] != &amp;#39;#&amp;#39;)&amp;#123;
            st[x + 1][tmp.second.first][tmp.second.second] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x + 1, &amp;#123;tmp.second.first, tmp.second.second&amp;#125;&amp;#125;);
        &amp;#125;
        if(x - 1 &amp;gt;= 0 &amp;amp;&amp;amp; st[x - 1][tmp.second.first][tmp.second.second] == -1 &amp;amp;&amp;amp; g[x - 1][tmp.second.first][tmp.second.second] != &amp;#39;#&amp;#39;)&amp;#123;
            st[x - 1][tmp.second.first][tmp.second.second] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x - 1, &amp;#123;tmp.second.first, tmp.second.second&amp;#125;&amp;#125;);
        &amp;#125;
    
        for(int i = 0; i &amp;lt; 4; i++)&amp;#123;
            y = tmp.second.first + dy[i];
            z = tmp.second.second + dz[i];
            if(st[x][y][z] != -1) continue;
            if(y &amp;lt; 0 || z &amp;lt; 0 || y &amp;gt;= r || z &amp;gt;= c) continue;
            if(g[x][y][z] == &amp;#39;#&amp;#39;) continue;
        
            st[x][y][z] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x, &amp;#123;y, z&amp;#125;&amp;#125;);
        &amp;#125;
    
    
    &amp;#125;

    return -1;
&amp;#125;

int main()&amp;#123;
    while(1)&amp;#123;
        cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;
        if(l == 0) break;
        for(int i = 0; i &amp;lt; l; i++)
            for(int j = 0; j &amp;lt; r; j++) 
                scanf(&amp;quot;%s&amp;quot;, g[i][j]);
    
        for(int i = 0; i &amp;lt; l; i++)
            for(int j = 0; j &amp;lt; r; j++)
                for(int z = 0; z &amp;lt; c; z++)
                    if(g[i][j][z] == &amp;#39;S&amp;#39;) start = &amp;#123;i, &amp;#123;j, z&amp;#125;&amp;#125;;
                    else if(g[i][j][z] == &amp;#39;E&amp;#39;) ed = &amp;#123;i, &amp;#123;j, z&amp;#125;&amp;#125;;
    
        int step = bfs(start, ed);
        if(step == -1) printf(&amp;quot;Trapped!\n&amp;quot;);
        else printf(&amp;quot;Escaped in %d minute(s).\n&amp;quot;, step);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="BFS" />
        <updated>2023-01-05T09:40:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91___%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A8%A1%E6%9D%BF/</id>
        <title>线段树 / 树状数组 模板</title>
        <link rel="alternate" href="http://example.com/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91___%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A8%A1%E6%9D%BF/"/>
        <content type="html">&lt;h4 id=&#34;题目&#34;&gt;&lt;a href=&#34;#题目&#34; class=&#34;headerlink&#34; title=&#34;题目&#34;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给定 &lt;strong&gt;n&lt;/strong&gt; 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 &lt;strong&gt;[&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt;]&lt;/strong&gt; 的连续和。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;&lt;a href=&#34;#输入格式&#34; class=&#34;headerlink&#34; title=&#34;输入格式&#34;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行包含两个整数 &lt;strong&gt;n&lt;/strong&gt; 和 &lt;strong&gt;m&lt;/strong&gt;，分别表示数的个数和操作次数。&lt;/p&gt;
&lt;p&gt;第二行包含 &lt;strong&gt;n&lt;/strong&gt; 个整数，表示完整数列。&lt;/p&gt;
&lt;p&gt;接下来 &lt;strong&gt;m&lt;/strong&gt; 行，每行包含三个整数 &lt;strong&gt;k&lt;/strong&gt;,&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt; （&lt;strong&gt;k&amp;#x3D;0&lt;/strong&gt;，表示求子数列 &lt;strong&gt;[a,b]&lt;/strong&gt; 的和；&lt;strong&gt;k&amp;#x3D;1&lt;/strong&gt;，表示第 &lt;strong&gt;a&lt;/strong&gt; 个数加 &lt;strong&gt;b&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;数列从 &lt;strong&gt;1&lt;/strong&gt; 开始计数。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;&lt;a href=&#34;#输出格式&#34; class=&#34;headerlink&#34; title=&#34;输出格式&#34;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;输出若干行数字，表示 &lt;strong&gt;k&lt;/strong&gt;&amp;#x3D;&lt;strong&gt;0&lt;/strong&gt; 时，对应的子数列 &lt;strong&gt;[&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt;]&lt;/strong&gt; 的连续和。&lt;/p&gt;
&lt;h4 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;≤&lt;strong&gt;n&lt;/strong&gt;≤&lt;strong&gt;100000&lt;/strong&gt;,&lt;br&gt;&lt;strong&gt;1&lt;/strong&gt;≤&lt;strong&gt;m&lt;/strong&gt;≤&lt;strong&gt;100000，&lt;br&gt;1&lt;/strong&gt;≤&lt;strong&gt;a&lt;/strong&gt;≤&lt;strong&gt;b&lt;/strong&gt;≤&lt;strong&gt;n&lt;/strong&gt;,&lt;br&gt;数据保证在任何时候，数列中所有元素之和均在 int 范围内。&lt;/p&gt;
&lt;h4 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;10 5
1 2 3 4 5 6 7 8 9 10
1 1 5
0 1 3
0 4 8
1 7 5
0 4 8
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;11
30
35
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;树状数组模板&#34;&gt;&lt;a href=&#34;#树状数组模板&#34; class=&#34;headerlink&#34; title=&#34;树状数组模板&#34;&gt;&lt;/a&gt;树状数组模板&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100010;

int n, m;
int arr[N], tr[N];

int lowbit(int i)&amp;#123;
    return i &amp;amp; -i;
&amp;#125;

void add(int index, int x)&amp;#123;
    for(int i = index; i &amp;lt;= n; i += lowbit(i))
        tr[i] += x;
    return;
&amp;#125;

void change(int index, int x)&amp;#123;
    int c = x - arr[index];
    for(int i = index; i &amp;lt;= n; i += lowbit(i))
        tr[i] += c;
    return;
&amp;#125;

int query(int index)&amp;#123;
    int res = 0;
    for(int i = index; i; i -= lowbit(i))
        res += tr[i];
    return res;
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 1; i &amp;lt;= n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;arr[i]);
    for(int i = 1; i &amp;lt;= n; i++) add(i, arr[i]);

    while(m--)&amp;#123;
        int tag, l, r;
        int res;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;tag, &amp;amp;l, &amp;amp;r);
        if(tag) add(l, r);
        else printf(&amp;quot;%d\n&amp;quot;, query(r) - query(l - 1));
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;线段树模板&#34;&gt;&lt;a href=&#34;#线段树模板&#34; class=&#34;headerlink&#34; title=&#34;线段树模板&#34;&gt;&lt;/a&gt;线段树模板&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100010;

int n, m;
int num[N];

struct node&amp;#123;
    int l, r;
    int sum;
&amp;#125;sgt[N * 4];		// 需要开N * 4

// 更新当前节点
void pushup(int root)&amp;#123;
    sgt[root].sum = sgt[root &amp;lt;&amp;lt; 1].sum + sgt[root &amp;lt;&amp;lt; 1 | 1].sum;
&amp;#125;

// 初始化线段树
void build(int root, int l, int r)&amp;#123;
    if(l == r) sgt[root].sum = num[l];
    else&amp;#123;
        sgt[root] = &amp;#123;l, r&amp;#125;;
        int mid = l + r &amp;gt;&amp;gt; 1;
        build(root &amp;lt;&amp;lt; 1, l, mid);
        build(root &amp;lt;&amp;lt; 1 | 1, mid + 1, r);
        pushup(root);
    &amp;#125;
    return;
&amp;#125;

int query(int root, int l, int r)&amp;#123;
    if(sgt[root].l &amp;gt;= l &amp;amp;&amp;amp; sgt[root].r &amp;lt;= r) return sgt[root].sum;
    int mid = sgt[root].l + sgt[root].r &amp;gt;&amp;gt; 1;
    int sum = 0;
    if(l &amp;lt;= mid) sum += query(root &amp;lt;&amp;lt; 1, l, r);
    if(r &amp;gt; mid) sum += query(root &amp;lt;&amp;lt; 1 | 1, l, r);
    return sum;
&amp;#125;

void modify(int root, int index, int c)&amp;#123;
    if(sgt[root].l == sgt[root].r) sgt[root].sum += c;
    else&amp;#123;
        int mid = sgt[root].l + sgt[root].r &amp;gt;&amp;gt; 1;
        if(index &amp;lt;= mid) modify(root &amp;lt;&amp;lt; 1, index, c);
        else modify(root &amp;lt;&amp;lt; 1 | 1, index, c);
        pushup(root);
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 1; i &amp;lt;= n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;num[i]);
    build(1, 1, n);
    int k, a, b;
    while(m--)&amp;#123;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;k, &amp;amp;a, &amp;amp;b);
        if(k) modify(1, a, b);
        else printf(&amp;quot;%d\n&amp;quot;, query(1, a, b));
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法模板" />
        <updated>2022-12-30T13:40:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/27/stringstream_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC_int_double/</id>
        <title>stringstream 字符串转 int/double</title>
        <link rel="alternate" href="http://example.com/2022/12/27/stringstream_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC_int_double/"/>
        <content type="html">&lt;p&gt;某涉密单位下发了某种票据，并要在年终全部收回。&lt;/p&gt;
&lt;p&gt;每张票据有唯一的ID号。&lt;/p&gt;
&lt;p&gt;全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。&lt;/p&gt;
&lt;p&gt;因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。&lt;/p&gt;
&lt;p&gt;你的任务是通过编程，找出断号的ID和重号的ID。&lt;/p&gt;
&lt;p&gt;假设断号不可能发生在最大和最小号。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;&lt;a href=&#34;#输入格式&#34; class=&#34;headerlink&#34; title=&#34;输入格式&#34;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行包含整数 &lt;strong&gt;N&lt;/strong&gt;，表示后面共有 &lt;strong&gt;N&lt;/strong&gt; 行数据。&lt;/p&gt;
&lt;p&gt;接下来 &lt;strong&gt;N&lt;/strong&gt; 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;&lt;a href=&#34;#输出格式&#34; class=&#34;headerlink&#34; title=&#34;输出格式&#34;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;要求程序输出1行，含两个整数 &lt;strong&gt;m&lt;/strong&gt;,&lt;strong&gt;n&lt;/strong&gt;用空格分隔。&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;m&lt;/strong&gt;表示断号ID，&lt;strong&gt;n&lt;/strong&gt;表示重号ID。&lt;/p&gt;
&lt;h4 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;≤&lt;strong&gt;N&lt;/strong&gt;≤&lt;strong&gt;100&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;2
5 6 8 11 9 
10 12 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;7 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;AC代码&#34;&gt;&lt;a href=&#34;#AC代码&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int a[10001];
int c, n;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    string line;
    getline(cin, line);	\\ cin 会读取换行符
    while(n--)&amp;#123;
        getline(cin, line);
        stringstream ssin(line);
        while(ssin &amp;gt;&amp;gt; a[c])&amp;#123;
            c++;
        &amp;#125;
    &amp;#125;
    sort(a, a + c);
    int r1, r2;
    for(int i = 1; i &amp;lt; c; i++)&amp;#123;
        if(a[i] == a[i - 1]) r1 = a[i];
        if(a[i] - 2 == a[i - 1]) r2 = a[i] - 1;
    &amp;#125;
    cout &amp;lt;&amp;lt; r2 &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; r1;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;stringstream技巧：&#34;&gt;&lt;a href=&#34;#stringstream技巧：&#34; class=&#34;headerlink&#34; title=&#34;stringstream技巧：&#34;&gt;&lt;/a&gt;stringstream技巧：&lt;/h4&gt;&lt;h5 id=&#34;转int-x2F-double&#34;&gt;&lt;a href=&#34;#转int-x2F-double&#34; class=&#34;headerlink&#34; title=&#34;转int&amp;#x2F;double&#34;&gt;&lt;/a&gt;转int&amp;#x2F;double&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;string result = &amp;quot;10000&amp;quot;;	// double 同理, result = &amp;quot;1.5&amp;quot;;
stringstream stream(result);	// 可以是字符串也可以是数字，总之后面直接输入到目标变量里面
int n = 0;
stream &amp;gt;&amp;gt; n;	//n 等于10000
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;转int-x2F-double数组&#34;&gt;&lt;a href=&#34;#转int-x2F-double数组&#34; class=&#34;headerlink&#34; title=&#34;转int&amp;#x2F;double数组&#34;&gt;&lt;/a&gt;转int&amp;#x2F;double数组&lt;/h5&gt;&lt;p&gt;&lt;code&gt;stringstream&lt;/code&gt;以空格作为分隔符&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;string str = &amp;quot;1 2 3 4 5&amp;quot;;	// double 同理
stringstream ssin(str);
int i = 0;
int a[10] = &amp;#123;0&amp;#125;;
while(ssin &amp;gt;&amp;gt; a[i]) i++;	// 此时a[0] = 1, a[1] = 2 ...
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-12-27T12:29:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/25/%E5%9C%A8%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E9%87%8C%E5%A4%84%E7%90%86%E6%B5%AE%E7%82%B9%E6%95%B0/</id>
        <title>在整数运算里处理浮点数</title>
        <link rel="alternate" href="http://example.com/2022/12/25/%E5%9C%A8%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E9%87%8C%E5%A4%84%E7%90%86%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
        <content type="html">&lt;p&gt;&lt;code&gt;n = m / 2&lt;/code&gt; 可以写成 &lt;code&gt;n * 2 = m&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同理：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n &amp;lt; m / 2&lt;/code&gt; -&amp;gt; &lt;code&gt;n * 2 &amp;lt; m&lt;/code&gt;&lt;/p&gt;
</content>
        <updated>2022-12-25T08:23:44.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/12/21/AcWing_95._%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/</id>
        <title>AcWing 95. 费解的开关</title>
        <link rel="alternate" href="http://example.com/2022/12/21/AcWing_95._%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/"/>
        <content type="html">&lt;p&gt;你玩过“拉灯”游戏吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;25&lt;/strong&gt; 盏灯排成一个 &lt;strong&gt;5&lt;/strong&gt;×&lt;strong&gt;5&lt;/strong&gt; 的方形。&lt;/p&gt;
&lt;p&gt;每一个灯都有一个开关，游戏者可以改变它的状态。&lt;/p&gt;
&lt;p&gt;每一步，游戏者可以改变某一个灯的状态。&lt;/p&gt;
&lt;p&gt;游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。&lt;/p&gt;
&lt;p&gt;我们用数字 &lt;strong&gt;1&lt;/strong&gt; 表示一盏开着的灯，用数字 &lt;strong&gt;0&lt;/strong&gt; 表示关着的灯。&lt;/p&gt;
&lt;p&gt;下面这种状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10111
01101
10111
10000
11011
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在改变了最左上角的灯的状态后将变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;01111
11101
10111
10000
11011
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再改变它正中间的灯后状态将变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;01111
11001
11001
10100
11011
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给定一些游戏的初始状态，编写程序判断游戏者是否可能在 &lt;strong&gt;6&lt;/strong&gt;6 步以内使所有的灯都变亮。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;&lt;a href=&#34;#输入格式&#34; class=&#34;headerlink&#34; title=&#34;输入格式&#34;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行输入正整数 &lt;strong&gt;n&lt;/strong&gt;，代表数据中共有 &lt;strong&gt;n&lt;/strong&gt; 个待解决的游戏初始状态。&lt;/p&gt;
&lt;p&gt;以下若干行数据分为 &lt;strong&gt;n&lt;/strong&gt; 组，每组数据有 &lt;strong&gt;5&lt;/strong&gt; 行，每行 &lt;strong&gt;5&lt;/strong&gt; 个字符。&lt;/p&gt;
&lt;p&gt;每组数据描述了一个游戏的初始状态。&lt;/p&gt;
&lt;p&gt;各组数据间用一个空行分隔。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;&lt;a href=&#34;#输出格式&#34; class=&#34;headerlink&#34; title=&#34;输出格式&#34;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;一共输出 &lt;strong&gt;n&lt;/strong&gt; 行数据，每行有一个小于等于 &lt;strong&gt;6&lt;/strong&gt; 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。&lt;/p&gt;
&lt;p&gt;对于某一个游戏初始状态，若 &lt;strong&gt;6&lt;/strong&gt; 步以内无法使所有灯变亮，则输出 &lt;strong&gt;−1&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;0&lt;/strong&gt;&amp;lt;&lt;strong&gt;n&lt;/strong&gt;≤&lt;strong&gt;500&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出样例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3
2
-1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int light[7][7], backup[7][7];

void turn(int x, int y)&amp;#123;
    backup[x][y] = !backup[x][y];
    backup[x - 1][y] = !backup[x - 1][y];
    backup[x][y - 1] = !backup[x ][y - 1];
    backup[x + 1][y] = !backup[x + 1][y];
    backup[x][y + 1] = !backup[x][y + 1];
&amp;#125;

int main()&amp;#123;
    int n;
    string str;
    str.resize(7);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    for(int i = 0; i &amp;lt; n; i++)&amp;#123;
        int res = 10;

        for(int x = 1; x &amp;lt;= 5; x++)&amp;#123;
            string str;
            scanf(&amp;quot;%s&amp;quot;, &amp;amp;str[0]);
            for(int y = 1; y &amp;lt;= 5; y++)
                light[x][y] = str[y - 1] - &amp;#39;0&amp;#39;;
        &amp;#125;
        // 枚举操作而非状态
        // 01001 表示操作第2和第5盏灯
        for(int k = 0; k &amp;lt; 32; k++)&amp;#123;
            memcpy(backup, light, sizeof light);
            int step = 0;
            for(int j = 1; j &amp;lt;= 5; j++)&amp;#123;
                if((k &amp;gt;&amp;gt; (j - 1)) &amp;amp; 1)&amp;#123;
                    turn(1, j);
                    step++;
                &amp;#125;
            &amp;#125;

            for(int j = 2; j &amp;lt;= 5; j++)&amp;#123;
                for(int l = 1; l &amp;lt;= 5; l++)&amp;#123;
                    if(backup[j - 1][l] == 0)&amp;#123;
                        turn(j, l);
                        step++;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
            bool dark = false;
            for(int j = 1; j &amp;lt;= 5; j++)&amp;#123;
                if(backup[5][j] != 1)&amp;#123;
                    dark = true;
                    break;
                &amp;#125;
            &amp;#125;
            if(!dark)&amp;#123;
                res = min(res, step);
            &amp;#125;

        &amp;#125;
        if(res == 10 || res &amp;gt; 6) res = -1;

        cout &amp;lt;&amp;lt; res;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-12-21T11:02:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/11/10/DFS%E5%88%A4%E6%96%AD%E8%BF%B7%E5%AE%AB%E6%97%A0%E8%A7%A3/</id>
        <title>DFS判断迷宫无解</title>
        <link rel="alternate" href="http://example.com/2022/11/10/DFS%E5%88%A4%E6%96%AD%E8%BF%B7%E5%AE%AB%E6%97%A0%E8%A7%A3/"/>
        <content type="html">&lt;p&gt;回溯到原点既无解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;if(src_x == x &amp;amp;&amp;amp; src_y == y)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-11-10T00:54:26.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/</id>
        <title>Map 单词分析</title>
        <link rel="alternate" href="http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/"/>
        <content type="html">&lt;p&gt;&lt;strong&gt;蓝桥杯无法使用&lt;code&gt;for(x : y)&amp;#123;&amp;#125;&lt;/code&gt; 、 &lt;code&gt;auto&lt;/code&gt;等的C11语法和关键字&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

map&amp;lt;char, int&amp;gt; m;

int main(void)&amp;#123;
    string str;
    char mc;
    int s = 0;
    for(int i = 97; i &amp;lt;= 122; i++)&amp;#123;
        m.insert(make_pair((char)i, 0));
    &amp;#125;
    cin &amp;gt;&amp;gt; str;
    for(int i = 0; i &amp;lt; str.size(); i++)&amp;#123;
        m[str[i]]++;
    &amp;#125;
    for(map&amp;lt;char, int&amp;gt;::iterator i = m.begin(); i != m.end(); i++)&amp;#123;
        if(s &amp;lt; i-&amp;gt;second) mc = i-&amp;gt;first, s = i-&amp;gt;second;		// 记录次数
    &amp;#125;
    cout &amp;lt;&amp;lt; mc &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; m[mc];

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法" />
        <updated>2021-11-08T07:30:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</id>
        <title>DFS迷宫问题</title>
        <link rel="alternate" href="http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#pragma GCC optimize(2)
using namespace std;

int m[101][101];
int xS, yS, xE, yE;
int s;

void dfs(int x, int y)&amp;#123;
    if(x == xE &amp;amp;&amp;amp; y == yE)&amp;#123;
        s++;
        return;
    &amp;#125;else&amp;#123;		// 遍历四个方向 
        m[x][y] = 0;
        if(m[x + 1][y])&amp;#123;
            m[x + 1][y] = 0;		// 占位，防止死循环 
            dfs(x + 1, y);
            m[x + 1][y] = 1;
        &amp;#125;
        if(m[x - 1][y])&amp;#123;
            m[x - 1][y] = 0;
            dfs(x - 1, y);
            m[x - 1][y] = 1;
        &amp;#125;
        if(m[x][y + 1])&amp;#123;
            m[x][y + 1] = 0;
            dfs(x, y + 1);
            m[x][y + 1] = 1;
        &amp;#125;
        if(m[x][y - 1])&amp;#123;
            m[x][y - 1] = 0;
            dfs(x, y - 1);
            m[x][y - 1] = 1;
        &amp;#125;
    &amp;#125;
&amp;#125;

int main(void)&amp;#123;
    ios::sync_with_stdio(false);
    int x, y, k, Ox, Oy;
    cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; k;
    for(int i = 1; i &amp;lt;= x; i++)	// 棋盘预定义
        for(int j = 1; j &amp;lt;= y; j++)
            m[i][j] = 1;
    cin &amp;gt;&amp;gt; xS &amp;gt;&amp;gt; yS &amp;gt;&amp;gt; xE &amp;gt;&amp;gt; yE;
    for(int i = 0; i &amp;lt; k; i++)&amp;#123;	// 预先写入障碍
        cin &amp;gt;&amp;gt; Ox &amp;gt;&amp;gt; Oy;
        m[Ox][Oy] = 0;
    &amp;#125;
    dfs(xS, yS);
    cout &amp;lt;&amp;lt; s;

    return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法" />
        <updated>2021-11-08T06:36:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
        <title>Vector 二分查找</title>
        <link rel="alternate" href="http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
        <content type="html">&lt;p&gt;二分查找：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lower_bound：查找第一个大于或等于某个元素的位置。&lt;/li&gt;
&lt;li&gt;upper_bound：查找第一个大于某个元素的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vector 插入元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iterator insert(iterator it, const T&amp;amp; x)：iterator向量中迭代器指向元素前增加一个元素x&lt;/li&gt;
&lt;li&gt;iterator insert(iterator it, int n,const T&amp;amp; x)：向量中迭代器指向元素前增加n个相同的元素x&lt;/li&gt;
&lt;li&gt;iterator insert(iterator it, const_iterator first, const_iterator last)：向量中迭代器指向元素前插入另一个相同类型向量的[first, last)间的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main(void)&amp;#123;
    vector&amp;lt;int&amp;gt; arr;
    int t, k, a;
    for(int i = 0; i &amp;lt; 9; i++)&amp;#123;
        cin &amp;gt;&amp;gt; t;
        arr.push_back(t);
    &amp;#125;
    cin &amp;gt;&amp;gt; k;
    auto pos = upper_bound(arr.begin(), arr.end(), k); 	// vector&amp;lt;int&amp;gt;::iterator
    arr.insert(pos, k);
    for(int i = 0; i &amp;lt; 10; i++)
        cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="算法" />
        <updated>2021-11-04T07:39:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF/</id>
        <title>二叉树模板</title>
        <link rel="alternate" href="http://example.com/2021/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#pragma GCC optimize(2)
using namespace std;

struct tree&amp;#123;
    int left;
    int right;
&amp;#125;;

tree t[1000];

int dfs(int n)&amp;#123;		// 深度 
    if(!n) return 0;
    return max(dfs(t[n].left), dfs(t[n].right)) + 1;
&amp;#125;

void f(int n)&amp;#123;		// 先序 
    cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    if(t[n].left) f(t[n].left);
    if(t[n].right) f(t[n].right);
&amp;#125;

void s(int n)&amp;#123;		// 中序 
    if(t[n].left) s(t[n].left);
    cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    if(t[n].right) s(t[n].right);
&amp;#125;

void e(int n)&amp;#123;		// 后序 
    if(t[n].left) e(t[n].left);
    if(t[n].right) e(t[n].right);
    cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
&amp;#125;

int main(void)&amp;#123;
    int n;
    cin &amp;gt;&amp;gt; n;
    for(int i = 1; i &amp;lt;= n; i++)
        cin &amp;gt;&amp;gt; t[i].left &amp;gt;&amp;gt; t[i].right;
    
    return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-28T09:03:28.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/28/%E5%8D%A1%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%82%86%E6%97%A0%E5%BF%8C%E6%83%AESTL/</id>
        <title>卡常小技巧，肆无忌惮STL</title>
        <link rel="alternate" href="http://example.com/2021/10/28/%E5%8D%A1%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%82%86%E6%97%A0%E5%BF%8C%E6%83%AESTL/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#pragma GCC optimize(2)
ios::sync_with_stdio(false);
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-28T08:25:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/15/XX_XX_XX%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%90%E5%8F%96%E6%95%B0%E5%AD%97/</id>
        <title>XX:XX:XX类型字符串提取数字</title>
        <link rel="alternate" href="http://example.com/2021/10/15/XX_XX_XX%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%90%E5%8F%96%E6%95%B0%E5%AD%97/"/>
        <content type="html">&lt;p&gt;洛谷P1615&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cin &amp;gt;&amp;gt; time1
sscanf(time1.c_str(), &amp;quot;%d:%d:%d&amp;quot;, &amp;amp;h1, &amp;amp;m1, &amp;amp;s1); // c_str()获取字符串地址
// 或者直接这样写 scanf(&amp;quot;%d:%d:%d&amp;quot;, &amp;amp;h1, &amp;amp;m1, &amp;amp;s1);
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-15T09:26:16.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/10/01/P2911_[USACO08OCT]Bovine_Bones_G_(C)/</id>
        <title>P2911 [USACO08OCT]Bovine Bones G (C)</title>
        <link rel="alternate" href="http://example.com/2021/10/01/P2911_[USACO08OCT]Bovine_Bones_G_(C)/"/>
        <content type="html">&lt;p&gt;&lt;img data-src=&#34;https://i.loli.net/2021/10/01/dcA2xWtmfYQRaqD.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
    根据题意，总共3个骰子，每个骰子有 S个面，因为数据范围较小，可以直接选择暴力
    每次总和记录到相应的结构体(Sum = 10 -&amp;gt; struct[10])，结构体中保存两个数据：总和(num)、次数(times) 
    最后使用快排(qsort)筛出次数(times)最小的目标 
*/ 

#include&amp;lt;stdio.h&amp;gt;

struct A&amp;#123;		// 声明结构体，存放点数总和与次数 
    int num;
    int times;
&amp;#125;;

int compare(const void *a, const void *b)&amp;#123;
    struct A *p1 = (struct A *)a;
    struct A *p2 = (struct A *)b;
    if(p1-&amp;gt;times == p2-&amp;gt;times) return p1-&amp;gt;num - p2-&amp;gt;num;		// 题意：如果出现概率一样时输出最小总和 
    return p2-&amp;gt;times - p1-&amp;gt;times;
&amp;#125;

int main(void)&amp;#123;
    int s1, s2, s3, s, i, j, k;
    struct A a[80];
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;s1, &amp;amp;s2, &amp;amp;s3);
    for(i = 0; i &amp;lt; 81; i++)&amp;#123;
         a[i].times = 0;
         a[i].num = 0;
    &amp;#125;
    for(i = 1; i &amp;lt;= s1; i++)
        for(j = 1; j &amp;lt;= s2; j++)
            for(k = 1; k &amp;lt;= s3; k++)&amp;#123;
                a[i + j + k].num = i + j + k;
                a[i + j + k].times++;
            &amp;#125;

    qsort(a, 80, sizeof(struct A), compare);
    printf(&amp;quot;%d&amp;quot;, a[0].num);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-10-01T12:40:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/09/11/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F_C%E8%AF%AD%E8%A8%80/</id>
        <title>冒泡排序 C语言</title>
        <link rel="alternate" href="http://example.com/2021/09/11/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F_C%E8%AF%AD%E8%A8%80/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;

/* 交换函数
void swap(int *pa, int *pb)&amp;#123;
    int temp;
    if(*pa &amp;gt; *pb)&amp;#123;
        temp = *pb;
        *pb = *pa;
        *pa = temp; 
    &amp;#125;
&amp;#125;
*/

int main(void)&amp;#123;
    int a[] = &amp;#123;1, 3, 5, 2, 14, 8, 4 ,9&amp;#125;;
    int i, j;
    int temp;
    int num = (sizeof(a) / sizeof(a[0]));
    printf(&amp;quot;排序前：&amp;quot;);
    for(i = 0; i &amp;lt; num; i++)&amp;#123;
        printf(&amp;quot;%d &amp;quot;, a[i]);
    &amp;#125;
    printf(&amp;quot;\n&amp;quot;);

    // 冒泡 
    for(i = 0; i &amp;lt; num; i++)&amp;#123;		// 游标 
        for(j = i; j &amp;lt; num - 1; j++)&amp;#123;		// 两两比较 
            if(a[j] &amp;gt; a[j + 1])&amp;#123;
                temp = a[j + 1];
                a[j + 1] = a[j];
                a[j] = temp;
            &amp;#125;
            // swap((a + j), (a + j + 1));
        &amp;#125;
    &amp;#125;

    printf(&amp;quot;排序后：&amp;quot;);
    for(i = 0; i &amp;lt; num; i++)&amp;#123;
        printf(&amp;quot;%d &amp;quot;, a[i]);
    &amp;#125;
    return 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-09-11T09:10:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/09/04/P1223_%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4%E9%97%AE%E9%A2%98%E7%BB%AD%EF%BC%88C%EF%BC%89/</id>
        <title>P1223 排队接水问题续（C）</title>
        <link rel="alternate" href="http://example.com/2021/09/04/P1223_%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4%E9%97%AE%E9%A2%98%E7%BB%AD%EF%BC%88C%EF%BC%89/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
const MAX = 1500;

//创建结构体 
struct P&amp;#123;
    int id;
    int time;
&amp;#125;;

//排序函数 
int comp(const void *p1, const void *p2)
&amp;#123;
    const struct P *ps1 = (struct P *)p1;
    const struct P *ps2 = (struct P *)p2;	
    if(ps1-&amp;gt;time != ps2-&amp;gt;time)
        return ps1-&amp;gt;time - ps2-&amp;gt;time;
    else
        return ps1-&amp;gt;id - ps2-&amp;gt;id;
&amp;#125;

int main()
&amp;#123;
    struct P p[MAX];
    int count = 0;		//声明总人数 
    int i, j;
    double sum = 0.0; 
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;count);
    for(i = 0; i &amp;lt; count; i++)		//创建(id , time)散列表 
    &amp;#123;
        p[i].id = (i + 1);
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;p[i].time);
    &amp;#125;
    qsort(p, count, sizeof(p[1]), comp);		//快排 
    for(j = 0; j &amp;lt; count; j++)		//贪心算法求和计算总等待时间 
        sum += p[j].time * (count - j - 1); 
    for(j = 0; j &amp;lt; count; j++)		//输出最优顺序 
    &amp;#123;
        printf(&amp;quot;%d &amp;quot;,p[j].id);
    &amp;#125;
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;%.2lf\n&amp;quot;, sum / count);		//输出平均等待时间 
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL21pb2UueHl6L2luZGV4LnBocC9hcmNoaXZlcy80Mi8=&#34;&gt;Python解法&lt;/span&gt;&lt;/p&gt;
</content>
        <updated>2021-09-04T10:32:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/06/02/P1223_%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4_python/</id>
        <title>P1223 排队接水 python</title>
        <link rel="alternate" href="http://example.com/2021/06/02/P1223_%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4_python/"/>
        <content type="html">&lt;p&gt;&lt;img data-src=&#34;https://i.loli.net/2021/06/02/kzh7MsgTyiPWaUK.png&#34; alt=&#34;P1223 排队接水&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = int(input())
list1 = list(map(int, input().split()))
c = 1
sum1 = 0
list2 = []
for i in range(n):
    list2.append(&amp;#123;&amp;quot;id&amp;quot;: i + 1, &amp;quot;time&amp;quot;: list1[i]&amp;#125;)
list2.sort(key=lambda rank: rank[&amp;quot;time&amp;quot;])
for i in list2:
    sum1 += i[&amp;quot;time&amp;quot;] * (n - c)
    c += 1
for i in range(n):
    if i == n - 1:
        print(list2[i][&amp;quot;id&amp;quot;], end=&amp;quot;&amp;quot;)
    else:
        print(list2[i][&amp;quot;id&amp;quot;], end=&amp;quot; &amp;quot;)
print()
print(&amp;quot;%.2f&amp;quot; % (sum1/n))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-06-02T13:10:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/06/01/%E5%9B%9E%E6%96%87%E8%B4%A8%E6%95%B0_python/</id>
        <title>回文质数 python</title>
        <link rel="alternate" href="http://example.com/2021/06/01/%E5%9B%9E%E6%96%87%E8%B4%A8%E6%95%B0_python/"/>
        <content type="html">&lt;p&gt;&lt;img data-src=&#34;http://mioe.xyz/usr/uploads/2021/06/1304133883.png&#34; alt=&#34;6-01-2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;洛谷卡了很长时间，最终还是没有AC，最后两个超时，可能是我回文判断选择用字符串的方式导致的,最后没办法了，选择下策直接打表AC。&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;除 11 外没有偶数位的回文质数，那么[10000000,100000000] 这个区间根本不用枚举。&lt;/li&gt;
&lt;li&gt;只需要[2, sqrt(i) + 1]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import math
a, b = map(int, input().split())
list1 = []
if b &amp;gt; 10000000:
    b = 10000000
for i in range(a, b + 1):
    if str(i) == str(i)[::-1]:
        for j in range(2, int(math.sqrt(i)) + 1):
            if i % j == 0:
                break
        else:
            print(i)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-06-01T12:02:49.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/06/01/%E6%B4%9B%E8%B0%B7_P1106_%E5%88%A0%E6%95%B0%E9%97%AE%E9%A2%98_python%E8%A7%A3%E6%B3%95/</id>
        <title>洛谷 P1106 删数问题 python解法</title>
        <link rel="alternate" href="http://example.com/2021/06/01/%E6%B4%9B%E8%B0%B7_P1106_%E5%88%A0%E6%95%B0%E9%97%AE%E9%A2%98_python%E8%A7%A3%E6%B3%95/"/>
        <content type="html">&lt;p&gt;&lt;img data-src=&#34;http://mioe.xyz/usr/uploads/2021/06/3479330492.png&#34; alt=&#34;6-01-1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一次提交时，因为读题不清，3个WA。一开始理解为依次删除最大数，例50074897 2得500747，结果一直WA，然后被迫下载测试数据，发现正确答案为 4897。&lt;/p&gt;
&lt;p&gt;思索了一番，发现是个贪心问题,还是用 50074897 2 举例:&lt;br&gt;        (1) 5 &amp;gt; 0 , 删除5, 0074897&lt;br&gt;        (2) 0 &amp;#x3D; 0 , 不动 0074897&lt;br&gt;        (3) 0 &amp;#x3D; 0 , 同理 0074897&lt;br&gt;        (5) 7 &amp;gt; 4 , 删除7，004897&lt;br&gt;        (6) 去零整理，答案为 4897&lt;br&gt;Python天下第一，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m = input()
n = int(input())
i = 0   # 用于下标索引
while quit:
    # 边界默认和0比
    if i + 1 == len(m):
        m = m[:len(m) - 1]
        n -= 1
        i -= 1
    # 判断是否单调递增
    elif m[i] &amp;lt;= m[i + 1]:
        i += 1
        continue
    # 删除非递增项
    else:
        m = m.replace(m[i], &amp;quot;&amp;quot;, 1)
        n -= 1
        i -= 1
    # 循环结束
    if n == 0:
        break
print(int(m))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-06-01T11:48:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/05/31/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
        <title>贪婪算法之背包问题</title>
        <link rel="alternate" href="http://example.com/2021/05/31/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;p&gt;&lt;img data-src=&#34;http://mioe.xyz/usr/uploads/2021/05/33685418.png&#34; alt=&#34;5-31.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;coins, capacity = map(int, input().split())
emt = []
sum_coin = 0.0
for i in range(coins):
    temp_weight, temp_coin = map(int, input().split())
    emt.append(&amp;#123;&amp;#39;coin&amp;#39;: temp_coin, &amp;#39;weight&amp;#39;: temp_weight, &amp;#39;avg&amp;#39;: temp_coin/temp_weight&amp;#125;)
emt.sort(key=lambda emt_d: emt_d[&amp;#39;avg&amp;#39;], reverse=True)
for i in range(len(emt)):
    if capacity &amp;gt;= emt[i][&amp;#39;weight&amp;#39;]:
        sum_coin += emt[i][&amp;#39;coin&amp;#39;]
        capacity -= emt[i][&amp;#39;weight&amp;#39;]
    elif capacity &amp;lt; emt[i][&amp;#39;weight&amp;#39;] and capacity != 0:
        sum_coin += emt[i][&amp;#39;avg&amp;#39;] * capacity
        break
print(&amp;#39;%.2f&amp;#39; % sum_coin)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-05-31T13:54:41.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/03/31/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B(D&amp;amp;C%EF%BC%89/</id>
        <title>分而治之(D&amp;amp;C）</title>
        <link rel="alternate" href="http://example.com/2021/03/31/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B(D&amp;amp;C%EF%BC%89/"/>
        <content type="html">&lt;p&gt;&lt;strong&gt;分而治之（Ｄ＆Ｃ）&lt;/strong&gt;能将问题逐步分解，但并非可用于解决问题的算法，而是一种解决问题的思路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分而治之算法&lt;/strong&gt;是递归的，使用分而治之(D&amp;amp;C)解决问题的过程包括两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找出递归边界条件，这种条件必须尽可能简单&lt;/li&gt;
&lt;li&gt;不断地将问题分解（或者说缩小规模），直到符合递归边界条件。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：假设要将一块地均匀地分成方块，确保分出的方块最大的条件，应采取Ｄ＆Ｃ策略：适用于这小块地的最大方块，也是适用于整块地的最大方案。原因可参考欧几里得算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;给定一个数字数组　arr &amp;#x3D; [2, 4, 6]，如何将这些数字相加&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找出递归边界条件：数组不包含任何元素或只包含一个元素&lt;/li&gt;
&lt;li&gt;每次递归调用都必须离空数组更近一步。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;br&gt;    arr &amp;#x3D; [2, 4, 6]&lt;br&gt;    sum(arr) &amp;#x3D; 12&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#等效于下面的语句
arr = [4, 6]
2 + sum(arr) = 12

#再等效下面的语句
arr = [6]
2 + 6 + sum(arr) = 12

#依次类推，逐渐缩小了问题的规模
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：编写涉及数组的递归函数时，递归边界条件通常是数组为空或只包含一个元素。陷入困境时，请检查递归边界条件是不是这样的。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
        <updated>2021-03-31T10:15:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/03/31/%E9%80%92%E5%BD%92_-_%E6%95%B0%E7%BB%84%E7%B4%AF%E5%8A%A0/</id>
        <title>递归 - 数组累加</title>
        <link rel="alternate" href="http://example.com/2021/03/31/%E9%80%92%E5%BD%92_-_%E6%95%B0%E7%BB%84%E7%B4%AF%E5%8A%A0/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;def sum(a):
    if a == []:
        return 0    #基线条件
    return a[0] + sum(a[1:])    #递归条件

print(sum(a))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-03-31T10:01:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/03/28/%E8%BF%AD%E4%BB%A3_-_%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/</id>
        <title>迭代 - 水仙花数</title>
        <link rel="alternate" href="http://example.com/2021/03/28/%E8%BF%AD%E4%BB%A3_-_%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/"/>
        <content type="html">&lt;p&gt;偶然发现了一种用迭代算水仙花，太顶了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in range(100, 1000):
    sum = 0
    temp = i
    while temp:   #开始迭代
        sum = sum + (temp%10) ** 3
        temp //= 10
    if sum == i:
        print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如 153 这个数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先取出个位数 152 % 10 &amp;#x3D;&amp;#x3D; 2 ，再对 temp 去除个位 (temp &amp;#x2F;&amp;#x2F;&amp;#x3D; 10) ,这时 temp 等于 15&lt;/li&gt;
&lt;li&gt;while 为真，循环上一次操作，对 15 取各位 ，同理 temp 此时为 1&lt;/li&gt;
&lt;li&gt;对 1 求模 ，1 &amp;#x2F;&amp;#x2F; 10 为 0，跳出循环，至此 1,5,3 全部取出&lt;/li&gt;
&lt;/ol&gt;
</content>
        <updated>2021-03-28T07:13:27.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/03/28/%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E7%9A%84%E9%98%B6%E6%A2%AF%E9%97%AE%E9%A2%98/</id>
        <title>爱因斯坦的阶梯问题</title>
        <link rel="alternate" href="http://example.com/2021/03/28/%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E7%9A%84%E9%98%B6%E6%A2%AF%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;h2 id=&#34;爱因斯坦的阶梯难题&#34;&gt;&lt;a href=&#34;#爱因斯坦的阶梯难题&#34; class=&#34;headerlink&#34; title=&#34;爱因斯坦的阶梯难题&#34;&gt;&lt;/a&gt;爱因斯坦的阶梯难题&lt;/h2&gt;&lt;p&gt;爱因斯坦曾出过这样一道有趣的数学题：有一个长阶梯，若每步上2阶，最后剩1阶；若每步上3阶，最后剩2阶；若每步上5阶，最后剩4阶；若每步上6阶，最后剩5阶；只有每步上7阶，最后刚好一阶也不剩。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 0
while True:
    if i % 2 == 1 and i % 3 == 2 and i % 5 == 4 and i % 6 == 5 and i % 7 == 0:
        print(i)
        break
    else:
        i += 1
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-03-28T06:10:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
        <title>二分查找</title>
        <link rel="alternate" href="http://example.com/2021/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
        <content type="html">&lt;pre&gt;&lt;code&gt;def binary(list, item):         #二分查找
    low = 0
    high = len(list)
    while low &amp;lt;= high:
        mid = int((low + high) / 2)
        if list[mid] == item:
            return mid
        if list[mid] &amp;lt;= item:
            low = mid + 1         #中值已经比较过，直接从下一值开始，提高效率
        if list[mid] &amp;gt;= item:
            high = mid - 1         #同理
 
 
list1 = [1, 3, 5, 7, 9, 11, 15, 16]         #二分查找测试
print(binary(list1, 9))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2021-03-21T07:53:00.000Z</updated>
    </entry>
</feed>
