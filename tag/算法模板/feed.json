{
    "version": "https://jsonfeed.org/version/1",
    "title": "mioe • All posts by \"算法模板\" tag",
    "description": "花店不开了，花继续开",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/01/20/%E7%A6%BB%E6%95%A3%E5%8C%96%E5%8C%BA%E9%97%B4%E5%92%8C/",
            "url": "http://example.com/2023/01/20/%E7%A6%BB%E6%95%A3%E5%8C%96%E5%8C%BA%E9%97%B4%E5%92%8C/",
            "title": "离散化区间和",
            "date_published": "2023-01-20T11:29:00.000Z",
            "content_html": "<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100;\ntypedef pair&lt;int, int&gt; PII;\n\nint n, m;\nint arr[N], sum[N];\nvector&lt;int&gt; alls;\nvector&lt;PII&gt; add, query;\n\n// 查找x在alls数组中的下标\nint find(int x)&#123;\n    int l = 0, r = alls.size() - 1, mid;\n    while(l &lt; r)&#123;\n        mid = l + r &gt;&gt; 1;\n        if(alls[mid] &gt;= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return l + 1;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    int x, c;\n    for(int i = 0; i &lt; n; i++)&#123;\n        cin &gt;&gt; x &gt;&gt; c;\n        add.push_back(&#123;x, c&#125;);\n        alls.push_back(x);\n    &#125;\n\n    int l, r;\n    for(int i = 0; i &lt; m; i++)&#123;\n        cin &gt;&gt; l &gt;&gt; r;\n        query.push_back(&#123;l, r&#125;);\n        alls.push_back(l);\n        alls.push_back(r);\n    &#125;\n\n    // 排序去重\n    sort(alls.begin(), alls.end());\n    alls.erase(unique(alls.begin(), alls.end()), alls.end());\n\n    for(auto item : add)\n        arr[find(item.first)] += item.second;\n\n    // 处理前缀和\n    for(int i = 1; i &lt;= alls.size(); i++)\n        sum[i] = sum[i - 1] + arr[i];\n\n    for(auto item : query)\n        printf(&quot;%d\\n&quot;, sum[find(item.second)] - sum[find(item.first) - 1]);\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "算法模板"
            ]
        },
        {
            "id": "http://example.com/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91___%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A8%A1%E6%9D%BF/",
            "url": "http://example.com/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91___%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A8%A1%E6%9D%BF/",
            "title": "线段树 / 树状数组 模板",
            "date_published": "2022-12-30T13:40:00.000Z",
            "content_html": "<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定 <strong>n</strong> 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 <strong>[<strong>a</strong>,<strong>b</strong>]</strong> 的连续和。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行包含两个整数 <strong>n</strong> 和 <strong>m</strong>，分别表示数的个数和操作次数。</p>\n<p>第二行包含 <strong>n</strong> 个整数，表示完整数列。</p>\n<p>接下来 <strong>m</strong> 行，每行包含三个整数 <strong>k</strong>,<strong>a</strong>,<strong>b</strong> （<strong>k&#x3D;0</strong>，表示求子数列 <strong>[a,b]</strong> 的和；<strong>k&#x3D;1</strong>，表示第 <strong>a</strong> 个数加 <strong>b</strong>）。</p>\n<p>数列从 <strong>1</strong> 开始计数。</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>输出若干行数字，表示 <strong>k</strong>&#x3D;<strong>0</strong> 时，对应的子数列 <strong>[<strong>a</strong>,<strong>b</strong>]</strong> 的连续和。</p>\n<h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p><strong>1</strong>≤<strong>n</strong>≤<strong>100000</strong>,<br><strong>1</strong>≤<strong>m</strong>≤<strong>100000，<br>1</strong>≤<strong>a</strong>≤<strong>b</strong>≤<strong>n</strong>,<br>数据保证在任何时候，数列中所有元素之和均在 int 范围内。</p>\n<h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>10 5\n1 2 3 4 5 6 7 8 9 10\n1 1 5\n0 1 3\n0 4 8\n1 7 5\n0 4 8\n</code></pre>\n<h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>11\n30\n35\n</code></pre>\n<h4 id=\"树状数组模板\"><a href=\"#树状数组模板\" class=\"headerlink\" title=\"树状数组模板\"></a>树状数组模板</h4><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010;\n\nint n, m;\nint arr[N], tr[N];\n\nint lowbit(int i)&#123;\n    return i &amp; -i;\n&#125;\n\nvoid add(int index, int x)&#123;\n    for(int i = index; i &lt;= n; i += lowbit(i))\n        tr[i] += x;\n    return;\n&#125;\n\nvoid change(int index, int x)&#123;\n    int c = x - arr[index];\n    for(int i = index; i &lt;= n; i += lowbit(i))\n        tr[i] += c;\n    return;\n&#125;\n\nint query(int index)&#123;\n    int res = 0;\n    for(int i = index; i; i -= lowbit(i))\n        res += tr[i];\n    return res;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;arr[i]);\n    for(int i = 1; i &lt;= n; i++) add(i, arr[i]);\n\n    while(m--)&#123;\n        int tag, l, r;\n        int res;\n        scanf(&quot;%d %d %d&quot;, &amp;tag, &amp;l, &amp;r);\n        if(tag) add(l, r);\n        else printf(&quot;%d\\n&quot;, query(r) - query(l - 1));\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"线段树模板\"><a href=\"#线段树模板\" class=\"headerlink\" title=\"线段树模板\"></a>线段树模板</h4><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010;\n\nint n, m;\nint num[N];\n\nstruct node&#123;\n    int l, r;\n    int sum;\n&#125;sgt[N * 4];\t\t// 需要开N * 4\n\n// 更新当前节点\nvoid pushup(int root)&#123;\n    sgt[root].sum = sgt[root &lt;&lt; 1].sum + sgt[root &lt;&lt; 1 | 1].sum;\n&#125;\n\n// 初始化线段树\nvoid build(int root, int l, int r)&#123;\n    if(l == r) sgt[root].sum = num[l];\n    else&#123;\n        sgt[root] = &#123;l, r&#125;;\n        int mid = l + r &gt;&gt; 1;\n        build(root &lt;&lt; 1, l, mid);\n        build(root &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(root);\n    &#125;\n    return;\n&#125;\n\nint query(int root, int l, int r)&#123;\n    if(sgt[root].l &gt;= l &amp;&amp; sgt[root].r &lt;= r) return sgt[root].sum;\n    int mid = sgt[root].l + sgt[root].r &gt;&gt; 1;\n    int sum = 0;\n    if(l &lt;= mid) sum += query(root &lt;&lt; 1, l, r);\n    if(r &gt; mid) sum += query(root &lt;&lt; 1 | 1, l, r);\n    return sum;\n&#125;\n\nvoid modify(int root, int index, int c)&#123;\n    if(sgt[root].l == sgt[root].r) sgt[root].sum += c;\n    else&#123;\n        int mid = sgt[root].l + sgt[root].r &gt;&gt; 1;\n        if(index &lt;= mid) modify(root &lt;&lt; 1, index, c);\n        else modify(root &lt;&lt; 1 | 1, index, c);\n        pushup(root);\n    &#125;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;num[i]);\n    build(1, 1, n);\n    int k, a, b;\n    while(m--)&#123;\n        scanf(&quot;%d %d %d&quot;, &amp;k, &amp;a, &amp;b);\n        if(k) modify(1, a, b);\n        else printf(&quot;%d\\n&quot;, query(1, a, b));\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "算法模板"
            ]
        }
    ]
}