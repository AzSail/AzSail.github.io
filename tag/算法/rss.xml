<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>書架 • Posts by &#34;算法&#34; tag</title>
        <link>http://example.com</link>
        <description>花店不开了，花继续开</description>
        <language>zh-CN</language>
        <pubDate>Mon, 08 Nov 2021 15:30:00 +0800</pubDate>
        <lastBuildDate>Mon, 08 Nov 2021 15:30:00 +0800</lastBuildDate>
        <category>算法</category>
        <category>BFS</category>
        <category>Resilio Sync</category>
        <category>unity</category>
        <category>WolfraAlpha</category>
        <category>数论</category>
        <category>github</category>
        <category>linux</category>
        <category>Open-cv</category>
        <category>模板</category>
        <category>碧蓝航线</category>
        <category>Python</category>
        <category>局域网</category>
        <category>阅读</category>
        <category>相册</category>
        <category>算法模板</category>
        <item>
            <guid isPermalink="true">http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/</guid>
            <title>Map 单词分析</title>
            <link>http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/</link>
            <category>算法</category>
            <pubDate>Mon, 08 Nov 2021 15:30:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;strong&gt;蓝桥杯无法使用 &lt;code&gt;for(x : y)&amp;#123;&amp;#125;&lt;/code&gt;  、  &lt;code&gt;auto&lt;/code&gt;  等的 C11 语法和关键字&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

map&amp;lt;char, int&amp;gt; m;

int main(void)&amp;#123;
	string str;
	char mc;
	int s = 0;
	for(int i = 97; i &amp;lt;= 122; i++)&amp;#123;
		m.insert(make_pair((char)i, 0));
	&amp;#125;
	cin &amp;gt;&amp;gt; str;
	for(int i = 0; i &amp;lt; str.size(); i++)&amp;#123;
		m[str[i]]++;
	&amp;#125;
	for(map&amp;lt;char, int&amp;gt;::iterator i = m.begin(); i != m.end(); i++)&amp;#123;
		if(s &amp;lt; i-&amp;gt;second) mc = i-&amp;gt;first, s = i-&amp;gt;second;		// 记录次数
	&amp;#125;
	cout &amp;lt;&amp;lt; mc &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; m[mc];

	return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</guid>
            <title>DFS迷宫问题</title>
            <link>http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</link>
            <category>算法</category>
            <pubDate>Mon, 08 Nov 2021 14:36:00 +0800</pubDate>
            <description><![CDATA[ &lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#pragma GCC optimize(2)
using namespace std;

int m[101][101];
int xS, yS, xE, yE;
int s;

void dfs(int x, int y)&amp;#123;
	if(x == xE &amp;amp;&amp;amp; y == yE)&amp;#123;
		s++;
		return;
	&amp;#125;else&amp;#123;		// 遍历四个方向 
		m[x][y] = 0;
		if(m[x + 1][y])&amp;#123;
			m[x + 1][y] = 0;		// 占位，防止死循环 
			dfs(x + 1, y);
			m[x + 1][y] = 1;
		&amp;#125;
		if(m[x - 1][y])&amp;#123;
			m[x - 1][y] = 0;
			dfs(x - 1, y);
			m[x - 1][y] = 1;
		&amp;#125;
		if(m[x][y + 1])&amp;#123;
			m[x][y + 1] = 0;
			dfs(x, y + 1);
			m[x][y + 1] = 1;
		&amp;#125;
		if(m[x][y - 1])&amp;#123;
			m[x][y - 1] = 0;
			dfs(x, y - 1);
			m[x][y - 1] = 1;
		&amp;#125;
	&amp;#125;
&amp;#125;

int main(void)&amp;#123;
	ios::sync_with_stdio(false);
	int x, y, k, Ox, Oy;
	cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; k;
	for(int i = 1; i &amp;lt;= x; i++)	// 棋盘预定义
		for(int j = 1; j &amp;lt;= y; j++)
			m[i][j] = 1;
	cin &amp;gt;&amp;gt; xS &amp;gt;&amp;gt; yS &amp;gt;&amp;gt; xE &amp;gt;&amp;gt; yE;
	for(int i = 0; i &amp;lt; k; i++)&amp;#123;	// 预先写入障碍
		cin &amp;gt;&amp;gt; Ox &amp;gt;&amp;gt; Oy;
		m[Ox][Oy] = 0;
	&amp;#125;
	dfs(xS, yS);
	cout &amp;lt;&amp;lt; s;

	return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/11/05/C++_STL%E4%B8%AD%E7%9A%84next_permutation/</guid>
            <title>C++ STL中的next_permutation</title>
            <link>http://example.com/2021/11/05/C++_STL%E4%B8%AD%E7%9A%84next_permutation/</link>
            <category>算法</category>
            <pubDate>Fri, 05 Nov 2021 14:45:00 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;Rearranges the elements in the range  &lt;code&gt;[first,last)&lt;/code&gt;  into the next &lt;em&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jcGx1c3BsdXMuY29tL2xleGljb2dyYXBoaWNhbF9jb21wYXJl&#34;&gt;lexicographically&lt;/span&gt; greater&lt;/em&gt; permutation.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;将范围内的元素重新排列 &lt;code&gt;[first,last)&lt;/code&gt;  为下一个&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jcGx1c3BsdXMuY29tL2xleGljb2dyYXBoaWNhbF9jb21wYXJl&#34;&gt;字典序&lt;/span&gt;更大的排列。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jcGx1c3BsdXMuY29t&#34;&gt;–cplusplus.com&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 next_permutation 函数，其函数原型为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; #include &amp;lt;algorithm&amp;gt;
 bool next_permutation(iterator start,iterator end)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
int main()&amp;#123;
    int num[3]=&amp;#123;1, 2, 3&amp;#125;;
    do&amp;#123;
        cout &amp;lt;&amp;lt; num[0] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[1] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[2] &amp;lt;&amp;lt; endl;
    &amp;#125;while(next_permutation(num, num + 3));
    return 0;
&amp;#125;

输出结果：
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们把 &lt;code&gt;while(next_permutation(num, num + 3))&lt;/code&gt;  中的 &lt;code&gt;3&lt;/code&gt;  改为 &lt;code&gt;2&lt;/code&gt;  时，输出就变为了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3
2 1 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此可见，next_permutation 是对数组前 n 项进行全排列&lt;/p&gt;
&lt;p&gt;同理，既然有下一个全排列函数，那肯定是有上一个全排列函数： &lt;code&gt;prev_permutation&lt;/code&gt;  使用方法与 &lt;code&gt;next_permutation&lt;/code&gt;  一致。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/11/04/scanf%E3%80%81cin%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5/</guid>
            <title>scanf、cin返回值与连续输入</title>
            <link>http://example.com/2021/11/04/scanf%E3%80%81cin%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5/</link>
            <category>算法</category>
            <pubDate>Thu, 04 Nov 2021 19:43:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;code&gt;scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;a, &amp;amp;b);&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a&lt;/strong&gt; , &lt;strong&gt;b&lt;/strong&gt; 都成功读入，返回值为 &lt;strong&gt;2&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;只有 &lt;strong&gt;a&lt;/strong&gt; 成功读入，返回值为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a&lt;/strong&gt; 和 &lt;strong&gt;b&lt;/strong&gt; 都未成功读入，返回值为 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;strong&gt;错误&lt;/strong&gt; 或遇到 &lt;strong&gt;end of file&lt;/strong&gt;，返回值为 &lt;strong&gt;EOF&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;std::cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; 	// cin 无返回值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续输入参考模板：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while(scanf(&amp;quot;%d&amp;quot;, &amp;amp;i) != EOF)&amp;#123;...&amp;#125;

while(cin &amp;gt;&amp;gt; i)&amp;#123;...&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/11/04/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A1%A8%E8%BE%BE/</guid>
            <title>关于矩阵对角线的相关表达</title>
            <link>http://example.com/2021/11/04/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A1%A8%E8%BE%BE/</link>
            <category>算法</category>
            <pubDate>Thu, 04 Nov 2021 16:02:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;主对角线元素下标满足： &lt;code&gt;i = j&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;副对角线元素下标满足： &lt;code&gt;i + j = n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;假设一个 &lt;code&gt;n×n&lt;/code&gt;  的矩阵：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3 ...
4 5 6
7 8 9
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主对角线一定满足  &lt;code&gt;a[1][1], a[2][2], a[3][3]..., a[n][n]&lt;/code&gt;  其中主对角线的每项都有  &lt;code&gt;i == j&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;副对角线一定满足  &lt;code&gt;a[1][n], a[2][n - 1], a[3][n - 3] ... a[n][1]&lt;/code&gt;  其中次对角线的每项都有  &lt;code&gt;i + j == n&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;相关：求秩、八皇后问题…&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
            <title>Vector 二分查找</title>
            <link>http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
            <category>算法</category>
            <pubDate>Thu, 04 Nov 2021 15:39:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;二分查找：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lower_bound：查找第一个大于或等于某个元素的位置。&lt;/li&gt;
&lt;li&gt;upper_bound：查找第一个大于某个元素的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vector 插入元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iterator insert (iterator it, const T&amp;amp; x)：iterator 向量中迭代器指向元素前增加一个元素 x&lt;/li&gt;
&lt;li&gt;iterator insert (iterator it, int n,const T&amp;amp; x)：向量中迭代器指向元素前增加 n 个相同的元素 x&lt;/li&gt;
&lt;li&gt;iterator insert (iterator it, const_iterator first, const_iterator last)：向量中迭代器指向元素前插入另一个相同类型向量的 [first, last) 间的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main(void)&amp;#123;
	vector&amp;lt;int&amp;gt; arr;
	int t, k, a;
	for(int i = 0; i &amp;lt; 9; i++)&amp;#123;
		cin &amp;gt;&amp;gt; t;
		arr.push_back(t);
	&amp;#125;
	cin &amp;gt;&amp;gt; k;
	auto pos = upper_bound(arr.begin(), arr.end(), k); 	// vector&amp;lt;int&amp;gt;::iterator
	arr.insert(pos, k);
	for(int i = 0; i &amp;lt; 10; i++)
		cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; endl;

	return 0;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
