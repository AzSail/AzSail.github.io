{
    "version": "https://jsonfeed.org/version/1",
    "title": "書架 • All posts by \"算法\" tag",
    "description": "花店不开了，花继续开",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/",
            "url": "http://example.com/2021/11/08/Map_%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/",
            "title": "Map 单词分析",
            "date_published": "2021-11-08T07:30:00.000Z",
            "content_html": "<p><strong>蓝桥杯无法使用<code>for(x : y)&#123;&#125;</code> 、 <code>auto</code>等的C11语法和关键字</strong></p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nmap&lt;char, int&gt; m;\n\nint main(void)&#123;\n    string str;\n    char mc;\n    int s = 0;\n    for(int i = 97; i &lt;= 122; i++)&#123;\n        m.insert(make_pair((char)i, 0));\n    &#125;\n    cin &gt;&gt; str;\n    for(int i = 0; i &lt; str.size(); i++)&#123;\n        m[str[i]]++;\n    &#125;\n    for(map&lt;char, int&gt;::iterator i = m.begin(); i != m.end(); i++)&#123;\n        if(s &lt; i-&gt;second) mc = i-&gt;first, s = i-&gt;second;\t\t// 记录次数\n    &#125;\n    cout &lt;&lt; mc &lt;&lt; endl &lt;&lt; m[mc];\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2021/11/08/DFS%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/",
            "title": "DFS迷宫问题",
            "date_published": "2021-11-08T06:36:00.000Z",
            "content_html": "<pre><code>#include&lt;bits/stdc++.h&gt;\n#pragma GCC optimize(2)\nusing namespace std;\n\nint m[101][101];\nint xS, yS, xE, yE;\nint s;\n\nvoid dfs(int x, int y)&#123;\n    if(x == xE &amp;&amp; y == yE)&#123;\n        s++;\n        return;\n    &#125;else&#123;\t\t// 遍历四个方向 \n        m[x][y] = 0;\n        if(m[x + 1][y])&#123;\n            m[x + 1][y] = 0;\t\t// 占位，防止死循环 \n            dfs(x + 1, y);\n            m[x + 1][y] = 1;\n        &#125;\n        if(m[x - 1][y])&#123;\n            m[x - 1][y] = 0;\n            dfs(x - 1, y);\n            m[x - 1][y] = 1;\n        &#125;\n        if(m[x][y + 1])&#123;\n            m[x][y + 1] = 0;\n            dfs(x, y + 1);\n            m[x][y + 1] = 1;\n        &#125;\n        if(m[x][y - 1])&#123;\n            m[x][y - 1] = 0;\n            dfs(x, y - 1);\n            m[x][y - 1] = 1;\n        &#125;\n    &#125;\n&#125;\n\nint main(void)&#123;\n    ios::sync_with_stdio(false);\n    int x, y, k, Ox, Oy;\n    cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\n    for(int i = 1; i &lt;= x; i++)\t// 棋盘预定义\n        for(int j = 1; j &lt;= y; j++)\n            m[i][j] = 1;\n    cin &gt;&gt; xS &gt;&gt; yS &gt;&gt; xE &gt;&gt; yE;\n    for(int i = 0; i &lt; k; i++)&#123;\t// 预先写入障碍\n        cin &gt;&gt; Ox &gt;&gt; Oy;\n        m[Ox][Oy] = 0;\n    &#125;\n    dfs(xS, yS);\n    cout &lt;&lt; s;\n\n    return 0;\n&#125; \n</code></pre>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/11/05/C++_STL%E4%B8%AD%E7%9A%84next_permutation/",
            "url": "http://example.com/2021/11/05/C++_STL%E4%B8%AD%E7%9A%84next_permutation/",
            "title": "C++ STL中的next_permutation",
            "date_published": "2021-11-05T06:45:00.000Z",
            "content_html": "<blockquote>\n<p>Rearranges the elements in the range <code>[first,last)</code> into the next <em><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcGx1c3BsdXMuY29tL2xleGljb2dyYXBoaWNhbF9jb21wYXJl\">lexicographically</span> greater</em> permutation.</p>\n<p><em>将范围内的元素重新排列<code>[first,last)</code>为下一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcGx1c3BsdXMuY29tL2xleGljb2dyYXBoaWNhbF9jb21wYXJl\">字典序</span>更大的排列。</em></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcGx1c3BsdXMuY29tLw==\">–cplusplus.com</span></p>\n</blockquote>\n<p>对于next_permutation函数，其函数原型为：</p>\n<pre><code> #include &lt;algorithm&gt;\n bool next_permutation(iterator start,iterator end)\n</code></pre>\n<p>如下例子：</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()&#123;\n    int num[3]=&#123;1, 2, 3&#125;;\n    do&#123;\n        cout &lt;&lt; num[0] &lt;&lt; &quot; &quot; &lt;&lt; num[1] &lt;&lt; &quot; &quot; &lt;&lt; num[2] &lt;&lt; endl;\n    &#125;while(next_permutation(num, num + 3));\n    return 0;\n&#125;\n\n输出结果：\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n</code></pre>\n<p>当我们把<code>while(next_permutation(num, num + 3))</code>中的<code>3</code>改为<code>2</code>时，输出就变为了：</p>\n<pre><code>1 2 3\n2 1 3\n</code></pre>\n<p>由此可见，next_permutation是对数组前n项进行全排列</p>\n<p>同理，既然有下一个全排列函数，那肯定是有上一个全排列函数：<code>prev_permutation</code>使用方法与<code>next_permutation</code>一致。</p>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/11/04/scanf%E3%80%81cin%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5/",
            "url": "http://example.com/2021/11/04/scanf%E3%80%81cin%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5/",
            "title": "scanf、cin返回值与连续输入",
            "date_published": "2021-11-04T11:43:00.000Z",
            "content_html": "<p><code>scanf(&quot;%d %d&quot;, &amp;a, &amp;b);</code></p>\n<ul>\n<li><strong>a</strong> , <strong>b</strong> 都成功读入，返回值为 <strong>2</strong></li>\n<li>只有 <strong>a</strong> 成功读入，返回值为 <strong>1</strong></li>\n<li><strong>a</strong> 和 <strong>b</strong> 都未成功读入，返回值为 <strong>0</strong></li>\n<li>遇到 <strong>错误</strong> 或遇到 <strong>end of file</strong>，返回值为 <strong>EOF</strong></li>\n</ul>\n<p><code>std::cin &gt;&gt; a &gt;&gt; b; \t// cin 无返回值</code></p>\n<p><strong>连续输入参考模板：</strong></p>\n<pre><code>while(scanf(&quot;%d&quot;, &amp;i) != EOF)&#123;...&#125;\n\nwhile(cin &gt;&gt; i)&#123;...&#125;\n</code></pre>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/11/04/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A1%A8%E8%BE%BE/",
            "url": "http://example.com/2021/11/04/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A1%A8%E8%BE%BE/",
            "title": "关于矩阵对角线的相关表达",
            "date_published": "2021-11-04T08:02:00.000Z",
            "content_html": "<p>主对角线元素下标满足：<code>i = j</code></p>\n<p>副对角线元素下标满足：<code>i + j = n</code></p>\n<p>假设一个<code>n×n</code>的矩阵：</p>\n<pre><code>1 2 3 ...\n4 5 6\n7 8 9\n...\n</code></pre>\n<p>主对角线一定满足 <code>a[1][1], a[2][2], a[3][3]..., a[n][n]</code> 其中主对角线的每项都有 <code>i == j</code></p>\n<p>副对角线一定满足 <code>a[1][n], a[2][n - 1], a[3][n - 3] ... a[n][1]</code> 其中次对角线的每项都有 <code>i + j == n</code></p>\n<hr>\n<p>相关：求秩、八皇后问题…</p>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/",
            "url": "http://example.com/2021/11/04/Vector_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/",
            "title": "Vector 二分查找",
            "date_published": "2021-11-04T07:39:00.000Z",
            "content_html": "<p>二分查找：</p>\n<ul>\n<li>lower_bound：查找第一个大于或等于某个元素的位置。</li>\n<li>upper_bound：查找第一个大于某个元素的位置。</li>\n</ul>\n<p>Vector 插入元素</p>\n<ul>\n<li>iterator insert(iterator it, const T&amp; x)：iterator向量中迭代器指向元素前增加一个元素x</li>\n<li>iterator insert(iterator it, int n,const T&amp; x)：向量中迭代器指向元素前增加n个相同的元素x</li>\n<li>iterator insert(iterator it, const_iterator first, const_iterator last)：向量中迭代器指向元素前插入另一个相同类型向量的[first, last)间的数据</li>\n</ul>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(void)&#123;\n    vector&lt;int&gt; arr;\n    int t, k, a;\n    for(int i = 0; i &lt; 9; i++)&#123;\n        cin &gt;&gt; t;\n        arr.push_back(t);\n    &#125;\n    cin &gt;&gt; k;\n    auto pos = upper_bound(arr.begin(), arr.end(), k); \t// vector&lt;int&gt;::iterator\n    arr.insert(pos, k);\n    for(int i = 0; i &lt; 10; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; endl;\n\n    return 0;\n&#125; \n</code></pre>\n",
            "tags": [
                "算法"
            ]
        }
    ]
}