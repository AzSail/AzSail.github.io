{
    "version": "https://jsonfeed.org/version/1",
    "title": "書架 • All posts by \"模板\" tag",
    "description": "花店不开了，花继续开",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/02/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/",
            "url": "http://example.com/2023/02/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/",
            "title": "最小生成树",
            "date_published": "2023-02-07T11:45:54.000Z",
            "content_html": "<h1 id=\"最短生成树\"><a href=\"#最短生成树\" class=\"headerlink\" title=\"最短生成树\"></a>最短生成树</h1><h2 id=\"Prim\"><a href=\"#Prim\" class=\"headerlink\" title=\"Prim\"></a>Prim</h2><pre><code class=\"cpp\">#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N = 505, INF = 0x3f3f3f3f;\n\nint n, m;\nint g[N][N];\nint dist[N];\nbool st[N];\n\nintprim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;   // 第一个点一定在最小生成树中\n\n    int res = 0;  // 用来存放权值之和\n    for(int i = 0; i &lt; n; i ++)\n    &#123;\n        int t = -1;\n        for(int j = 1; j &lt;= n; j ++)\n            if(!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))\n                t = j;\n\n        if(dist[t] == INF) return INF;   // 尽早跳出循环防止TLE，如果不加则需要在输出的地方更改\n        res += dist[t];\n        st[t] = true;\n\n        for(int j = 1; j &lt;= n; j ++)\n            dist[j] = min(dist[j], g[t][j]); // 注意和dijkstra的区别\n                                             // prim的dist是到已经生成的树的最短距离\n    &#125;\n    return res;\n&#125;\n\n\nintmain()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(g, 0x3f, sizeof g);\n\n    while(m --)\n    &#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        g[a][b] = g[b][a] = min(g[a][b], c);\n    &#125;\n\n    int t = prim();\n\n    if(t == INF) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;  // 如果上面不及时跳出循环则在这里改为(t &gt;= INF / 2)\n    else cout &lt;&lt; t &lt;&lt; endl;\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"kruskal\"><a href=\"#kruskal\" class=\"headerlink\" title=\"kruskal\"></a>kruskal</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100;\n\nstructNode&#123;\n    int a, b, w;\n  \n    bool operator&lt; (const Node &amp;N) const &#123;\n        return w &lt; N.w;\n    &#125;\n&#125;edges[N];\n\nint n, m, res, cnt;\nint g[N];\n\nintfind(int a)&#123;\n    if (a != g[a]) g[a] = find(g[a]);\n    return g[a];\n&#125;\n\nintkruskal()&#123;\n    for (int i = 0; i &lt; m; i++) &#123;\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n  \n        a = find(a), b = find(b);  \n        if (a != b) &#123;\n            g[a] = b;\n            res += w;\n            cnt++;\n        &#125;\n    &#125;\n  \n    if (cnt &lt; n - 1) return -1;\n    else return res;\n&#125;\n\nintmain()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n  \n    for (int i = 0; i &lt; m; i++) &#123;\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        edges[i] = &#123;a, b, c&#125;;\n    &#125;\n    for (int i = 1; i &lt;= n; i++) g[i] = i;\n    sort(edges, edges + m);\n  \n    int t = kruskal();\n    cout &lt;&lt; t;\n  \n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        },
        {
            "id": "http://example.com/2023/02/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2023/02/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/",
            "title": "最短路问题",
            "date_published": "2023-02-04T10:51:00.000Z",
            "content_html": "<h1 id=\"单源最短路\"><a href=\"#单源最短路\" class=\"headerlink\" title=\"单源最短路\"></a>单源最短路</h1><h2 id=\"dijkstra-稠密图\"><a href=\"#dijkstra-稠密图\" class=\"headerlink\" title=\"dijkstra 稠密图\"></a>dijkstra 稠密图</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e4;\n\nint n, m, s;\nint g[N][N];\nint dist[N];\nbool st[N];\n\nvoid dijkstra() &#123;\n    memset(dist, 0x3f, sizeof dist);\n\n    dist[s] = 0;\n\n    for (int i = 0; i &lt; n; i++) &#123;\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))\n                t = j;\n        st[t] = true;\n        for (int j = 1; j &lt;= n; j++) &#123;\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n        &#125;\n    &#125;\n\n    //\tif(dist[n] == 0x3f3f3f3f) return -1;\n    //\telse return n;\n&#125;\n\nint main() &#123;\n    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s);\n\n    memset(g, 0x3f, sizeof g);\n\n    int a, b, c;\n    while (m--) &#123;\n        scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);\n        g[a][b] = min(g[a][b], c);\n    &#125;\n\n    //\tint t = dijkstra();\n    //\tprintf(&quot;%d&quot;, t);\n\n    dijkstra();\n\n    for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, dist[i]);\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"堆优化dijkstra\"><a href=\"#堆优化dijkstra\" class=\"headerlink\" title=\"堆优化dijkstra\"></a>堆优化dijkstra</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 2e6 + 5;\ntypedef pair&lt;int, int&gt; PII;\n\nint n, m, s;\nint h[N], ne[N], e[N], w[N], idx;\nint dist[N];\nbool st[N];\n\nvoid add(int a, int b, int c) &#123;\n    w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\n\nvoid dijkstra() &#123;\n    memset(dist, 127, sizeof dist);\n    dist[s] = 0;\n\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    heap.push(&#123;0, s&#125;);\n\n    while (heap.size()) &#123;\n        auto t = heap.top();\n        heap.pop();\n\n        int ver = t.second, distance = t.first;\n\n        if (st[ver]) continue;\n        st[ver] = true;\n\n        for (int i = h[ver]; i != -1; i = ne[i]) &#123;\n            int j = e[i];\n            if (dist[j] &gt; distance + w[i]) &#123;\n                dist[j] = distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n\n    //\tif(dist[n] == 0x3f3f3f3f) return -1;\n    //\telse return n;\n&#125;\n\nint main() &#123;\n    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s);\n\n    memset(h, -1, sizeof h);\n    int a, b, c;\n    while (m--) &#123;\n        scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);\n        add(a, b, c);\n    &#125;\n    //\tint t = dijkstra();\n    //\tprintf(&quot;%d&quot;, t);\n\n    dijkstra();\n    for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, dist[i]);\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman-Ford\"></a>Bellman-Ford</h2><pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 505, M = 10010;\n\nint n, m, k;\nint dist[N], backup[N], st[N];\n\nstruct Node &#123;\n    int a, b, w;\n&#125; edges[M];\n\nint b_f() &#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    for (int i = 0; i &lt; k; i++) &#123;\n        memcpy(backup, dist, sizeof dist);\n        for (int j = 0; j &lt; m; j++) &#123;\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            dist[b] = min(dist[b], backup[a] + w);\n        &#125;\n    &#125;\n    if (dist[n] &gt;= 0x3f3f3f3f / 2) return -1;\n    else return dist[n];\n&#125;\n\nint main() &#123;\n    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);\n\n    for (int i = 0; i &lt; m; i++) &#123;\n        int x, y, z;\n        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);\n        edges[i] = &#123;x, y, z&#125;;\n    &#125;\n\n    int t = b_f();\n    if (t == -1 &amp;&amp; dist[n] != -1) printf(&quot;impossible&quot;);\n    else printf(&quot;%d&quot;, t);\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h2><p><img data-src=\"https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2023/02/568055134.png\" alt=\"《信息学奥赛一本通》 , usaco training 3.2\"></p>\n<h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h4><pre><code>3 4 5\n2\n3\n4\n1 2 1\n1 3 5\n2 3 7\n2 4 3\n3 4 5\n</code></pre>\n<h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h4><pre><code>8\n</code></pre>\n<h4 id=\"AC\"><a href=\"#AC\" class=\"headerlink\" title=\"AC\"></a>AC</h4><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 510, P = 805, C = 1455 * 2;    // 无向图 边 * 2;\n\nbool st[P];\nint cow[N];\nint dist[P];\nint ne[C], e[C], h[C], w[C], idx;\n\nvoid add(int a, int b, int v) &#123;\n    e[idx] = b, w[idx] = v, ne[idx] = h[a], h[a] = idx++;\n&#125;\n\nvoid spfa(int cw) &#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[cw] = 0;\n\n    queue&lt;int&gt; q;\n    q.push(cw);\n    st[cw] = true;\n\n    while (!q.empty()) &#123;\n        int t = q.front();\n        q.pop();\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i]) &#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) &#123;\n                dist[j] = dist[t] + w[i];\n                if (!st[j]) &#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main() &#123;\n    int n, p, c;\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; c;\n\n    for (int i = 0; i &lt; n; i++) cin &gt;&gt; cow[i];\n\n    memset(h, -1, sizeof h);\n    for (int i = 0; i &lt; c; i++) &#123;\n        int a, b, v;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;\n        add(a, b, v);\n        add(b, a, v);\n    &#125;\n\n    int res = 0x3f3f3f3f, t = 0;\n    for (int i = 1; i &lt;= p; i++) &#123;\n        t = 0;\n        spfa(i);\n        for (int j = 0; j &lt; n; j++) &#123;\n            if (t &gt;= 0x3f3f3f3f) continue;\n            t += dist[cow[j]];\n        &#125;\n        res = min(res, t);\n    &#125;\n\n    cout &lt;&lt; res;\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"负环判断\"><a href=\"#负环判断\" class=\"headerlink\" title=\"负环判断\"></a>负环判断</h2><pre><code class=\"cpp\">cnt[x] = cnt[i] + 1;\nif(cnt[x] &gt;= n) return true;\n</code></pre>\n<h1 id=\"多源最短路\"><a href=\"#多源最短路\" class=\"headerlink\" title=\"多源最短路\"></a>多源最短路</h1><h2 id=\"Floyd\"><a href=\"#Floyd\" class=\"headerlink\" title=\"Floyd\"></a>Floyd</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 205, inf = 0x3f3f3f3f;\n\nint g[N][N], path[N][N];\nint n, m, q;\nint tx, ty;\n\nvoid writePath(int x, int y)&#123;\n    if (path[x][y] != 0) &#123;\n        writePath(x, path[x][y]);\n        cout &lt;&lt; path[x][y] &lt;&lt; &quot; &quot;;\n    &#125;\n    if (y == ty) cout &lt;&lt; y &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid floyd() &#123;\n    for (int k = 1; k &lt;= n; k++)\n        for (int i = 1; i &lt;= n; i++)\n            for (int j = 1; j &lt;= n; j++)\n                if (g[i][k] + g[k][j] &lt; g[i][j]) &#123;\n                    g[i][j] = g[i][k] + g[k][j];\n                    path[i][j] = path[k][j];\n                &#125;\n&#125; \n\nint main() &#123;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++) &#123;\n        for (int j = 1; j &lt;= n; j++) &#123;\n            if (i == j) g[i][j] = 0;\n            else g[i][j] = inf;\n        &#125;\n    &#125;\n\n    for (int i = 0; i &lt; m; i++) &#123;\n        int x, y, z;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        path[x][y] = x;\n        g[x][y] = min(g[x][y], z);\n    &#125;\n\n    floyd();\n\n    cin &gt;&gt; tx &gt;&gt; ty;\n    cout &lt;&lt; g[tx][ty] &lt;&lt; endl;\n    writePath(tx, ty);\n\n    return 0;\n&#125;\n</code></pre>\n<pre><code>\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        },
        {
            "id": "http://example.com/2023/02/03/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89/",
            "url": "http://example.com/2023/02/03/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89/",
            "title": "树的深度优先遍历（邻接表）",
            "date_published": "2023-02-03T10:24:20.000Z",
            "content_html": "<h4 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h4><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100;\n\nint idx, n;\nint h[N], e[N], ne[N];\nbool st[N];\n\nvoid ins(int a, int b)&#123;\n    e[idx] = b;\n    ne[idx] = h[a];\n    h[a] = idx++;\n&#125;\n\nvoid dfs(int u)&#123;\n    st[u] = true;\n    cout &lt;&lt; u;\n    for(int i = h[u]; i != -1; i = ne[i])&#123;\n        int j = e[i];\n        if(!st[j]) dfs(j);\n    &#125;\n&#125;\n\nint main()&#123;\n    memset(h, -1, sizeof h);\n\n    cin &gt;&gt; n;\n    int a, b;\n\n    while(n--)&#123;\n        cin &gt;&gt; a &gt;&gt; b;\n        ins(a, b);\n    &#125;\n\n    dfs(1);\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        },
        {
            "id": "http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/",
            "url": "http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/",
            "title": "字符串哈希",
            "date_published": "2023-02-02T08:36:57.000Z",
            "content_html": "<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1010, P = 131;\n\nunsigned long long h[N], p[N];\nint n, m;\nchar str[N];\n\nunsigned long long gethash(int l, int r)&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d %d %s&quot;, &amp;n, &amp;m, str + 1);\n\n    p[0] = 1;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        p[i] = p[i - 1] * P;\n        h[i] = h[i - 1] * P + str[i];\n    &#125;\n\n    int l1, r1, l2, r2;\n    while(m--)&#123;\n        scanf(&quot;%d %d %d %d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);\n        if(gethash(l1, r1) == gethash(l2, r2)) printf(&quot;Yes\\n&quot;);\n        else printf(&quot;No\\n&quot;);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        },
        {
            "id": "http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/",
            "url": "http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/",
            "title": "小根堆",
            "date_published": "2023-02-01T10:38:45.000Z",
            "content_html": "<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e6+10;\n\nint hp[N], idx;\nint n;\n\nvoid down(int k)&#123;\n    int t = k;\n    if(hp[k &lt;&lt; 1] &lt; hp[t] &amp;&amp; (k &lt;&lt; 1) &lt;= idx) t = k &lt;&lt; 1;\n    if(hp[k &lt;&lt; 1 | 1] &lt; hp[t] &amp;&amp; (k &lt;&lt; 1 | 1) &lt;= idx) t = k &lt;&lt; 1 | 1;\n    if(t != k)&#123;\n        swap(hp[k], hp[t]);\n        down(t);\n    &#125;\n&#125;\n\nvoid up(int k)&#123;\n    while(k &gt;&gt; 1 &amp;&amp; hp[k &gt;&gt; 1] &gt; hp[k])&#123;\n        swap(hp[k &gt;&gt; 1], hp[k]);\n        k &gt;&gt;= 1;\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;n);\n\n    int x, y;\n    while(n--)&#123;\n        scanf(&quot;%d&quot;, &amp;x);\n        if(x == 1)&#123;\n            scanf(&quot;%d&quot;, &amp;y);\n            hp[++idx] = y;\n            up(idx);\n        &#125;else if(x == 2) printf(&quot;%d\\n&quot;, hp[1]);\n        else hp[1] = hp[idx], idx--, down(1);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        },
        {
            "id": "http://example.com/2023/01/31/%E9%9B%86%E5%90%88%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/",
            "url": "http://example.com/2023/01/31/%E9%9B%86%E5%90%88%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/",
            "title": "集合与并查集",
            "date_published": "2023-01-31T10:11:00.000Z",
            "content_html": "<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 100010;\n\nint son[N][26], cnt[N], idx;\nint n;\n\nvoid insert(string str)&#123;\n    int p = 0;\n    for(int i = 0; str[i]; i++)&#123;\n        int u = str[i] - &#39;a&#39;;\n        if(!son[p][u]) son[p][u] = ++idx;\n        p = son[p][u];\n    &#125;\n    cnt[p]++;\n&#125;\n\nint query(string str)&#123;\n    int p = 0;\n    for(int i = 0; str[i]; i++)&#123;\n        int u = str[i] - &#39;a&#39;;\n        if(!son[p][u]) return 0;\n        p = son[p][u];\n    &#125;\n\n    return cnt[p];\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; n;\n    while(n--)&#123;\n        char op;\n        string str;\n        cin &gt;&gt; op &gt;&gt; str;\n        if(op == &#39;I&#39;) insert(str);\n        else printf(&quot;%d\\n&quot;, query(str)); \n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h4><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 10010;\n\nint p[N], n, m;\n\nint find(int x)&#123;\n    if(p[x] != x) p[x] = find(p[x]);\n    return x;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    for(int i = 1; i &lt;= n; i++) p[i] = i;\n\n    while(m--)&#123;\n        int z, x, y;\n        scanf(&quot;%d%d%d&quot;, &amp;z, &amp;x, &amp;y);\n        if(z == 1) p[find(x)] = find(y);\n        else&#123;\n            if(find(x) == find(y)) printf(&quot;Y\\n&quot;);\n            else printf(&quot;N\\n&quot;);\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "模板"
            ]
        }
    ]
}