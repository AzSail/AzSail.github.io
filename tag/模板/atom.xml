<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>mioe • Posts by &#34;模板&#34; tag</title>
    <link href="http://example.com" />
    <updated>2023-02-07T11:45:54.000Z</updated>
    <category term="BFS" />
    <category term="算法" />
    <category term="Resilio Sync" />
    <category term="unity" />
    <category term="WolfraAlpha" />
    <category term="数论" />
    <category term="github" />
    <category term="linux" />
    <category term="Open-cv" />
    <category term="碧蓝航线" />
    <category term="Python" />
    <category term="模板" />
    <category term="局域网" />
    <category term="阅读" />
    <category term="相册" />
    <category term="算法模板" />
    <entry>
        <id>http://example.com/2023/02/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
        <title>最小生成树</title>
        <link rel="alternate" href="http://example.com/2023/02/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
        <content type="html">&lt;h1 id=&#34;最短生成树&#34;&gt;&lt;a href=&#34;#最短生成树&#34; class=&#34;headerlink&#34; title=&#34;最短生成树&#34;&gt;&lt;/a&gt;最短生成树&lt;/h1&gt;&lt;h2 id=&#34;Prim&#34;&gt;&lt;a href=&#34;#Prim&#34; class=&#34;headerlink&#34; title=&#34;Prim&#34;&gt;&lt;/a&gt;Prim&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;

const int N = 505, INF = 0x3f3f3f3f;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

intprim()
&amp;#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;   // 第一个点一定在最小生成树中

    int res = 0;  // 用来存放权值之和
    for(int i = 0; i &amp;lt; n; i ++)
    &amp;#123;
        int t = -1;
        for(int j = 1; j &amp;lt;= n; j ++)
            if(!st[j] &amp;amp;&amp;amp; (t == -1 || dist[j] &amp;lt; dist[t]))
                t = j;

        if(dist[t] == INF) return INF;   // 尽早跳出循环防止TLE，如果不加则需要在输出的地方更改
        res += dist[t];
        st[t] = true;

        for(int j = 1; j &amp;lt;= n; j ++)
            dist[j] = min(dist[j], g[t][j]); // 注意和dijkstra的区别
                                             // prim的dist是到已经生成的树的最短距离
    &amp;#125;
    return res;
&amp;#125;


intmain()
&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    memset(g, 0x3f, sizeof g);

    while(m --)
    &amp;#123;
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    &amp;#125;

    int t = prim();

    if(t == INF) cout &amp;lt;&amp;lt; &amp;quot;impossible&amp;quot; &amp;lt;&amp;lt; endl;  // 如果上面不及时跳出循环则在这里改为(t &amp;gt;= INF / 2)
    else cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kruskal&#34;&gt;&lt;a href=&#34;#kruskal&#34; class=&#34;headerlink&#34; title=&#34;kruskal&#34;&gt;&lt;/a&gt;kruskal&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

structNode&amp;#123;
    int a, b, w;
  
    bool operator&amp;lt; (const Node &amp;amp;N) const &amp;#123;
        return w &amp;lt; N.w;
    &amp;#125;
&amp;#125;edges[N];

int n, m, res, cnt;
int g[N];

intfind(int a)&amp;#123;
    if (a != g[a]) g[a] = find(g[a]);
    return g[a];
&amp;#125;

intkruskal()&amp;#123;
    for (int i = 0; i &amp;lt; m; i++) &amp;#123;
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
  
        a = find(a), b = find(b);  
        if (a != b) &amp;#123;
            g[a] = b;
            res += w;
            cnt++;
        &amp;#125;
    &amp;#125;
  
    if (cnt &amp;lt; n - 1) return -1;
    else return res;
&amp;#125;

intmain()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
  
    for (int i = 0; i &amp;lt; m; i++) &amp;#123;
        int a, b, c;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        edges[i] = &amp;#123;a, b, c&amp;#125;;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; i++) g[i] = i;
    sort(edges, edges + m);
  
    int t = kruskal();
    cout &amp;lt;&amp;lt; t;
  
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-07T11:45:54.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</id>
        <title>最短路问题</title>
        <link rel="alternate" href="http://example.com/2023/02/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;h1 id=&#34;单源最短路&#34;&gt;&lt;a href=&#34;#单源最短路&#34; class=&#34;headerlink&#34; title=&#34;单源最短路&#34;&gt;&lt;/a&gt;单源最短路&lt;/h1&gt;&lt;h2 id=&#34;dijkstra-稠密图&#34;&gt;&lt;a href=&#34;#dijkstra-稠密图&#34; class=&#34;headerlink&#34; title=&#34;dijkstra 稠密图&#34;&gt;&lt;/a&gt;dijkstra 稠密图&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1e4;

int n, m, s;
int g[N][N];
int dist[N];
bool st[N];

void dijkstra() &amp;#123;
    memset(dist, 0x3f, sizeof dist);

    dist[s] = 0;

    for (int i = 0; i &amp;lt; n; i++) &amp;#123;
        int t = -1;
        for (int j = 1; j &amp;lt;= n; j++)
            if (!st[j] &amp;amp;&amp;amp; (t == -1 || dist[t] &amp;gt; dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j &amp;lt;= n; j++) &amp;#123;
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        &amp;#125;
    &amp;#125;

    //	if(dist[n] == 0x3f3f3f3f) return -1;
    //	else return n;
&amp;#125;

int main() &amp;#123;
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);

    memset(g, 0x3f, sizeof g);

    int a, b, c;
    while (m--) &amp;#123;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        g[a][b] = min(g[a][b], c);
    &amp;#125;

    //	int t = dijkstra();
    //	printf(&amp;quot;%d&amp;quot;, t);

    dijkstra();

    for (int i = 1; i &amp;lt;= n; i++) printf(&amp;quot;%d &amp;quot;, dist[i]);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;堆优化dijkstra&#34;&gt;&lt;a href=&#34;#堆优化dijkstra&#34; class=&#34;headerlink&#34; title=&#34;堆优化dijkstra&#34;&gt;&lt;/a&gt;堆优化dijkstra&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 2e6 + 5;
typedef pair&amp;lt;int, int&amp;gt; PII;

int n, m, s;
int h[N], ne[N], e[N], w[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c) &amp;#123;
    w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&amp;#125;

void dijkstra() &amp;#123;
    memset(dist, 127, sizeof dist);
    dist[s] = 0;

    priority_queue&amp;lt;PII, vector&amp;lt;PII&amp;gt;, greater&amp;lt;PII&amp;gt;&amp;gt; heap;
    heap.push(&amp;#123;0, s&amp;#125;);

    while (heap.size()) &amp;#123;
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i]) &amp;#123;
            int j = e[i];
            if (dist[j] &amp;gt; distance + w[i]) &amp;#123;
                dist[j] = distance + w[i];
                heap.push(&amp;#123;dist[j], j&amp;#125;);
            &amp;#125;
        &amp;#125;
    &amp;#125;

    //	if(dist[n] == 0x3f3f3f3f) return -1;
    //	else return n;
&amp;#125;

int main() &amp;#123;
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);

    memset(h, -1, sizeof h);
    int a, b, c;
    while (m--) &amp;#123;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        add(a, b, c);
    &amp;#125;
    //	int t = dijkstra();
    //	printf(&amp;quot;%d&amp;quot;, t);

    dijkstra();
    for (int i = 1; i &amp;lt;= n; i++) printf(&amp;quot;%d &amp;quot;, dist[i]);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Bellman-Ford&#34;&gt;&lt;a href=&#34;#Bellman-Ford&#34; class=&#34;headerlink&#34; title=&#34;Bellman-Ford&#34;&gt;&lt;/a&gt;Bellman-Ford&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 505, M = 10010;

int n, m, k;
int dist[N], backup[N], st[N];

struct Node &amp;#123;
    int a, b, w;
&amp;#125; edges[M];

int b_f() &amp;#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i &amp;lt; k; i++) &amp;#123;
        memcpy(backup, dist, sizeof dist);
        for (int j = 0; j &amp;lt; m; j++) &amp;#123;
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            dist[b] = min(dist[b], backup[a] + w);
        &amp;#125;
    &amp;#125;
    if (dist[n] &amp;gt;= 0x3f3f3f3f / 2) return -1;
    else return dist[n];
&amp;#125;

int main() &amp;#123;
    scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;k);

    for (int i = 0; i &amp;lt; m; i++) &amp;#123;
        int x, y, z;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;x, &amp;amp;y, &amp;amp;z);
        edges[i] = &amp;#123;x, y, z&amp;#125;;
    &amp;#125;

    int t = b_f();
    if (t == -1 &amp;amp;&amp;amp; dist[n] != -1) printf(&amp;quot;impossible&amp;quot;);
    else printf(&amp;quot;%d&amp;quot;, t);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;SPFA&#34;&gt;&lt;a href=&#34;#SPFA&#34; class=&#34;headerlink&#34; title=&#34;SPFA&#34;&gt;&lt;/a&gt;SPFA&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&#34;https://mioe-xyz.oss-cn-shanghai.aliyuncs.com/usr/uploads/2023/02/568055134.png&#34; alt=&#34;《信息学奥赛一本通》 , usaco training 3.2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;输入样例&#34;&gt;&lt;a href=&#34;#输入样例&#34; class=&#34;headerlink&#34; title=&#34;输入样例&#34;&gt;&lt;/a&gt;输入样例&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出样例&#34;&gt;&lt;a href=&#34;#输出样例&#34; class=&#34;headerlink&#34; title=&#34;输出样例&#34;&gt;&lt;/a&gt;输出样例&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;8
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;AC&#34;&gt;&lt;a href=&#34;#AC&#34; class=&#34;headerlink&#34; title=&#34;AC&#34;&gt;&lt;/a&gt;AC&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 510, P = 805, C = 1455 * 2;    // 无向图 边 * 2;

bool st[P];
int cow[N];
int dist[P];
int ne[C], e[C], h[C], w[C], idx;

void add(int a, int b, int v) &amp;#123;
    e[idx] = b, w[idx] = v, ne[idx] = h[a], h[a] = idx++;
&amp;#125;

void spfa(int cw) &amp;#123;
    memset(dist, 0x3f, sizeof dist);
    dist[cw] = 0;

    queue&amp;lt;int&amp;gt; q;
    q.push(cw);
    st[cw] = true;

    while (!q.empty()) &amp;#123;
        int t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]) &amp;#123;
            int j = e[i];
            if (dist[j] &amp;gt; dist[t] + w[i]) &amp;#123;
                dist[j] = dist[t] + w[i];
                if (!st[j]) &amp;#123;
                    q.push(j);
                    st[j] = true;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;

int main() &amp;#123;
    int n, p, c;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; p &amp;gt;&amp;gt; c;

    for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; cow[i];

    memset(h, -1, sizeof h);
    for (int i = 0; i &amp;lt; c; i++) &amp;#123;
        int a, b, v;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; v;
        add(a, b, v);
        add(b, a, v);
    &amp;#125;

    int res = 0x3f3f3f3f, t = 0;
    for (int i = 1; i &amp;lt;= p; i++) &amp;#123;
        t = 0;
        spfa(i);
        for (int j = 0; j &amp;lt; n; j++) &amp;#123;
            if (t &amp;gt;= 0x3f3f3f3f) continue;
            t += dist[cow[j]];
        &amp;#125;
        res = min(res, t);
    &amp;#125;

    cout &amp;lt;&amp;lt; res;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;负环判断&#34;&gt;&lt;a href=&#34;#负环判断&#34; class=&#34;headerlink&#34; title=&#34;负环判断&#34;&gt;&lt;/a&gt;负环判断&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;cnt[x] = cnt[i] + 1;
if(cnt[x] &amp;gt;= n) return true;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;多源最短路&#34;&gt;&lt;a href=&#34;#多源最短路&#34; class=&#34;headerlink&#34; title=&#34;多源最短路&#34;&gt;&lt;/a&gt;多源最短路&lt;/h1&gt;&lt;h2 id=&#34;Floyd&#34;&gt;&lt;a href=&#34;#Floyd&#34; class=&#34;headerlink&#34; title=&#34;Floyd&#34;&gt;&lt;/a&gt;Floyd&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 205, inf = 0x3f3f3f3f;

int g[N][N], path[N][N];
int n, m, q;
int tx, ty;

void writePath(int x, int y)&amp;#123;
    if (path[x][y] != 0) &amp;#123;
        writePath(x, path[x][y]);
        cout &amp;lt;&amp;lt; path[x][y] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    &amp;#125;
    if (y == ty) cout &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
&amp;#125;

void floyd() &amp;#123;
    for (int k = 1; k &amp;lt;= n; k++)
        for (int i = 1; i &amp;lt;= n; i++)
            for (int j = 1; j &amp;lt;= n; j++)
                if (g[i][k] + g[k][j] &amp;lt; g[i][j]) &amp;#123;
                    g[i][j] = g[i][k] + g[k][j];
                    path[i][j] = path[k][j];
                &amp;#125;
&amp;#125; 

int main() &amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

    for (int i = 1; i &amp;lt;= n; i++) &amp;#123;
        for (int j = 1; j &amp;lt;= n; j++) &amp;#123;
            if (i == j) g[i][j] = 0;
            else g[i][j] = inf;
        &amp;#125;
    &amp;#125;

    for (int i = 0; i &amp;lt; m; i++) &amp;#123;
        int x, y, z;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;
        path[x][y] = x;
        g[x][y] = min(g[x][y], z);
    &amp;#125;

    floyd();

    cin &amp;gt;&amp;gt; tx &amp;gt;&amp;gt; ty;
    cout &amp;lt;&amp;lt; g[tx][ty] &amp;lt;&amp;lt; endl;
    writePath(tx, ty);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-04T10:51:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/03/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89/</id>
        <title>树的深度优先遍历（邻接表）</title>
        <link rel="alternate" href="http://example.com/2023/02/03/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89/"/>
        <content type="html">&lt;h4 id=&#34;DFS&#34;&gt;&lt;a href=&#34;#DFS&#34; class=&#34;headerlink&#34; title=&#34;DFS&#34;&gt;&lt;/a&gt;DFS&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100;

int idx, n;
int h[N], e[N], ne[N];
bool st[N];

void ins(int a, int b)&amp;#123;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
&amp;#125;

void dfs(int u)&amp;#123;
    st[u] = true;
    cout &amp;lt;&amp;lt; u;
    for(int i = h[u]; i != -1; i = ne[i])&amp;#123;
        int j = e[i];
        if(!st[j]) dfs(j);
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    memset(h, -1, sizeof h);

    cin &amp;gt;&amp;gt; n;
    int a, b;

    while(n--)&amp;#123;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        ins(a, b);
    &amp;#125;

    dfs(1);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-03T10:24:20.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</id>
        <title>字符串哈希</title>
        <link rel="alternate" href="http://example.com/2023/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1010, P = 131;

unsigned long long h[N], p[N];
int n, m;
char str[N];

unsigned long long gethash(int l, int r)&amp;#123;
    return h[r] - h[l - 1] * p[r - l + 1];
&amp;#125;

int main()&amp;#123;
    scanf(&amp;quot;%d %d %s&amp;quot;, &amp;amp;n, &amp;amp;m, str + 1);

    p[0] = 1;
    for(int i = 1; i &amp;lt;= n; i++)&amp;#123;
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    &amp;#125;

    int l1, r1, l2, r2;
    while(m--)&amp;#123;
        scanf(&amp;quot;%d %d %d %d&amp;quot;, &amp;amp;l1, &amp;amp;r1, &amp;amp;l2, &amp;amp;r2);
        if(gethash(l1, r1) == gethash(l2, r2)) printf(&amp;quot;Yes\n&amp;quot;);
        else printf(&amp;quot;No\n&amp;quot;);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-02T08:36:57.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/</id>
        <title>小根堆</title>
        <link rel="alternate" href="http://example.com/2023/02/01/%E5%B0%8F%E6%A0%B9%E5%A0%86/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1e6+10;

int hp[N], idx;
int n;

void down(int k)&amp;#123;
    int t = k;
    if(hp[k &amp;lt;&amp;lt; 1] &amp;lt; hp[t] &amp;amp;&amp;amp; (k &amp;lt;&amp;lt; 1) &amp;lt;= idx) t = k &amp;lt;&amp;lt; 1;
    if(hp[k &amp;lt;&amp;lt; 1 | 1] &amp;lt; hp[t] &amp;amp;&amp;amp; (k &amp;lt;&amp;lt; 1 | 1) &amp;lt;= idx) t = k &amp;lt;&amp;lt; 1 | 1;
    if(t != k)&amp;#123;
        swap(hp[k], hp[t]);
        down(t);
    &amp;#125;
&amp;#125;

void up(int k)&amp;#123;
    while(k &amp;gt;&amp;gt; 1 &amp;amp;&amp;amp; hp[k &amp;gt;&amp;gt; 1] &amp;gt; hp[k])&amp;#123;
        swap(hp[k &amp;gt;&amp;gt; 1], hp[k]);
        k &amp;gt;&amp;gt;= 1;
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);

    int x, y;
    while(n--)&amp;#123;
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;x);
        if(x == 1)&amp;#123;
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;y);
            hp[++idx] = y;
            up(idx);
        &amp;#125;else if(x == 2) printf(&amp;quot;%d\n&amp;quot;, hp[1]);
        else hp[1] = hp[idx], idx--, down(1);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-02-01T10:38:45.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/01/31/%E9%9B%86%E5%90%88%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
        <title>集合与并查集</title>
        <link rel="alternate" href="http://example.com/2023/01/31/%E9%9B%86%E5%90%88%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
        <content type="html">&lt;h4 id=&#34;集合&#34;&gt;&lt;a href=&#34;#集合&#34; class=&#34;headerlink&#34; title=&#34;集合&#34;&gt;&lt;/a&gt;集合&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 100010;

int son[N][26], cnt[N], idx;
int n;

void insert(string str)&amp;#123;
    int p = 0;
    for(int i = 0; str[i]; i++)&amp;#123;
        int u = str[i] - &amp;#39;a&amp;#39;;
        if(!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    &amp;#125;
    cnt[p]++;
&amp;#125;

int query(string str)&amp;#123;
    int p = 0;
    for(int i = 0; str[i]; i++)&amp;#123;
        int u = str[i] - &amp;#39;a&amp;#39;;
        if(!son[p][u]) return 0;
        p = son[p][u];
    &amp;#125;

    return cnt[p];
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    while(n--)&amp;#123;
        char op;
        string str;
        cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; str;
        if(op == &amp;#39;I&amp;#39;) insert(str);
        else printf(&amp;quot;%d\n&amp;quot;, query(str)); 
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;并查集&#34;&gt;&lt;a href=&#34;#并查集&#34; class=&#34;headerlink&#34; title=&#34;并查集&#34;&gt;&lt;/a&gt;并查集&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 10010;

int p[N], n, m;

int find(int x)&amp;#123;
    if(p[x] != x) p[x] = find(p[x]);
    return x;
&amp;#125;

int main()&amp;#123;
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for(int i = 1; i &amp;lt;= n; i++) p[i] = i;

    while(m--)&amp;#123;
        int z, x, y;
        scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;z, &amp;amp;x, &amp;amp;y);
        if(z == 1) p[find(x)] = find(y);
        else&amp;#123;
            if(find(x) == find(y)) printf(&amp;quot;Y\n&amp;quot;);
            else printf(&amp;quot;N\n&amp;quot;);
        &amp;#125;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="模板" />
        <updated>2023-01-31T10:11:00.000Z</updated>
    </entry>
</feed>
