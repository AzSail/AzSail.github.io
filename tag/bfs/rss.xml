<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>書架 • Posts by &#34;bfs&#34; tag</title>
        <link>http://example.com</link>
        <description>花店不开了，花继续开</description>
        <language>zh-CN</language>
        <pubDate>Thu, 05 Jan 2023 17:40:00 +0800</pubDate>
        <lastBuildDate>Thu, 05 Jan 2023 17:40:00 +0800</lastBuildDate>
        <category>BFS</category>
        <category>算法</category>
        <category>Resilio Sync</category>
        <category>unity</category>
        <category>WolfraAlpha</category>
        <category>数论</category>
        <category>github</category>
        <category>linux</category>
        <category>Open-cv</category>
        <category>碧蓝航线</category>
        <category>Python</category>
        <category>模板</category>
        <category>局域网</category>
        <category>阅读</category>
        <category>相册</category>
        <category>算法模板</category>
        <item>
            <guid isPermalink="true">http://example.com/2023/01/05/BFS%E6%A8%A1%E6%9D%BF/</guid>
            <title>BFS模板</title>
            <link>http://example.com/2023/01/05/BFS%E6%A8%A1%E6%9D%BF/</link>
            <category>BFS</category>
            <pubDate>Thu, 05 Jan 2023 17:40:00 +0800</pubDate>
            <description><![CDATA[ &lt;h4 id=&#34;题目&#34;&gt;&lt;a href=&#34;#题目&#34; class=&#34;headerlink&#34; title=&#34;题目&#34;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行，&lt;/p&gt;
&lt;p&gt;对于每一组数据，输出吃到奶酪的最少单位时间。&lt;/p&gt;
&lt;p&gt;若无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。&lt;/p&gt;
&lt;p&gt;在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。&lt;/p&gt;
&lt;h4 id=&#34;模板&#34;&gt;&lt;a href=&#34;#模板&#34; class=&#34;headerlink&#34; title=&#34;模板&#34;&gt;&lt;/a&gt;模板&lt;/h4&gt;&lt;h6 id=&#34;二维&#34;&gt;&lt;a href=&#34;#二维&#34; class=&#34;headerlink&#34; title=&#34;二维&#34;&gt;&lt;/a&gt;二维&lt;/h6&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 210;

// 方向偏移量
int dx[4] = &amp;#123;-1, 0, 1, 0&amp;#125;;
int dy[4] = &amp;#123;0, 1, 0, -1&amp;#125;;
// 距离
int dist[N][N];
int n, m;
pair&amp;lt;int, int&amp;gt; start;
pair&amp;lt;int, int&amp;gt; ed;
// 迷宫
char g[N][N];

int bfs(pair&amp;lt;int, int&amp;gt; s, pair&amp;lt;int, int&amp;gt; e)&amp;#123;
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
    memset(dist, -1, sizeof dist);

    dist[s.first][s.second] = 0;						// 起点
    q.push(s);

    while(!q.empty())&amp;#123;
        pair&amp;lt;int, int&amp;gt; t = q.front();
        q.pop();

        if(t == e) return dist[t.first][t.second];			// 判断是否终点

        for(int i = 0; i &amp;lt; 4; i++)&amp;#123;
            int x = t.first + dx[i];
            int y = t.second + dy[i];
            if(x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= n || y &amp;gt;= m) continue;	// 越界
            if(g[x][y] == &amp;#39;#&amp;#39;) continue;				// 碰墙
            if(dist[x][y] != -1) continue;				// 已遍历

            dist[x][y] = dist[t.first][t.second] + 1;		// 距离加一
            q.push(&amp;#123;x, y&amp;#125;);
        &amp;#125;
    &amp;#125;

    return -1;
&amp;#125;

int main()&amp;#123;
    int t;
    cin &amp;gt;&amp;gt; t;
    while(t--)&amp;#123;
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;m);
        for(int i = 0; i &amp;lt; n; i++) scanf(&amp;quot;%s&amp;quot;, g[i]);
        for(int i = 0; i &amp;lt; n; i++)&amp;#123;
            for(int j = 0; j &amp;lt; m; j++)&amp;#123;
                if(g[i][j] == &amp;#39;S&amp;#39;) start = &amp;#123;i, j&amp;#125;;
                if(g[i][j] == &amp;#39;E&amp;#39;) ed = &amp;#123;i, j&amp;#125;;
            &amp;#125;
        &amp;#125;

        int d = bfs(start, ed);
        if(d == -1) printf(&amp;quot;oop!\n&amp;quot;);
        else printf(&amp;quot;%d\n&amp;quot;, d);
    &amp;#125;


    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;三维&#34;&gt;&lt;a href=&#34;#三维&#34; class=&#34;headerlink&#34; title=&#34;三维&#34;&gt;&lt;/a&gt;三维&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 101;

pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; start, ed, tmp;
char g[N][N][N];
int st[N][N][N];
int dy[4] = &amp;#123;-1, 0, 1, 0&amp;#125;;
int dz[4] = &amp;#123;0, -1, 0, 1&amp;#125;;
int l, r, c;

int bfs(pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; s, pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; e)&amp;#123;
    memset(st, -1, sizeof st);
    queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; q;
    st[s.first][s.second.first][s.second.second] = 0;
    q.push(s);

    while(!q.empty())&amp;#123;
        tmp = q.front();
        q.pop();
        if(tmp == e) return st[tmp.first][tmp.second.first][tmp.second.second];
    
        int x = tmp.first, y, z;
    
        if(x + 1 &amp;lt; l &amp;amp;&amp;amp; st[x + 1][tmp.second.first][tmp.second.second] == -1 &amp;amp;&amp;amp; g[x + 1][tmp.second.first][tmp.second.second] != &amp;#39;#&amp;#39;)&amp;#123;
            st[x + 1][tmp.second.first][tmp.second.second] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x + 1, &amp;#123;tmp.second.first, tmp.second.second&amp;#125;&amp;#125;);
        &amp;#125;
        if(x - 1 &amp;gt;= 0 &amp;amp;&amp;amp; st[x - 1][tmp.second.first][tmp.second.second] == -1 &amp;amp;&amp;amp; g[x - 1][tmp.second.first][tmp.second.second] != &amp;#39;#&amp;#39;)&amp;#123;
            st[x - 1][tmp.second.first][tmp.second.second] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x - 1, &amp;#123;tmp.second.first, tmp.second.second&amp;#125;&amp;#125;);
        &amp;#125;
    
        for(int i = 0; i &amp;lt; 4; i++)&amp;#123;
            y = tmp.second.first + dy[i];
            z = tmp.second.second + dz[i];
            if(st[x][y][z] != -1) continue;
            if(y &amp;lt; 0 || z &amp;lt; 0 || y &amp;gt;= r || z &amp;gt;= c) continue;
            if(g[x][y][z] == &amp;#39;#&amp;#39;) continue;
        
            st[x][y][z] = st[tmp.first][tmp.second.first][tmp.second.second] + 1;
            q.push(&amp;#123;x, &amp;#123;y, z&amp;#125;&amp;#125;);
        &amp;#125;
    
    
    &amp;#125;

    return -1;
&amp;#125;

int main()&amp;#123;
    while(1)&amp;#123;
        cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;
        if(l == 0) break;
        for(int i = 0; i &amp;lt; l; i++)
            for(int j = 0; j &amp;lt; r; j++) 
                scanf(&amp;quot;%s&amp;quot;, g[i][j]);
    
        for(int i = 0; i &amp;lt; l; i++)
            for(int j = 0; j &amp;lt; r; j++)
                for(int z = 0; z &amp;lt; c; z++)
                    if(g[i][j][z] == &amp;#39;S&amp;#39;) start = &amp;#123;i, &amp;#123;j, z&amp;#125;&amp;#125;;
                    else if(g[i][j][z] == &amp;#39;E&amp;#39;) ed = &amp;#123;i, &amp;#123;j, z&amp;#125;&amp;#125;;
    
        int step = bfs(start, ed);
        if(step == -1) printf(&amp;quot;Trapped!\n&amp;quot;);
        else printf(&amp;quot;Escaped in %d minute(s).\n&amp;quot;, step);
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
