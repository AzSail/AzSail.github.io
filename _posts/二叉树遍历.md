---
layout: post
cid: 66
title: 二叉树遍历
slug: 66
date: 2021/10/28 17:03:28
updated: 2021/10/28 17:03:28
status: publish
author: mi0e
categories: 
  - 编程
  - 算法
  - C/C++
tags: 
customSummary: 
mathjax: auto
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
using namespace std;

struct tree{
	int left;
	int right;
};

tree t[1000];

int dfs(int n){		// 深度 
	if(!n) return 0;
	return max(dfs(t[n].left), dfs(t[n].right)) + 1;
}

void f(int n){		// 先序 
	cout << n << " ";
	if(t[n].left) f(t[n].left);
	if(t[n].right) f(t[n].right);
}

void s(int n){		// 中序 
	if(t[n].left) s(t[n].left);
	cout << n << " ";
	if(t[n].right) s(t[n].right);
}

void e(int n){		// 后序 
	if(t[n].left) e(t[n].left);
	if(t[n].right) e(t[n].right);
	cout << n << " ";
}

int main(void){
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> t[i].left >> t[i].right;
	
	return 0;
} 
```
