---
title: 树的重构
date: 2023-02-18 18:45:35
tags:
  - 模板
categories: 
  - C/C++
  - 算法
---

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 35;

int in[N], post[N];
int n;
map<int, int> l, r, pos;

int f(int il, int ir, int pl, int pr){
    int root = post[pr];
    int k = pos[root];
    if (il < k) l[root] = f(il, k - 1, pl, pl + k - 1 - il);
    if (ir > k) r[root] = f(k + 1, ir, pl + k - il, pr - 1);
    return root;
}

void bfs(int root){
    queue<int> q;
    q.push(root);
    while (q.size()) {
        int x = q.front();
        q.pop();
        cout << x << " ";
        if (l[x]) q.push(l[x]);
        if (r[x]) q.push(r[x]);
    }
}

int main(){
    cin >> n;
    
    for (int i = 1; i <= n; i++) cin >> post[i];
    
    for (int i = 1; i <= n; i++) cin >> in[i], pos[in[i]] = i;
    
    int root = f(1, n, 1, n);
    
    bfs(root);
    
    return 0;
}
```