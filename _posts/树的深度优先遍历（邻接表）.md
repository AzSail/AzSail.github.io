---
layout: post
cid: 175
title: 树的深度优先遍历（邻接表）
slug: 175
date: 2023/02/03 18:24:20
updated: 2023/02/03 18:24:20
status: publish
author: mi0e
categories: 
  - 算法
tags: 
  - 模板
customSummary: 
mathjax: auto
noThumbInfoEmoji: 
noThumbInfoStyle: default
outdatedNotice: no
parseWay: auto
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


#### DFS

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100;

int idx, n;
int h[N], e[N], ne[N];
bool st[N];

void ins(int a, int b){
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}

void dfs(int u){
	st[u] = true;
	cout << u;
	for(int i = h[u]; i != -1; i = ne[i]){
		int j = e[i];
		if(!st[j]) dfs(j);
	}
}

int main(){
	memset(h, -1, sizeof h);

	cin >> n;
	int a, b;

	while(n--){
		cin >> a >> b;
		ins(a, b);
	}

	dfs(1);

	return 0;
}
```
