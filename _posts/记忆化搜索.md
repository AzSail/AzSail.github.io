---
title: 记忆化搜索
date: 2023-02-15 21:25:22
tags:
  - 模板
categories: 
  - C/C++
  - 算法
math: true
---

## 题目描述

Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：

```plain
1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
```

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 **24−17−16−1**（从 **24** 开始，在 **1** 结束）。当然 **25－24－23－…－3－2－1** 更长。事实上，这是最长的一条。

## 输入格式

输入的第一行为表示区域的二维数组的行数 **R** 和列数 **C**。下面是 **R** 行，每行有 **C** 个数，代表高度(两个数字之间用 **1** 个空格间隔)。

## 输出格式

输出区域中最长滑坡的长度。

## 输入输出样例

**输入 #1**

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

**输出 #1**

```
25
```

## AC

```cpp
#include <bits/stdc++.h>
using namespace std;   
const int N = 105;

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
int h[N][N], dp[N][N];
int n, m;

int dfs(int x, int y){
    if (dp[x][y] != 0) return dp[x][y];     \\ 已经遍历过
  
    for (int k = 0; k < 4; k++) {
        int tx = x + dx[k];
        int ty = y + dy[k];
        if (tx <= 0 || tx > n || ty <= 0 || ty > m) continue;
        if (h[x][y] > h[tx][ty]) dp[x][y] = max(dp[x][y], dfs(tx, ty) + 1);
    }
  
    return dp[x][y];
}

int main(){
    cin >> n >> m;
  
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> h[i][j];
          
    int res = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            res = max(res, dfs(i, j));
  
    cout << res + 1;

    return 0;
}